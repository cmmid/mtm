[
  {
    "objectID": "00_01_3_IntroToR_solutions.html",
    "href": "00_01_3_IntroToR_solutions.html",
    "title": "P01. Introduction to R, part 3: solutions",
    "section": "",
    "text": "A. Read in the same data as before\nThis file can be downloaded from here.\n\nmyTBdata &lt;- read.table(\"TB_stats.txt\", header=TRUE)\n\nB. Plot the mortality in HIV negative against HIV positive check the plot function help file\n\n?plot\n\nplot is a generic function, and depending on what type of data you pass the function R will use different sub-functions (you dont need to worry about how it handles this!).\n\n# make the plot\nplot(x=myTBdata$HIV_neg_TB_mortality, y=myTBdata$HIV_pos_TB_mortality)\n\n\n\n\n\n\n\n\nC. Add meaningful axes labels\n\nplot(x=myTBdata$HIV_neg_TB_mortality, \n     y=myTBdata$HIV_pos_TB_mortality,\n     xlab=\"Mortality in HIV negative people\",\n     ylab=\"Mortality in HIV positive people\")\n\n\n\n\n\n\n\n\nD. Add a meaningful title\n\nplot(x=myTBdata$HIV_neg_TB_mortality, \n     y=myTBdata$HIV_pos_TB_mortality,\n     xlab=\"Mortality in HIV negative people\",\n     ylab=\"Mortality in HIV positive people\",\n     main=\"Comparison of mortality in HIV negative and positive\")\n\n\n\n\n\n\n\n\nE. Change the colour of the points to red\n\nplot(x=myTBdata$HIV_neg_TB_mortality, \n     y=myTBdata$HIV_pos_TB_mortality,\n     xlab=\"Mortality in HIV negative people\",\n     ylab=\"Mortality in HIV positive people\",\n     main=\"Comparison of mortality in HIV negative and positive\",\n     col=\"red\")\n\n\n\n\n\n\n\n\nF. It’s hard to see the numbers because some are small and some very large\nUsing a log scale is useful for that.You can either log the values and re-plot, or use the log option in plot()\n\nplot(x=myTBdata$HIV_neg_TB_mortality, \n     y=myTBdata$HIV_pos_TB_mortality,\n     xlab=\"Mortality in HIV negative people\",\n     ylab=\"Mortality in HIV positive people\",\n     main=\"Comparison of mortality in HIV negative and positive\",\n     col=\"red\",\n     log=\"xy\")\n\n\n\n\n\n\n\n\nG. Now let’s make a different kind of plot\nShow the distribution of Total_TB_mortality in a histogram and then change the x axis label. Note, same options as before.\n\nhist(myTBdata$Total_TB_mortality)\n\n\n\n\n\n\n\nhist(myTBdata$Total_TB_mortality,\n     xlab=\"Number\")\n\n\n\n\n\n\n\n\nNow add a meaningful title to the plot\n\nhist(myTBdata$Total_TB_mortality,\n     xlab=\"Number\",\n     main = \"Total TB mortality\")\n\n\n\n\n\n\n\n\nH. Check what other aspects of the histogram you can change\n\n?hist\n\nThen change the color to “blue” in the last plot\n\nhist(myTBdata$Total_TB_mortality,\n     xlab=\"Number\",\n     main=\"Total TB mortality\",\n     col=\"blue\")\n\n\n\n\n\n\n\n\nI. Now let’s plot a histogram of mortality per 1000\nAnd add a title, and x axis label.\nHint: calculate it as in the previous practical\n\nmyTBdata[,\"MortalityPer1000\"] &lt;- myTBdata[,\"Total_TB_mortality\"]*1000/myTBdata[,\"Population\"]\nhist(myTBdata$MortalityPer1000,\n     xlab = \"Mortality per 1000\",\n     main = \"TB mortality per 1000 population\")\n\n\n\n\n\n\n\n\nchange the color to something different hint: to find more colours, run “colors()” or google “Colors in R”\n\nhist(myTBdata$MortalityPer1000,\n     xlab = \"Mortality per 1000\",\n     main = \"TB mortality per 1000 population\",\n     col = \"dodgerblue1\")\n\n\n\n\n\n\n\n\nJ. Now let’s show both histograms at the same time you need to make a call to “par”, short for parameters, setting the plot parameter “mfrow” (Multi-Figure ROW-wise) gives 1 row, and 2 columns of plot\n\npar(mfrow=c(1,2))\nhist(myTBdata$Total_TB_mortality,\n     xlab=\"Number\",\n     main=\"Total TB mortality\",\n     col=\"blue\")\n\nhist(myTBdata$MortalityPer1000,\n     xlab = \"Mortality per 1000\",\n     main = \"TB mortality per 1000 population\",\n     col = \"dodgerblue1\")\n\n\n\n\n\n\n\n\ncut and paste your plot code from I. here and run it. Then resize the plot window and see what happens\nK. Export the figure and save it as a PNG with a useful name\nHint: use the Export button in the plot window\nL. R has functions for every kind of plot for example:\n\n?barplot\n?boxplot\n?contour\n\nand stackoverflow.com has a lot of comments and help on every kind of plot\nAdvanced plotting exercises\nMake a plot where:\n\nx=Total_TB_mortality and y=HIV_pos_TB_mortality\nboth aces are on the on the log scale\ncolour the points\nadd axis labels and a title\n\n\nplot(x=myTBdata$Total_TB_mortality, \n     y=myTBdata$HIV_pos_TB_mortality,\n     xlab=\"Total TB mortality\",\n     ylab=\"Mortality in HIV positive people\",\n     main=\"Total TB mortality vs in HIV positive people\",\n     col=\"red\", \n     log=\"xy\")\n\n\n\n\n\n\n\n\nadd HIV_neg_TB_mortality on the same y axis, in a different colour.\nHint: use points(). see ?points for information\n\nplot(x=myTBdata$Total_TB_mortality, \n     y=myTBdata$HIV_pos_TB_mortality,\n     xlab=\"Total TB mortality\",\n     ylab=\"Mortality in HIV positive people\",\n     main=\"Total TB mortality vs in HIV positive people\",\n     col=\"red\", \n     log=\"xy\")\npoints(x=myTBdata$Total_TB_mortality, \n       y=myTBdata$HIV_neg_TB_mortality,\n     col=\"blue\")\n\n\n\n\n\n\n\n\ndo you need to change the y axis label? i.e. does it still make sense now that it shows negative and positive mortality?\nAnswer: You’ll need to change the y axis label.\nSome of the points no longer fit on the graph. Why is this? You need to alter the y limit (ylim), which is an option of plot. What value will you choose?\nHint: the maximum value that the data go to change the ylim of the plot.\n\nplot(x=myTBdata$Total_TB_mortality, \n     y=myTBdata$HIV_pos_TB_mortality,\n     xlab=\"Total TB mortality\",\n     ylab=\"Mortality in HIV positive people\",\n     main=\"Total TB mortality vs in HIV positive people\",\n     col=\"red\", \n     log=\"xy\",\n     ylim=c(1, max(myTBdata$HIV_neg_TB_mortality, myTBdata$HIV_pos_TB_mortality)))\npoints(x=myTBdata$Total_TB_mortality, y=myTBdata$HIV_neg_TB_mortality,\n       col=\"blue\")\n\n\n\n\n\n\n\n\nThe plot now has 2 data sets in different colours, so it needs a legend check the help of legend (there’s a lot of options!)\nHint: use x=“topright” instead of setting the x and y values for location.\nHint: use the option “fill” to change the colours\n\nplot(x=myTBdata$Total_TB_mortality, \n     y=myTBdata$HIV_pos_TB_mortality,\n     xlab=\"Total TB mortality\",\n     ylab=\"Mortality in HIV positive people\",\n     main=\"Total TB mortality vs in HIV positive people\",\n     col=\"red\", \n     log=\"xy\",\n     ylim=c(1, max(myTBdata$HIV_neg_TB_mortality, myTBdata$HIV_pos_TB_mortality)))\npoints(x=myTBdata$Total_TB_mortality, y=myTBdata$HIV_neg_TB_mortality,\n       col=\"blue\")\nlegend(x=\"topright\", legend=c(\"HIV pos\", \"HIV neg\"), fill=c(\"red\", \"blue\"))"
  },
  {
    "objectID": "08_StochasticIBM_solutions.html",
    "href": "08_StochasticIBM_solutions.html",
    "title": "08. Stochastic individual-based models (solutions)",
    "section": "",
    "text": "# Individual-based SARS-CoV-2 transmission model, practical 1\nlibrary(ggplot2)\n\n\n## Model parameters\nbeta &lt;- 0.5        # Transmission parameter\ndelta &lt;- 1 / 2.5   # Rate of transitioning out of latent state\ngamma &lt;- 1 / 5     # Rate of transitioning out of infectious state\nomega &lt;- 1 / 180   # Rate of waning immunity\n\ndt &lt;- 1            # Time step of simulation (1 day)\ndays &lt;- 365        # Duration of simulation (365 days)\nsteps &lt;- days / dt # Total number of time steps\nn &lt;- 1000          # Population size\n\n\n## Data frame to store simulation results\nresults &lt;- data.frame(ts = 1:steps, S = 0, E = 0, I = 0, R = 0)\n\n\n## Initialize simulation\n\n# Set the seed for the pseudorandom number generator, for reproducibility\nset.seed(12345)\n\n# Since this is an individual-based model, we track the properties of all n\n# individuals in the simulation. One kind of property we can track is a state,\n# such as S (susceptible), E (exposed), I (infectious), or R (recovered). We\n# will store each individual's state as a string, either \"S\", \"E\", \"I\", or \"R\".\n\nstate &lt;- rep(\"S\", n)   # Each individual's state: start with all susceptible\nstate[1:10] &lt;- \"E\"     # Start 10 individuals in the \"exposed\" state\n\n\n## Run simulation\n\n# We'll use the built-in function txtProgressBar to track the simulation's\n# progress. Really helps for planning coffee breaks! It needs to know the\n# minimum and maximum values to expect, and style = 3 tells it to report the\n# percentage complete.\nbar &lt;- txtProgressBar(min = 1, max = steps, style = 3)\n\n# Loop over each time step . . .\nfor (ts in 1:steps) {\n    # Calculate the force of infection\n    lambda &lt;- beta * sum(state == \"I\") / n\n\n    # Loop through each individual . . .\n    for (i in 1:n) {\n        if (state[i] == \"S\") {\n            # Transition S -&gt; E (infection) at rate lambda\n            if (runif(1) &lt; 1 - exp(-lambda * dt)) {\n                state[i] &lt;- \"E\"\n            }\n        } else if (state[i] == \"E\") {\n            # Transition E -&gt; I (latent to infectious) at rate delta\n            if (runif(1) &lt; 1 - exp(-delta * dt)) {\n                state[i] &lt;- \"I\"\n            }\n        } else if (state[i] == \"I\") {\n            # Transition I -&gt; R (infectious to recovered) at rate gamma\n            if (runif(1) &lt; 1 - exp(-gamma * dt)) {\n                state[i] &lt;- \"R\"\n            }\n        } else if (state[i] == \"R\") {\n            # Transition R -&gt; S (waning of immunity) at rate omega\n            if (runif(1) &lt; 1 - exp(-omega * dt)) {\n                state[i] &lt;- \"S\"\n            }\n        }\n    }\n\n    # Save population state for this time step\n    results[ts, \"S\"] &lt;- sum(state == \"S\")\n    results[ts, \"E\"] &lt;- sum(state == \"E\")\n    results[ts, \"I\"] &lt;- sum(state == \"I\")\n    results[ts, \"R\"] &lt;- sum(state == \"R\")\n\n    # Update progress bar; close progress bar if we are finished\n    setTxtProgressBar(bar, ts)\n    if (ts == steps) {\n        close(bar)\n    }\n}\n\n## Plot simulation results\nggplot(results) +\n    geom_line(aes(x = ts, y = S, colour = \"S\")) +\n    geom_line(aes(x = ts, y = E, colour = \"E\")) +\n    geom_line(aes(x = ts, y = I, colour = \"I\")) +\n    geom_line(aes(x = ts, y = R, colour = \"R\"))"
  },
  {
    "objectID": "08_StochasticIBM_solutions.html#practical-1.-an-individual-based-seir-model-of-sars-cov-2-transmission",
    "href": "08_StochasticIBM_solutions.html#practical-1.-an-individual-based-seir-model-of-sars-cov-2-transmission",
    "title": "08. Stochastic individual-based models (solutions)",
    "section": "",
    "text": "# Individual-based SARS-CoV-2 transmission model, practical 1\nlibrary(ggplot2)\n\n\n## Model parameters\nbeta &lt;- 0.5        # Transmission parameter\ndelta &lt;- 1 / 2.5   # Rate of transitioning out of latent state\ngamma &lt;- 1 / 5     # Rate of transitioning out of infectious state\nomega &lt;- 1 / 180   # Rate of waning immunity\n\ndt &lt;- 1            # Time step of simulation (1 day)\ndays &lt;- 365        # Duration of simulation (365 days)\nsteps &lt;- days / dt # Total number of time steps\nn &lt;- 1000          # Population size\n\n\n## Data frame to store simulation results\nresults &lt;- data.frame(ts = 1:steps, S = 0, E = 0, I = 0, R = 0)\n\n\n## Initialize simulation\n\n# Set the seed for the pseudorandom number generator, for reproducibility\nset.seed(12345)\n\n# Since this is an individual-based model, we track the properties of all n\n# individuals in the simulation. One kind of property we can track is a state,\n# such as S (susceptible), E (exposed), I (infectious), or R (recovered). We\n# will store each individual's state as a string, either \"S\", \"E\", \"I\", or \"R\".\n\nstate &lt;- rep(\"S\", n)   # Each individual's state: start with all susceptible\nstate[1:10] &lt;- \"E\"     # Start 10 individuals in the \"exposed\" state\n\n\n## Run simulation\n\n# We'll use the built-in function txtProgressBar to track the simulation's\n# progress. Really helps for planning coffee breaks! It needs to know the\n# minimum and maximum values to expect, and style = 3 tells it to report the\n# percentage complete.\nbar &lt;- txtProgressBar(min = 1, max = steps, style = 3)\n\n# Loop over each time step . . .\nfor (ts in 1:steps) {\n    # Calculate the force of infection\n    lambda &lt;- beta * sum(state == \"I\") / n\n\n    # Loop through each individual . . .\n    for (i in 1:n) {\n        if (state[i] == \"S\") {\n            # Transition S -&gt; E (infection) at rate lambda\n            if (runif(1) &lt; 1 - exp(-lambda * dt)) {\n                state[i] &lt;- \"E\"\n            }\n        } else if (state[i] == \"E\") {\n            # Transition E -&gt; I (latent to infectious) at rate delta\n            if (runif(1) &lt; 1 - exp(-delta * dt)) {\n                state[i] &lt;- \"I\"\n            }\n        } else if (state[i] == \"I\") {\n            # Transition I -&gt; R (infectious to recovered) at rate gamma\n            if (runif(1) &lt; 1 - exp(-gamma * dt)) {\n                state[i] &lt;- \"R\"\n            }\n        } else if (state[i] == \"R\") {\n            # Transition R -&gt; S (waning of immunity) at rate omega\n            if (runif(1) &lt; 1 - exp(-omega * dt)) {\n                state[i] &lt;- \"S\"\n            }\n        }\n    }\n\n    # Save population state for this time step\n    results[ts, \"S\"] &lt;- sum(state == \"S\")\n    results[ts, \"E\"] &lt;- sum(state == \"E\")\n    results[ts, \"I\"] &lt;- sum(state == \"I\")\n    results[ts, \"R\"] &lt;- sum(state == \"R\")\n\n    # Update progress bar; close progress bar if we are finished\n    setTxtProgressBar(bar, ts)\n    if (ts == steps) {\n        close(bar)\n    }\n}\n\n## Plot simulation results\nggplot(results) +\n    geom_line(aes(x = ts, y = S, colour = \"S\")) +\n    geom_line(aes(x = ts, y = E, colour = \"E\")) +\n    geom_line(aes(x = ts, y = I, colour = \"I\")) +\n    geom_line(aes(x = ts, y = R, colour = \"R\"))"
  },
  {
    "objectID": "08_StochasticIBM_solutions.html#practical-2.-adding-more-complex-dynamics-to-the-model",
    "href": "08_StochasticIBM_solutions.html#practical-2.-adding-more-complex-dynamics-to-the-model",
    "title": "08. Stochastic individual-based models (solutions)",
    "section": "Practical 2. Adding more complex dynamics to the model",
    "text": "Practical 2. Adding more complex dynamics to the model\n\n# Individual-based SARS-CoV-2 transmission model, practical 2\nlibrary(ggplot2)\n\n\n## Model parameters\nbeta &lt;- 0.5        # Transmission parameter\niota &lt;- 1e-5       # Importation rate\nwane &lt;- 0.05       # Rate of antibody waning\n\ndt &lt;- 1            # Time step of simulation (1 day)\ndays &lt;- 365 * 2    # Duration of simulation (2 years)\nsteps &lt;- days / dt # Total number of time steps\nn &lt;- 1000          # Population size\n\n\n## Some helper functions\n# Calculates infectiousness as a function of state and age: zero if state is\n# not \"I\"; nonzero if state is \"I\", and slightly decreasing with age\ninfectiousness &lt;- function(state, age) {\n    ifelse(state == \"I\", 1.25 - age / 160, 0)\n}\n\n# Calculates susceptibility of individuals with antibody level(s) ab\nsusceptibility &lt;- function(ab) {\n    pnorm(ab, 5, 1)\n}\n\n# Generates n random delays from the latent-period distribution\n# (approximately 2 days, on average)\nlatent_delay &lt;- function(n) {\n    rlnorm(n, meanlog = 0.5, sdlog = 0.6)\n}\n\n# Generates n random delays from the infectious-period distribution\n# (approximately 5 days, on average)\ninfectious_delay &lt;- function(n) {\n    rlnorm(n, meanlog = 1.5, sdlog = 0.5)\n}\n\n# Generates n random increments to antibody levels following recovery\nab_increment &lt;- function(n) {\n    rnorm(n, mean = 12, sd = 2)\n}\n\n\n## Data frame to store simulation results\nresults &lt;- data.frame(ts = 1:steps, S = 0, E = 0, I = 0, AMeanU = 0, AMeanV = 0)\n\n\n## Initialize simulation\n\n# Set the seed for the pseudorandom number generator, for reproducibility\nset.seed(12345)\n\n# Initialize state variables\nstate &lt;- rep(\"S\", n)   # Each individual's state: start with all susceptible\nage &lt;- runif(n, 0, 80) # Each individual's age: random distribution from 0 to 80\ndelay &lt;- rep(0, n)     # Delay for latent and infectious periods\nantib &lt;- rep(0, n)     # Antibody concentration for each individual\nvacc &lt;- rep(FALSE, n)  # Vaccinated status\n\nstate[1:10] &lt;- \"E\"     # Start 10 individuals in the \"exposed\" state\n\n\n## Run simulation\n\n# Initialize progress bar\nbar &lt;- txtProgressBar(min = 1, max = steps, style = 3)\n\n# Loop over each time step . . .\nfor (ts in 1:steps) {\n    # Calculate the force of infection\n    lambda &lt;- beta * sum(infectiousness(state, age)) / n + iota\n\n    # Loop through each individual . . .\n    for (i in 1:n) {\n        # Update individual i's non-state variables\n        # Time remaining in latent/infectious periods\n        delay[i] &lt;- delay[i] - dt\n        # Antibody waning\n        antib[i] &lt;- antib[i] - wane * dt\n        # Vaccination at time step 300 for over-40s\n        if ((ts == 300) && (age[i] &gt;= 40)) {\n            vacc[i] &lt;- TRUE\n            antib[i] &lt;- antib[i] + 2 * ab_increment(1)\n        }\n\n        # Update individual i's state\n        if (state[i] == \"S\") {\n            # Transition S -&gt; E (infection) at rate lambda\n            if (runif(1) &lt; 1 - exp(-lambda * dt)) {\n                if (runif(1) &gt; susceptibility(antib[i])) {\n                    state[i] &lt;- \"E\"\n                    delay[i] &lt;- latent_delay(1)\n                }\n            }\n        } else if (state[i] == \"E\") {\n            # Transition E -&gt; I (latent to infectious)\n            if (delay[i] &lt; 0) {\n                state[i] &lt;- \"I\"\n                delay[i] &lt;- infectious_delay(1)\n            }\n        } else if (state[i] == \"I\") {\n            # Transition I -&gt; S (infectious to susceptible)\n            if (delay[i] &lt; 0) {\n                state[i] &lt;- \"S\"\n                antib[i] &lt;- antib[i] + ab_increment(1)\n            }\n        }\n    }\n\n    # Save population state for this time step\n    results[ts, \"S\"] &lt;- sum(state == \"S\")\n    results[ts, \"E\"] &lt;- sum(state == \"E\")\n    results[ts, \"I\"] &lt;- sum(state == \"I\")\n    results[ts, \"AMeanU\"] &lt;- mean(antib[!vacc])\n    results[ts, \"AMeanV\"] &lt;- mean(antib[vacc])\n\n    # Update progress bar; close progress bar if we are finished\n    setTxtProgressBar(bar, ts)\n    if (ts == steps) {\n        close(bar)\n    }\n}\n\n## Plot simulation results\nggplot(results) +\n    geom_line(aes(x = ts, y = S, colour = \"S\")) +\n    geom_line(aes(x = ts, y = E, colour = \"E\")) +\n    geom_line(aes(x = ts, y = I, colour = \"I\"))\n\nggplot(results) +\n    geom_line(aes(x = ts, y = AMeanU, colour = \"Unvaccinated\")) +\n    geom_line(aes(x = ts, y = AMeanV, colour = \"Vaccinated\")) +\n    labs(x = \"Time step\", y = \"Mean antibody level\")"
  },
  {
    "objectID": "08_StochasticIBM_solutions.html#practical-3.-optimizing-the-model-to-run-faster",
    "href": "08_StochasticIBM_solutions.html#practical-3.-optimizing-the-model-to-run-faster",
    "title": "08. Stochastic individual-based models (solutions)",
    "section": "Practical 3. Optimizing the model to run faster",
    "text": "Practical 3. Optimizing the model to run faster\n\n# Individual-based SARS-CoV-2 transmission model, practical 3\nlibrary(ggplot2)\n\n\n## Model parameters\nbeta &lt;- 0.5        # Transmission parameter\niota &lt;- 1e-5       # Importation rate\nwane &lt;- 0.05       # Rate of antibody waning\n\ndt &lt;- 1            # Time step of simulation (1 day)\ndays &lt;- 365 * 4    # Duration of simulation (4 years)\nsteps &lt;- days / dt # Total number of time steps\nn &lt;- 5000          # Population size\n\n\n## Some helper functions\n# Calculates infectiousness as a function of state and age: zero if state is\n# not \"I\"; nonzero if state is \"I\", and slightly decreasing with age\ninfectiousness &lt;- function(state, age) {\n    ifelse(state == \"I\", 1.25 - age / 160, 0)\n}\n\n# Calculates susceptibility of individuals with antibody level(s) ab\nsusceptibility &lt;- function(ab) {\n    pnorm(ab, 5, 1)\n}\n\n# Generates n random delays from the latent-period distribution\n# (approximately 2 days, on average)\nlatent_delay &lt;- function(n) {\n    rlnorm(n, meanlog = 0.5, sdlog = 0.6)\n}\n\n# Generates n random delays from the infectious-period distribution\n# (approximately 5 days, on average)\ninfectious_delay &lt;- function(n) {\n    rlnorm(n, meanlog = 1.5, sdlog = 0.5)\n}\n\n# Generates n random increments to antibody levels following recovery\nab_increment &lt;- function(n) {\n    rnorm(n, mean = 12, sd = 2)\n}\n\n\n## Data frame to store simulation results\nresults &lt;- data.frame(ts = 1:steps, S = 0, E = 0, I = 0, AMeanU = 0, AMeanV = 0)\n\n\n## Initialize simulation\n\n# Set the seed for the pseudorandom number generator, for reproducibility\nset.seed(12345)\n\n# Initialize state variables\nstate &lt;- rep(\"S\", n)   # Each individual's state: start with all susceptible\nage &lt;- runif(n, 0, 80) # Each individual's age: random distribution from 0 to 80\ndelay &lt;- rep(0, n)     # Delay for latent and infectious periods\nantib &lt;- rep(0, n)     # Antibody concentration for each individual\nvacc &lt;- rep(FALSE, n)  # Vaccinated status\n\nstate[1:10] &lt;- \"E\"     # Start 10 individuals in the \"exposed\" state\n\n\n## Run simulation\n\n# Initialize progress bar\nbar &lt;- txtProgressBar(min = 1, max = steps, style = 3)\n\n# Loop over each time step . . .\nfor (ts in 1:steps) {\n    # Calculate the force of infection\n    lambda &lt;- beta * sum(infectiousness(state, age)) / n + iota\n\n    ##### NOTE - There is no inner loop over individuals anymore!\n\n    # Update non-state variables (for all individuals simultaneously)\n    # Time remaining in latent/infectious periods\n    delay &lt;- delay - dt\n    # Antibody waning\n    antib &lt;- antib - wane * dt\n    # Vaccination at time step 300 for over-40s\n    if (ts == 300) {\n        vacc[age &gt;= 40] &lt;- TRUE\n        antib[vacc] &lt;- antib[vacc] + 2 * ab_increment(sum(vacc))\n    }\n\n    # Update state variables (for all individuals simultaneously)\n    ##### trE selects all individuals who will transition states from S to E.\n    trE &lt;- (state == \"S\") & (runif(n) &lt; 1 - exp(-lambda * dt)) &\n      (runif(n) &gt; susceptibility(antib))\n    trI &lt;- (state == \"E\") & (delay &lt; 0)\n    trS &lt;- (state == \"I\") & (delay &lt; 0)\n\n    # Do state transitions\n    # transition S -&gt; E\n    state[trE] &lt;- \"E\"\n    delay[trE] &lt;- latent_delay(sum(trE))\n\n    # transition E -&gt; I\n    state[trI] &lt;- \"I\"\n    delay[trI] &lt;- infectious_delay(sum(trI))\n\n    # transition I -&gt; S\n    state[trS] &lt;- \"S\"\n    antib[trS] &lt;- antib[trS] + ab_increment(sum(trS))\n\n    # Save population state for this time step\n    results[ts, \"S\"] &lt;- sum(state == \"S\")\n    results[ts, \"E\"] &lt;- sum(state == \"E\")\n    results[ts, \"I\"] &lt;- sum(state == \"I\")\n    results[ts, \"AMeanU\"] &lt;- mean(antib[!vacc])\n    results[ts, \"AMeanV\"] &lt;- mean(antib[vacc])\n\n    # Update progress bar; close progress bar if we are finished\n    setTxtProgressBar(bar, ts)\n    if (ts == steps) {\n        close(bar)\n    }\n}\n\n## Plot simulation results\nggplot(results) +\n    geom_line(aes(x = ts, y = S, colour = \"S\")) +\n    geom_line(aes(x = ts, y = E, colour = \"E\")) +\n    geom_line(aes(x = ts, y = I, colour = \"I\"))\n\nggplot(results) +\n    geom_line(aes(x = ts, y = AMeanU, colour = \"Unvaccinated\")) +\n    geom_line(aes(x = ts, y = AMeanV, colour = \"Vaccinated\")) +\n    labs(x = \"Time step\", y = \"Mean antibody level\")\n\nReturn to the practical here."
  },
  {
    "objectID": "04_ODEs_practical.html",
    "href": "04_ODEs_practical.html",
    "title": "04. Ordinary differential equations (ODEs)",
    "section": "",
    "text": "The code below will solve the SI model with beta = 0.4 over 50 days with initial conditions S(0) = 99, I(0) = 1. Run the following lines including the plot() line to create a plot of the output\n\nlibrary(deSolve) # Load in the deSolve package. If the package is not installed, install using the install.packages() function\n# Define model function\n\nSI_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  N &lt;- S + I\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N\n  res &lt;- list(c(dS, dI))\n  return(res)\n}\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nstate &lt;- c( S = S_0, I = I_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SI_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar( mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines( output$time, output$I, lwd = 2, col = \"red\", type = \"l\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\"),\n       lty = c(1, 1), col = c(\"blue\", \"red\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow, let’s solve a Susceptible-Infected-Recovered set of ordinary equations. There are now states; Susceptible, Infected, Recovered. Once infected people recover at a rate gamma = 0.1. The code for the model function ONLY is given below.\n\n# Define model function \nSIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n  N &lt;- S + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dI, dR ))\n  return(res)\n}\n\n\n\n\n\n\n# Define parameter values\nparameters &lt;-\n\n# Define initial conditions\nN &lt;- 100\n\nstate &lt;-\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar(mfrow = c(1, 1))\nplot(output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n     xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend( \"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n        lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")\n\n\n\n\nHint: Recall that for an SIR model, the basic reproduction number, R_0 = beta / gamma\n\nparameters &lt;- \n\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\nThe code below has been written to solve a Susceptible-Exposed-Infected-Recovered model. In the model individuals can be in one of four states. Once infected, susceptible individuals move to the exposed class. Exposed individuals become infectious at a rate delta = 0.14.\n\n\n\n\n\n# Define model function \nSEIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[1]\n  I &lt;- state[2]\n  R &lt;- state[3]\n  N &lt;- S + E + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  delta &lt;- parms[\"delta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I ) / N\n  dE &lt;- (beta * S * I) / N - delta * E\n  dI &lt;- delta * E - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dI, dR))\n  return(res)\n}\n\n# Define parameters  \nparameters &lt;- c( beta = 0.4, gamma = 0.1)\n\n# Define time to run model\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0  &lt;- N - I_0\nR_0 &lt;- 0\nstate &lt;- c(S = S_0, E = 0, I = I_0, R = R_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SEIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlines(output$time, output$E, lwd = 2, col = \"cyan\")\nlegend(\"topright\", legend =  c(\"Susceptible\", \"Exposed\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\", \"cyan\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\nHere we assume that susceptible individuals are vaccinated at a rate v = 0.05. The vaccine is 100% effective, so once vaccinated, individuals cannot become infected. HINT: you will need to create a new class V, you can assume that the initial number of vaccinated individuals is 0.\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "04_ODEs_practical.html#solving-the-si-model-using-desolve",
    "href": "04_ODEs_practical.html#solving-the-si-model-using-desolve",
    "title": "04. Ordinary differential equations (ODEs)",
    "section": "",
    "text": "The code below will solve the SI model with beta = 0.4 over 50 days with initial conditions S(0) = 99, I(0) = 1. Run the following lines including the plot() line to create a plot of the output\n\nlibrary(deSolve) # Load in the deSolve package. If the package is not installed, install using the install.packages() function\n# Define model function\n\nSI_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  N &lt;- S + I\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N\n  res &lt;- list(c(dS, dI))\n  return(res)\n}\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nstate &lt;- c( S = S_0, I = I_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SI_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar( mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines( output$time, output$I, lwd = 2, col = \"red\", type = \"l\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\"),\n       lty = c(1, 1), col = c(\"blue\", \"red\"), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "04_ODEs_practical.html#solving-the-sir-model-using-desolve",
    "href": "04_ODEs_practical.html#solving-the-sir-model-using-desolve",
    "title": "04. Ordinary differential equations (ODEs)",
    "section": "",
    "text": "Now, let’s solve a Susceptible-Infected-Recovered set of ordinary equations. There are now states; Susceptible, Infected, Recovered. Once infected people recover at a rate gamma = 0.1. The code for the model function ONLY is given below.\n\n# Define model function \nSIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n  N &lt;- S + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dI, dR ))\n  return(res)\n}\n\n\n\n\n\n\n# Define parameter values\nparameters &lt;-\n\n# Define initial conditions\nN &lt;- 100\n\nstate &lt;-\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar(mfrow = c(1, 1))\nplot(output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n     xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend( \"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n        lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")\n\n\n\n\nHint: Recall that for an SIR model, the basic reproduction number, R_0 = beta / gamma\n\nparameters &lt;- \n\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "04_ODEs_practical.html#solving-the-seir-model-using-desolve",
    "href": "04_ODEs_practical.html#solving-the-seir-model-using-desolve",
    "title": "04. Ordinary differential equations (ODEs)",
    "section": "",
    "text": "The code below has been written to solve a Susceptible-Exposed-Infected-Recovered model. In the model individuals can be in one of four states. Once infected, susceptible individuals move to the exposed class. Exposed individuals become infectious at a rate delta = 0.14.\n\n\n\n\n\n# Define model function \nSEIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[1]\n  I &lt;- state[2]\n  R &lt;- state[3]\n  N &lt;- S + E + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  delta &lt;- parms[\"delta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I ) / N\n  dE &lt;- (beta * S * I) / N - delta * E\n  dI &lt;- delta * E - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dI, dR))\n  return(res)\n}\n\n# Define parameters  \nparameters &lt;- c( beta = 0.4, gamma = 0.1)\n\n# Define time to run model\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0  &lt;- N - I_0\nR_0 &lt;- 0\nstate &lt;- c(S = S_0, E = 0, I = I_0, R = R_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SEIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlines(output$time, output$E, lwd = 2, col = \"cyan\")\nlegend(\"topright\", legend =  c(\"Susceptible\", \"Exposed\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\", \"cyan\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\nHere we assume that susceptible individuals are vaccinated at a rate v = 0.05. The vaccine is 100% effective, so once vaccinated, individuals cannot become infected. HINT: you will need to create a new class V, you can assume that the initial number of vaccinated individuals is 0.\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "03_DiscreteDeterministic_solutions.html",
    "href": "03_DiscreteDeterministic_solutions.html",
    "title": "03. Discrete-time deterministic models: Solutions",
    "section": "",
    "text": "Click here to return to the practical."
  },
  {
    "objectID": "03_DiscreteDeterministic_solutions.html#a.-sir-model-from-lecture",
    "href": "03_DiscreteDeterministic_solutions.html#a.-sir-model-from-lecture",
    "title": "03. Discrete-time deterministic models: Solutions",
    "section": "A. SIR model from lecture",
    "text": "A. SIR model from lecture\n\nA.1 Implement the SIR model from the slides and plot the proportion of the population that is infectious.\nAnswer:\n\ntime_sir &lt;- seq(0, 20, by = 1)\ny_sir &lt;- matrix(data = NA,\n                nrow = length(time_sir),\n                ncol = 3)\n\nupdate_sir &lt;- function(t, y, parms){\n    beta  &lt;- parms[\"beta\"]\n    gamma &lt;- parms[\"gamma\"]\n    \n    out &lt;- c(-beta*y[1]*y[2],\n             beta*y[1]*y[2] - gamma*y[2],\n             + gamma*y[2])\n    \n    return(out)\n}\n\nparms_sir &lt;- c(beta = 1.3,\n               gamma = 0.23)\n\n# initial values at t=0\ny_sir[1, ] &lt;- c(0.99, 0.01, 0)\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- y_sir[i-1,] +\n        update_sir(time_sir[i],\n                   y_sir[i-1, ],\n                   parms_sir)\n}\n\nplot(x = time_sir, y = y_sir[,2], ylim = c(0,1))\n\n\n\n\n\n\n\n\nA.1.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nAnswer: After approximately 7 days, the proportion infectious is 0.6.\nA.1.(b) Approximately how long does it take for the susceptibles to go to 0?\nAnswer: After 13 days, the proportion susceptible is below 0.001\n\n\nA.2 Change the mean time spent infectious from 4.35 days to 2 days, keeping the rate of transmission the same.\nA.2.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nAnswer: After 8 days, the proportion infectious is 0.3\nA.2.(b) Approximately how long does it take for the susceptibles to go to 0?\nAnswer: After 20 days, the proportion susceptible is still above 0.05\n\nparms_sir &lt;- c(beta = 1.3,\n               gamma = 1/2)\n\ny_sir[1, ] &lt;- c(0.99, 0.01, 0)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- y_sir[i-1,] +\n        update_sir(time_sir[i],\n                   y_sir[i-1, ],\n                   parms_sir)\n}\n\nplot(x = time_sir, y = y_sir[,2], ylim = c(0,1))\n\n\n\nA.3 Change the mean time spent infectious back to 4.35 days and set the transmission rate to be half what is has been\nA.3.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nAnswer: After 14 days, the proportion infectious is approximately 0.31\nA.3.(b) Approximately how long does it take for the susceptibles to go to 0?\nAnswer: Even after 20 days, the susceptible group is 0.1 of the population\n\nparms_sir &lt;- c(beta = 1.3/2,\n               gamma = 0.23)\n\ny_sir[1, ] &lt;- c(0.99, 0.01, 0)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- y_sir[i-1,] +\n        update_sir(time_sir[i],\n                   y_sir[i-1, ],\n                   parms_sir)\n}\n\nplot(x = time_sir, y = y_sir[,2], ylim = c(0,1))"
  },
  {
    "objectID": "03_DiscreteDeterministic_solutions.html#b.-sir-model",
    "href": "03_DiscreteDeterministic_solutions.html#b.-sir-model",
    "title": "03. Discrete-time deterministic models: Solutions",
    "section": "B. SIR model",
    "text": "B. SIR model\n\nB.1 Incorporating births\nAdapt the SIR model in the slides to incorporate birth of new susceptibles proportional to the sum of the S, I, and R populations. Balance these new births with deaths from each of the S I and R groups, with both the per capita birth and death rates being delta=0.01\nAnswer:\n\nnew_sir &lt;- function(t, y, parms){\n    S &lt;- y[1]\n    I &lt;- y[2]\n    R &lt;- y[3]\n    \n    \n    beta  &lt;- parms[\"beta\"]\n    gamma &lt;- parms[\"gamma\"]\n    delta &lt;- parms[\"delta\"]\n    \n    out &lt;- c(-beta*y[1]*y[2] + delta*sum(y) - delta*S,\n             beta*y[1]*y[2] - gamma*y[2] - delta*I,\n             gamma*y[2] - delta*R)\n    \n    return(out)\n}\n\nnew_parms &lt;- c(beta = 1.3, gamma = 0.23, delta = 0.1)\n\ntime_sir &lt;- seq(0,20,by=1)\ny_sir    &lt;- matrix(data = NA, ncol = 3, nrow = length(time_sir))\ny_sir[1, ] &lt;- c(0.99, 0.01, 0)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- y_sir[i-1,] +\n        new_sir(time_sir[i],\n                y_sir[i-1, ],\n                new_parms)\n}\n\nplot(x = time_sir, y = y_sir[,2], ylim = c(0,1))\n\n\n\n\n\n\n\n\n\n\nB.2 Visualising for the whole population\nCalculate N(t) = S(t) + I(t) the total number of alive individuals. Make a plot of S(t), I(t), R(t) and N(t). Your function N(t) should be constant at 1 for all values of t. If this is not the case, ensure the model contains births of new S proportional to N, and deaths of each of S, I, and R.\nAnswer:\n\n\n\n\n\n\n\n\n\nB.2.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nAnswer: After 8 days, the proportion infectious is approximately 0.54\nB.2.(b) Approximately how long does it take for the susceptibles to go to 0?\nAnswer: The susceptible population does not go to 0, due to the birth of new susceptibles\n\n\nB.3 Discussion\nDiscuss what happens to the population of S, I, and R over time. Consider the parameters of the model, what they represent, and whether the assumptions they represent are realistic.\nAnswer:\nS(t): The population decreases to a minimum at about 9 days but the birth of new susceptibles prevents it reaching 0. It will continue to increase to a stable equilibrium.\nI(t): The population increases to a peak and then the recovery process causes the population to decrease. The infectious population does not decrease down to 0 as before as the new susceptibles will get infected. The long-term behaviour is a stable equilibrium.\nR(t): The recovered population increases to a peak and then decreases to a stable equilibrium as the recovered population die and are replaced with susceptibles. There’s an implicit assumption in the model that transmission is not passed to newborns; i.e. only susceptibles are born. This is likely a reasonable assumption to make for many diseases. As we are dealing the proportion of the total population it’s reasonable to keep N(t) constant, but the birth and death rates may not be reasonable. Instead, we might be best to allow them to grow indefinitely (or, if the death rate is higher, decrease to 0).\nAdditionally, we assume that the entire population is capable of giving birth to newborns, and that the disease does not cause a loss of life expectancy."
  },
  {
    "objectID": "08_StochasticIBM_code2.html",
    "href": "08_StochasticIBM_code2.html",
    "title": "08. Stochastic individual-based models (practical 2)",
    "section": "",
    "text": "For practical 2, start with the following code:\n\n# Individual-based SARS-CoV-2 transmission model, practical 2\nlibrary(ggplot2)\n\n\n## Model parameters\nbeta &lt;- 0.5      # Transmission parameter\niota &lt;- 1e-5     # Importation rate\ndelta &lt;- 1/2.5   # Rate of transitioning out of latent state\ngamma &lt;- 1/5     # Rate of transitioning out of infectious state\nomega &lt;- 1/180   # Rate of waning immunity\n\ndt &lt;- 1          # Time step of simulation (1 day)\ndays &lt;- 365*2    # Duration of simulation (2 years)\nsteps &lt;- days/dt # Total number of time steps\nn &lt;- 1000        # Population size\n\n\n## Some helper functions\n# Calculates infectiousness as a function of state and age: zero if state is\n# not \"I\"; nonzero if state is \"I\", and slightly decreasing with age\ninfectiousness &lt;- function(state, age) {\n    ifelse(state == \"I\", 1.25 - age / 160, 0)\n}\n\n# Calculates susceptibility of individuals with antibody level(s) ab\nsusceptibility &lt;- function(ab) {\n    pnorm(ab, 5, 1)\n}\n\n# Generates n random delays from the latent-period distribution\n# (approximately 2 days, on average)\nlatent_delay &lt;- function(n) {\n    rlnorm(n, meanlog = 0.5, sdlog = 0.6)\n}\n\n# Generates n random delays from the infectious-period distribution\n# (approximately 5 days, on average)\ninfectious_delay &lt;- function(n) {\n    rlnorm(n, meanlog = 1.5, sdlog = 0.5)\n}\n\n# Generates n random increments to antibody levels following recovery\nab_increment &lt;- function(n) {\n    rnorm(n, mean = 12, sd = 2)\n}\n\n\n## Data frame to store simulation results\nresults &lt;- data.frame(ts = 1:steps, S = 0, E = 0, I = 0, R = 0)\n\n\n## Initialize simulation\n\n# Set the seed for the pseudorandom number generator, for reproducibility\nset.seed(12345)\n\n# Initialize state variables\nstate &lt;- rep(\"S\", n)   # Each individual's state: start with all susceptible\nstate[1:10] &lt;- \"E\"     # Start 10 individuals in the \"exposed\" state\n\n\n## Run simulation\n\n# Initialize progress bar\nbar &lt;- txtProgressBar(min = 1, max = steps, style = 3)\n\n# Loop over each time step . . .\nfor (ts in 1:steps) {\n    # Calculate the force of infection\n    lambda &lt;- beta * sum(state == \"I\") / n + iota\n\n    # Loop through each host . . .\n    for (i in 1:n) {\n        # Update individual i's non-state variables\n        # . . .\n\n        # Update individual i's state\n        if (state[i] == \"S\") {\n            # Transition S -&gt; E (infection) at rate lambda\n            if (runif(1) &lt; 1 - exp(-lambda * dt)) {\n                state[i] &lt;- \"E\"\n            }\n        } else if (state[i] == \"E\") {\n            # Transition E -&gt; I (latent to infectious) at rate delta\n            if (runif(1) &lt; 1 - exp(-delta * dt)) {\n                state[i] &lt;- \"I\"\n            }\n        } else if (state[i] == \"I\") {\n            # Transition I -&gt; R (infectious to recovered) at rate gamma\n            if (runif(1) &lt; 1 - exp(-gamma * dt)) {\n                state[i] &lt;- \"R\"\n            }\n        } else if (state[i] == \"R\") {\n            # Transition R -&gt; S (waning of immunity) at rate omega\n            if (runif(1) &lt; 1 - exp(-omega * dt)) {\n                state[i] &lt;- \"S\"\n            }\n        }\n    }\n\n    # Save population state for this time step\n    results[ts, \"S\"] &lt;- sum(state == \"S\")\n    results[ts, \"E\"] &lt;- sum(state == \"E\")\n    results[ts, \"I\"] &lt;- sum(state == \"I\")\n    results[ts, \"R\"] &lt;- sum(state == \"R\")\n\n    # Update progress bar; close progress bar if we are finished\n    setTxtProgressBar(bar, ts)\n    if (ts == steps) {\n        close(bar)\n    }\n}\n\n## Plot simulation results\nggplot(results) +\n  geom_line(aes(x = ts, y = S, colour = \"S\")) +\n  geom_line(aes(x = ts, y = E, colour = \"E\")) +\n  geom_line(aes(x = ts, y = I, colour = \"I\")) +\n  geom_line(aes(x = ts, y = R, colour = \"R\"))\n\nReturn to the practical here."
  },
  {
    "objectID": "08_StochasticIBM_code2.html#practical-2.-adding-more-complex-dynamics-to-the-model",
    "href": "08_StochasticIBM_code2.html#practical-2.-adding-more-complex-dynamics-to-the-model",
    "title": "08. Stochastic individual-based models (practical 2)",
    "section": "",
    "text": "For practical 2, start with the following code:\n\n# Individual-based SARS-CoV-2 transmission model, practical 2\nlibrary(ggplot2)\n\n\n## Model parameters\nbeta &lt;- 0.5      # Transmission parameter\niota &lt;- 1e-5     # Importation rate\ndelta &lt;- 1/2.5   # Rate of transitioning out of latent state\ngamma &lt;- 1/5     # Rate of transitioning out of infectious state\nomega &lt;- 1/180   # Rate of waning immunity\n\ndt &lt;- 1          # Time step of simulation (1 day)\ndays &lt;- 365*2    # Duration of simulation (2 years)\nsteps &lt;- days/dt # Total number of time steps\nn &lt;- 1000        # Population size\n\n\n## Some helper functions\n# Calculates infectiousness as a function of state and age: zero if state is\n# not \"I\"; nonzero if state is \"I\", and slightly decreasing with age\ninfectiousness &lt;- function(state, age) {\n    ifelse(state == \"I\", 1.25 - age / 160, 0)\n}\n\n# Calculates susceptibility of individuals with antibody level(s) ab\nsusceptibility &lt;- function(ab) {\n    pnorm(ab, 5, 1)\n}\n\n# Generates n random delays from the latent-period distribution\n# (approximately 2 days, on average)\nlatent_delay &lt;- function(n) {\n    rlnorm(n, meanlog = 0.5, sdlog = 0.6)\n}\n\n# Generates n random delays from the infectious-period distribution\n# (approximately 5 days, on average)\ninfectious_delay &lt;- function(n) {\n    rlnorm(n, meanlog = 1.5, sdlog = 0.5)\n}\n\n# Generates n random increments to antibody levels following recovery\nab_increment &lt;- function(n) {\n    rnorm(n, mean = 12, sd = 2)\n}\n\n\n## Data frame to store simulation results\nresults &lt;- data.frame(ts = 1:steps, S = 0, E = 0, I = 0, R = 0)\n\n\n## Initialize simulation\n\n# Set the seed for the pseudorandom number generator, for reproducibility\nset.seed(12345)\n\n# Initialize state variables\nstate &lt;- rep(\"S\", n)   # Each individual's state: start with all susceptible\nstate[1:10] &lt;- \"E\"     # Start 10 individuals in the \"exposed\" state\n\n\n## Run simulation\n\n# Initialize progress bar\nbar &lt;- txtProgressBar(min = 1, max = steps, style = 3)\n\n# Loop over each time step . . .\nfor (ts in 1:steps) {\n    # Calculate the force of infection\n    lambda &lt;- beta * sum(state == \"I\") / n + iota\n\n    # Loop through each host . . .\n    for (i in 1:n) {\n        # Update individual i's non-state variables\n        # . . .\n\n        # Update individual i's state\n        if (state[i] == \"S\") {\n            # Transition S -&gt; E (infection) at rate lambda\n            if (runif(1) &lt; 1 - exp(-lambda * dt)) {\n                state[i] &lt;- \"E\"\n            }\n        } else if (state[i] == \"E\") {\n            # Transition E -&gt; I (latent to infectious) at rate delta\n            if (runif(1) &lt; 1 - exp(-delta * dt)) {\n                state[i] &lt;- \"I\"\n            }\n        } else if (state[i] == \"I\") {\n            # Transition I -&gt; R (infectious to recovered) at rate gamma\n            if (runif(1) &lt; 1 - exp(-gamma * dt)) {\n                state[i] &lt;- \"R\"\n            }\n        } else if (state[i] == \"R\") {\n            # Transition R -&gt; S (waning of immunity) at rate omega\n            if (runif(1) &lt; 1 - exp(-omega * dt)) {\n                state[i] &lt;- \"S\"\n            }\n        }\n    }\n\n    # Save population state for this time step\n    results[ts, \"S\"] &lt;- sum(state == \"S\")\n    results[ts, \"E\"] &lt;- sum(state == \"E\")\n    results[ts, \"I\"] &lt;- sum(state == \"I\")\n    results[ts, \"R\"] &lt;- sum(state == \"R\")\n\n    # Update progress bar; close progress bar if we are finished\n    setTxtProgressBar(bar, ts)\n    if (ts == steps) {\n        close(bar)\n    }\n}\n\n## Plot simulation results\nggplot(results) +\n  geom_line(aes(x = ts, y = S, colour = \"S\")) +\n  geom_line(aes(x = ts, y = E, colour = \"E\")) +\n  geom_line(aes(x = ts, y = I, colour = \"I\")) +\n  geom_line(aes(x = ts, y = R, colour = \"R\"))\n\nReturn to the practical here."
  },
  {
    "objectID": "06_SensitivitySampling_solutions.html",
    "href": "06_SensitivitySampling_solutions.html",
    "title": "06. Sensitivity analysis and sampling: Solutions",
    "section": "",
    "text": "Click here to return to the practical."
  },
  {
    "objectID": "06_SensitivitySampling_solutions.html#one-way-sensitivity-analyses",
    "href": "06_SensitivitySampling_solutions.html#one-way-sensitivity-analyses",
    "title": "06. Sensitivity analysis and sampling: Solutions",
    "section": "(1) One-way sensitivity analyses",
    "text": "(1) One-way sensitivity analyses\nFirst, let’s run an ODE model. Download and open up the SIRmodel.R\n\n(a) Which functions are in here?\nAnswer: solveODE() and SIR_model()\n\n\n(b) What are the arguments of the first function?\nAnswer: (1) the parameter values lists, (2) Argument to plot everything, (3) number of row to plot (4) number of cols to plot\n\n\n(c) What is the output of the first function?\nAnswer: maximum prevalence through the epidemic\n# First let's clear our workspace, remove plots and load the libraries we need\nrm(list=ls())\ndev.off()\nlibrary(deSolve)\nlibrary(ggplot2)\n\n# Let's read in these functions so we have them to hand\nsource(\"SIRmodel.R\")\n\n# Let's choose a beta value of 0.4 and a gamma value of 0.2\nmax.prevalence &lt;- solveODE(parameters &lt;- c(beta = 0.4, gamma = 0.2))\nprint(max.prevalence)\n\n# Now let's look at the effect of the maximum prevalence of the epidemic across \n# gamma = 0.1 -1.0 (increment on 0.1)\ngamma.vec &lt;- seq(0.1, 1.0, by = 0.1)\n\n# initialise max/prevalence container\nmax.prevalence &lt;- vector()\n\n# Add in a loop to make this happen\nfor (gamma.val in gamma.vec){\n  mp = solveODE(parameters = c(beta = 0.4, gamma = gamma.val),\n                                         plot.all.results = FALSE)\n  max.prevalence = c(max.prevalence, mp)\n}\n\n# Now we have our max.prevalence, we need to plot this against our \n# infectiousness duration - plot max.prevalence as a function of the \n# \\*infectiousness duration\\*\n\npar(new=FALSE)\npar(mfrow=c(1,1))\n\nplot(1/gamma.vec, \n     max.prevalence, \n     type = \"b\",\n     xlab = \"Infectiousness Duration (days)\",\n     ylab = \"Maximum Prevalence\",\n     main = \"One-way uncertainty analysis\")\n\n# Now try to increase the resolution of gamma to get a better idea of the \n# relationship but remember to clear max.prevalence first!\n\n# You could try and replace gamma.vec = seq(0.1, 1.0, by = 0.1) with\ninf.duration = 1:10\ngamma.vec = 1/inf.duration\n\n\n(d) Describe in words the qualitative relationship\nAnswer: There is no epidemic until the infectiousness duration is &gt; 2 days (R0 &gt; 1) after that there is a linear increase in the maximum prevalence until gamma = 6, then there is a diminishing increase in the maximum prevalence."
  },
  {
    "objectID": "06_SensitivitySampling_solutions.html#monte-carlo-sampling",
    "href": "06_SensitivitySampling_solutions.html#monte-carlo-sampling",
    "title": "06. Sensitivity analysis and sampling: Solutions",
    "section": "(2) Monte Carlo Sampling",
    "text": "(2) Monte Carlo Sampling\nNow suppose that we have a previous epidemiological study that suggested that R0 has a mean value of 5, but uncertainty within the range of [-1, +1]. However, we still don’t know whether the infectiousness period is 1 day or 10 days. We will now use the functions in SIRmodel_R0.R to make a similar plot as above, but this time, incorporate the uncertainty of R0 for each discrete value of gamma. We’re going to first use a direct Monte Carlo Sampling method.\n# Read in our set of functions in SIRmodel_R0.R\nsource(\"SIRmodel_R0.R\")\n\n# First, let's set a fixed seed for the random number generator\n# this will allow us to run the code again and retrieve the same 'simulation'\nset.seed(2019)\n\n# Now, draw R0 1,000 times from a suitable distribution (e.g. normal)\nr0.all = rnorm(1000, 5, 0.5)\nsize.df = length(r0.all) * length(gamma.vec)\n\n# initialise max.prevalence again, this time it needs to be a dataframe \n# or a matrix\nmax.prevalence = data.frame(r0.value = vector(mode = \"numeric\", \n                                            length = size.df),\n                            gamma = vector(mode = \"numeric\", \n                                           length = size.df),\n                            max.prev = vector(mode = \"numeric\", \n                                              length = size.df))\nindex = 0\n\n# create a loop over each of these R0 values in turn\nfor (r0.val in r0.all){\n# create a loop over each of these Gamma values in turn\n    for (gamma.val in gamma.vec){\n    index = index + 1\n    mp = solveODE_2(parameters = c(R0 = r0.val, gamma = gamma.val))\n    max.prevalence[index, \"r0.value\"] = r0.val\n    max.prevalence[index, \"gamma\"] = gamma.val\n    max.prevalence[index, \"max.prev\"] = mp\n    }\n}\n\n# Take a look at max.prevalence by using the 'head() function\nhead(max.prevalence)\n\n(e) How have we saved the output?\nAnswer: using ‘long’ formatting – see the ggplot pre-course material\nNow plot this output using the R function MCplot() in SIRmodel_R0.R\nMCplot(max.prevalence)\n\n\n(f) What conclusions can you draw from the plot?\nAnswer: Increasing the rate of recovery reduces the max prevalence. However, the uncertainty in R0 has a larger impact on the maximum prevalence than infectious duration. In fact, until the infectiousness duration decreases below 4 days, the value of R0 is the important parameter in determining prevalence."
  },
  {
    "objectID": "06_SensitivitySampling_solutions.html#latin-hypercube-sampling-lhs-vs-monte-carlo-sampling",
    "href": "06_SensitivitySampling_solutions.html#latin-hypercube-sampling-lhs-vs-monte-carlo-sampling",
    "title": "06. Sensitivity analysis and sampling: Solutions",
    "section": "(3) Latin hypercube sampling (LHS) vs Monte Carlo Sampling",
    "text": "(3) Latin hypercube sampling (LHS) vs Monte Carlo Sampling\n# First let's load in the library we'll need for later\nlibrary(lhs)\n\n# We're going to first sample directly from a full distribution uniform \n# distribution from 0 to 1. How many samples will we need to take? \n# Let's try a few options and see how well they do\n\npar(mfrow=c(3,2))\nhist(rnorm(10))\nhist(rnorm(100))\nhist(rnorm(1000))\nhist(rnorm(10000))\nhist(rnorm(20000))\n\n# Now let's plot the sample sizes against the variance of the sample distribution\n\nplot(\n    c(10,100,1000,10000,50000,100000),\n    c(var(rnorm(10)), var(rnorm(100)), var(rnorm(1000)), var(rnorm(10000)), \n      var(rnorm(50000)), var(rnorm(100000))),\n    ylab = \"variance\", main = \"Variance of sampled normal\"\n    )\nabline(h = 1)\n\n# Let's now use 100 samples to see the difference between a Monte Carlo \n# sampling and a LHS sampling approach.\n# Pick some small number of samples\nn &lt;- 100\n\n# First we're going to sample 100 times from a random sample\nmc_unif &lt;- runif(n)\n\n# 100 lh samples across 1 parameter\nlatin_unif &lt;- randomLHS(n, 1)\n\n# plot these two distribution\ndev.off()\npar(mfrow=c(3,2))\nhist(mc_unif)\nhist(latin_unif)\n\n# You can see how the Latin Hypercube does a great job of sampling evenly \n# across the distribution. Let's now sample from a Normal distribution using \n# a random monte carlo sample across the whole distribution.\nmc_norm &lt;- rnorm(n, mean = 0, sd = 1)\n\n# How do we sample using an LHS? We use the previous numbers generated from the \n# uniform LHS to draw samples from the Normal using the Inverse Cumulative \n# Sampling.\nlatin_norm &lt;- qnorm(latin_unif, mean = 0, sd = 1)\n\n# plot these two normal distributions\nhist(mc_norm)\nhist(latin_norm)\n\n# the latin hypercube sample looks much better! Why does this work?\n# first let's look at the norm probability distibution\nx &lt;- seq(-6, 6, by = 0.1) # random variable X\nnormdens &lt;- dnorm(x, mean = 0, sd = 1) # prob distribution, f(X)\nnormcumul &lt;- pnorm(x, mean = 0, sd = 1) # cumulative distribution, F(X)\n\nplot(x, normdens, \"l\")\nplot(x, normcumul, \"l\")\n\n# Most of the density is in the middle range of values (-1 to 1).\n\n# So we want a method to sample from this more often than the other areas in \n# the distribution. Specifically, we want to sample values from X proportionally \n# to the probability of those values occuring. Let's generate some samples \n# between 0-1. These can be values on our Y-axis. Then, if we ask what is the \n# value of the cumulative distribution that corresponds to these uniform \n# values we are taking the inverse for illustration let's just choose 10 points.\nex_latin &lt;- randomLHS(10, 1)\n\n# which X values are given by using these as the Y value (denoted by \"X\"s)?\nabline(h = ex_latin, col = \"red\")\npoints(qnorm(ex_latin, mean = 0, sd = 1), y=rep(0,10), pc = \"x\")\n\n# You can see that the samples are clustered around the middle: in areas of X \n# with higher density, the gradient of the cumluative distribution (F(X)) will \n# be very steep, causing more values between 0 and 1 to map to this range of X \n# with high density That is, F\\^{-1}(R) = X where R is a uniform random number \n# between 0 and 1.\n\n# So, you can sample from any distribution whose cumluative function is \n# 'invertable' by plugging in uniform random numbers to the inverse cumulative \n# function of your new distribution. For more information check out: \n# https://en.wikipedia.org/wiki/Inverse_transform_sampling\n\n# Likewise, to perform LHS on a uni- or mulitvariate non-uniform distribution, \n# we can transform our LHS samples from a uniform distribution as above."
  },
  {
    "objectID": "problems.html",
    "href": "problems.html",
    "title": "Modelling problems",
    "section": "",
    "text": "When you are faced with a research question, and think that modelling might be useful, you have to translate the problem into a model.\nAs a modeler, you will have to choose the type of model you want to use, build the model and choose the parameters.\nIn this course, we have 3 sessions (Tuesday and Thursday) to enable you to think constructively about the type of model you might need for a research problem that we provide you with.\nWe are aiming for a “sketch” of a model or a few ideas of what a model would look like (e.g. compartment diagram). You are not required to code anything."
  },
  {
    "objectID": "problems.html#aim",
    "href": "problems.html#aim",
    "title": "Modelling problems",
    "section": "",
    "text": "When you are faced with a research question, and think that modelling might be useful, you have to translate the problem into a model.\nAs a modeler, you will have to choose the type of model you want to use, build the model and choose the parameters.\nIn this course, we have 3 sessions (Tuesday and Thursday) to enable you to think constructively about the type of model you might need for a research problem that we provide you with.\nWe are aiming for a “sketch” of a model or a few ideas of what a model would look like (e.g. compartment diagram). You are not required to code anything."
  },
  {
    "objectID": "problems.html#instructions",
    "href": "problems.html#instructions",
    "title": "Modelling problems",
    "section": "Instructions",
    "text": "Instructions\nTuesday’s session (30 mins):\n\nIdentify which group you are in and which modelling problem you should tackle (table TBC)\nConsult your group’s Modelling Problem (see below!)\nTake some time to look at the problem and ask any questions you need to (20 mins)\nNow you’ve had a chance to think about the problem yourself, you can say “Hi” to your group colleagues\n\nThursday’s session: You’ll be working with colleagues in your group to sketch a model that answers your particular question. After this group work, there will be a session to discuss the problem you had to solve, and your ideas for a solution with the other groups. You and your group can write down your ideas on draw.io (link TBC)."
  },
  {
    "objectID": "problems.html#the-problems",
    "href": "problems.html#the-problems",
    "title": "Modelling problems",
    "section": "The problems",
    "text": "The problems\nYou will be assigned to one of the following four modelling problems.\nYour group’s assignment is to design a model that could help you complete your task. For instance, you may wish to include the following:\n\nA compartment diagram of the disease including demographic states that you wish your model to track (showing arrows between your compartments denoting flows)\nAny further information on the model set-up (e.g. whether you wish to use a stochastic model and if so what type)\nA short list of information or parameters that you need to run your model\nAny values of these parameters needed (you may find googling helpful here - remember to state your source)\nA short list of where any uncertainty is in your assumptions, model structure or parameter values.\n\n\n1. Avian influenza\nA strain of avian influenza is spreading among poultry farms. The virus has a near-100% fatality risk in birds, and has an \\(R_0\\) typically between 1.8 and 2.4 (among birds in a farm setting). Whether \\(R_0\\) is at the low end or the high end of this range seems to depend upon the farm, but the reasons for this variation are not fully understood. When birds are housed outdoors, there is around a 5% risk each year of any given farm having at least one case, but it has been observed that this risk goes up to around 20% if a neighbouring farm has had a substantial outbreak (with more than half of the flock affected). If birds are housed indoors, the risk of introduction is reduced 4-8 fold, because there is reduced contact with wild birds which may spread the virus. You have been asked to model different strategies for reducing the impact of avian influenza on poultry and poultry farms, based around establishing criteria for when birds should be housed inside and when a flock should be culled.\n\n\n2. SARS-CoV-2\nGovernment ministers have asked you to assess the relative efficacy of two alternative quarantine strategies for reducing SARS-CoV-2 transmission. The baseline strategy requires contacts of a suspected COVID-19 case to quarantine for 10 days. The alternative “test-to-release” strategy allows individuals to leave quarantine early if they test negative partway through the quarantine period. Which will be more effective? You have been asked to consider:\n\npotentially differing rates of compliance with the two strategies\nhow many days after the start of the quarantine period the “test-to-release” should be taken\nimperfect sensitivity and specificity of the test\n\n\n\n3. Dengue\nDengue virus transmits between humans via mosquito vectors. While some infections are asymptomatic, others lead to dengue fever, of which a proportion go on to develop very severe dengue haemorrhagic fever (DHF), which can result in death. There are four subtypes of the dengue virus. Recovering from one subtype generates complete immunity to that subtype (i.e. prevents re-infection) and some immunity to other subtypes (usually termed imperfect cross-immunity). It is also known that second or third dengue infections have a higher chance of DHF due to something called ‘antibody-dependent enhancement’. The degree of cross-immunity and increased severity of subsequent infections are highly uncertain, which makes it difficult to understand the impact of intervention strategies.\nYou are the modeller in a large clinical trial team that is evaluating the use of a dengue vaccine candidate in country Y. Your role is to use a model that will help elucidate the results of the clinical trial which measures the incidence of dengue infection and DHF. However, first, you need to build a model that captures the dynamics of dengue prior to vaccine introduction.\n\n\n4. Seasonal influenza\nCountry X currently funds an annual influenza vaccination programme (between October and February) that targets school students 6-18 years old. Typically, this school-based programme achieves 40% vaccine coverage among this age group. However, there is no funded programme for working-age adults, who pay for a seasonal flu vaccine themselves (out-of-pocket), and thus the annual coverage levels are typically around 10% in this age group. The government would like to reduce flu-related deaths and hospitalisations each year and is considering whether to try to increase vaccine use and needs to understand the impact of different strategies.\nYou have been tasked to predict the impact of two potential strategies on flu-related hospitalisations and deaths. The first strategy aims to increase the vaccine coverage among school students using public health campaigns to provide information on flu and vaccines to parents and schools; colleagues in the Immunisation Division believe this campaign would increase the vaccine coverage to 75% given results from a recent pilot study. The second strategy would be to increase vaccine coverage among working-age adults by providing a cash incentive; the effect of this strategy is less certain, but survey results suggest this strategy may increase coverage among working-age adults to around 30%."
  },
  {
    "objectID": "05_Metapop_solutions.html",
    "href": "05_Metapop_solutions.html",
    "title": "05. Metapopulations with ODEs: Solutions",
    "section": "",
    "text": "Click here to return to the practical.\nThe code below has been written to solve a Susceptible-Infected-Recovered model with two populations. Familiarise yourself with the expanded model before moving onto the activities that follow. Note: the compartments C1 and C2 reflect the cumulative numbers of people infected. This will be used later on.\n# Load in the deSolve package\nlibrary(deSolve)\n# If the package is not installed, install using the install.packages() function\n\n# Define model function \nSIR_metapop_model &lt;- function(times, state, parms){\n  ## Define variables\n  S1 &lt;- state[\"S1\"]\n  I1 &lt;- state[\"I1\"]\n  R1 &lt;- state[\"R1\"]\n  C1 &lt;- state[\"C1\"]\n  N1 &lt;- S1 + I1 + R1\n  S2 &lt;- state[\"S2\"]\n  I2 &lt;- state[\"I2\"]\n  R2 &lt;- state[\"R2\"]\n  C2 &lt;- state[\"C2\"]\n  N2 &lt;- S2 + I2 + R2\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  alpha &lt;- parms[\"alpha\"]\n  lambda1 &lt;- (beta * I1 / N1 + alpha * beta * I2 / N2)\n  lambda2 &lt;- (beta * I2 / N2 + alpha * beta * I1 / N1)\n  # Define differential equations\n  dS1 &lt;- - lambda1 * S1\n  dI1 &lt;- lambda1 * S1 - gamma * I1\n  dR1 &lt;- gamma * I1\n  dC1 &lt;- lambda1 * S1\n  dS2 &lt;- - lambda2 * S2\n  dI2 &lt;-  lambda2 * S2 - gamma * I2\n  dR2 &lt;- gamma * I2\n  dC2 &lt;- lambda2 * S2\n  res &lt;- list(c(dS1, dI1, dR1, dC1, dS2, dI2, dR2, dC2))\n  return(res)\n}\n\n# Define parameters  \nparameters &lt;- c( beta = 0.4, gamma = 0.1, alpha = 1)\n\n# Define time to run model\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN1 &lt;- 1000; N2 &lt;- 1000\nI1_0 &lt;- 1; I2_0 &lt;- 0\nR1_0 &lt;- 0; R2_0 &lt;- 0\nC1_0 &lt;- 0; C2_0 &lt;- 0\nS1_0  &lt;- N1 - I1_0\nS2_0  &lt;- N2 - I2_0\nstate &lt;- c(S1 = S1_0, I1 = I1_0, R1 = R1_0, C1 = C1_0, \n           S2 = S2_0, I2 = I2_0, R2 = R2_0, C2 = C2_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, \n                  times = times, \n                  func = SIR_metapop_model, \n                  parms = parameters,\n                  method = rk4)\n\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar(mfrow = c(1, 1))\nplot(output$time, output$I1, type = \"l\", col = 4, lwd = 2, ylim = c(0, N1),\n      xlab = \"Time\", ylab = \"Number\", main = \"\")\nlines(output$time, output$I2, lwd = 2, col = 2, type = \"l\")\nlegend(\"topright\", \n       legend = c(\"Infected in population 1\", \n                  \"Infected in population 2\"),\n       lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "05_Metapop_solutions.html#question-a",
    "href": "05_Metapop_solutions.html#question-a",
    "title": "05. Metapopulations with ODEs: Solutions",
    "section": "Question A",
    "text": "Question A\nWhen you simulate the above model, you’ll notice that currently the epidemics are nearly identical in the two populations. Update the model parameters so the transmission rate between the two populations is equal to 5% of the transmission rate within each population. What happens to the size and timing of the epidemics?\nAnswer: Epidemic is delayed with slightly smaller peak in population 2 because takes time for infection to spread.\n\nparameters &lt;- c( beta = 0.4, gamma = 0.1, alpha = 0.05)"
  },
  {
    "objectID": "05_Metapop_solutions.html#question-b",
    "href": "05_Metapop_solutions.html#question-b",
    "title": "05. Metapopulations with ODEs: Solutions",
    "section": "Question B",
    "text": "Question B\nWhat happens if the epidemic starts with 10 people infected in both populations? Why does this happen?\nAnswer: Epidemics are identical because initial conditions are the same. Although there is some connectivity between populations, it is symmetrical, so same dynamics in both."
  },
  {
    "objectID": "05_Metapop_solutions.html#question-c",
    "href": "05_Metapop_solutions.html#question-c",
    "title": "05. Metapopulations with ODEs: Solutions",
    "section": "Question C",
    "text": "Question C\nThe model is currently set up to record the number of cumulative cases in each population (i.e. C1 and C2). The below code will plot these cumulative numbers of cases. Update the code so you are plotting incidence, i.e. new cases appearing over time, rather than cumulative cases.\n\npar(mfrow = c(1, 1))\nplot(output$time, output$C1, type = \"l\", col = 4, lwd = 2, ylim = c(0, N1+100), \n     xlab = \"Time\", ylab = \"Number\", main = \"\")\nlines( output$time, output$C2, lwd = 2, col = 2, type = \"l\")\nlegend(\"topright\", \n       legend = c(\"Cumulative cases in population 1\", \n                  \"Cumulative cases in population 2\"),\n       lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\nHint: Create a new variable that calculates the difference between adjacent timesteps, i.e. C1[2:t] - C1[1:(t-1)]\nAnswer:\n\ncases1 &lt;- tail(output$C1,-1) - head(output$C1,-1)\ncases2 &lt;- tail(output$C2,-1) - head(output$C2,-1)\ntime_cases &lt;- tail(output$time,-1)\n\nplot( time_cases, cases1, type = \"l\", col = 4, lwd = 2, ylim = c(0, N1+100),\n      xlab = \"Time\", ylab = \"Number\", main = \"\")\nlines( time_cases, cases2, lwd = 2, col = 2, type = \"l\")\nlegend(\"topright\", legend = c(\"Cases in population 1\", \"Cases in population 2\"),\n       lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "05_Metapop_solutions.html#question-d",
    "href": "05_Metapop_solutions.html#question-d",
    "title": "05. Metapopulations with ODEs: Solutions",
    "section": "Question D",
    "text": "Question D\nWhat does the incidence look like if only 50% of the cases in population 2 are reported?\nHint: There are several ways to do this - some are easier than others.\nAnswer:\n\ncases2 &lt;- 0.5*cases2\n\nplot( time_cases, cases1, type = \"l\", col = 4, lwd = 2, ylim = c(0, N1+100),\n      xlab = \"Time\", ylab = \"Number\", main = \"\")\nlines( time_cases, cases2, lwd = 2, col = 2, type = \"l\")\nlegend(\"topright\", legend = c(\"Cases in population 1\", \"Cases in population 2\"),\n       lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "05_Metapop_solutions.html#question-e",
    "href": "05_Metapop_solutions.html#question-e",
    "title": "05. Metapopulations with ODEs: Solutions",
    "section": "Question E",
    "text": "Question E\nIf you have time, expand the model to include three populations (denoted 1, 2, 3). How would you model an epidemic where:\n\nmixing between population 1 and population 2 is 5% of the rate of mixing within these populations\nmixing between population 1 and population 3 is 10% of the rate of mixing within these populations\nthere is no mixing between population 2 and population 3\n\nAnswer:\n\n# Define model function\nSIR_metapop_model_3 &lt;- function(times, state, parms){\n  ## Define variables\n  S1 &lt;- state[\"S1\"]\n  I1 &lt;- state[\"I1\"]\n  R1 &lt;- state[\"R1\"]\n  C1 &lt;- state[\"C1\"]\n  N1 &lt;- S1 + I1 + R1\n\n  S2 &lt;- state[\"S2\"]\n  I2 &lt;- state[\"I2\"]\n  R2 &lt;- state[\"R2\"]\n  C2 &lt;- state[\"C2\"]\n  N2 &lt;- S2 + I2 + R2\n\n  S3 &lt;- state[\"S3\"]\n  I3 &lt;- state[\"I3\"]\n  R3 &lt;- state[\"R3\"]\n  C3 &lt;- state[\"C3\"]\n  N3 &lt;- S3 + I3 + R3\n\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  alpha1 &lt;- parms[\"alpha1\"]\n  alpha2 &lt;- parms[\"alpha2\"]\n  lambda1 &lt;- (beta * I1 / N1 + alpha1 * beta * I2 / N2 + alpha2 * beta * I3 / N3)\n  lambda2 &lt;- (beta * I2 / N2 + alpha1 * beta * I1 / N1)\n  lambda3 &lt;- (beta * I3 / N3 + alpha2 * beta * I1 / N1)\n\n  # Define differential equations\n  dS1 &lt;- - lambda1 * S1\n  dI1 &lt;- lambda1 * S1 - gamma * I1\n  dR1 &lt;- gamma * I1\n  dC1 &lt;- lambda1 * S1\n  dS2 &lt;- - lambda2 * S2\n  dI2 &lt;-  lambda2 * S2 - gamma * I2\n  dR2 &lt;- gamma * I2\n  dC2 &lt;- lambda2 * S2\n  dS3 &lt;- - lambda3 * S3\n  dI3 &lt;-  lambda3 * S3 - gamma * I3\n  dR3 &lt;- gamma * I3\n  dC3 &lt;- lambda3 * S3\n\n  res &lt;- list(c(dS1, dI1, dR1, dC1, dS2, dI2, dR2, dC2, dS3, dI3, dR3, dC3))\n  return(res)\n}\n\n# Define parameters\nparameters &lt;- c( beta = 0.4, gamma = 0.1, alpha1 = 0.05, alpha2 = 0.1)\n\n# Define time to run model\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN1 &lt;- 1000; N2 &lt;- 1000; N3 &lt;- 1000\nI1_0 &lt;- 1; I2_0 &lt;- 0; I3_0 &lt;- 0\nR1_0 &lt;- 0; R2_0 &lt;- 0; R3_0 &lt;- 0\nC1_0 &lt;- 0; C2_0 &lt;- 0; C3_0 &lt;- 0\nS1_0  &lt;- N1 - I1_0; S2_0  &lt;- N2 - I2_0; S3_0  &lt;- N3 - I3_0\nstate &lt;- c(S1 = S1_0, I1 = I1_0, R1 = R1_0, C1 = C1_0, S2 = S2_0, I2 = I2_0, \n           R2 = R2_0, C2 = C2_0, S3 = S3_0, I3 = I3_0, R3 = R3_0, C3 = C3_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, \n                  times = times, \n                  func = SIR_metapop_model_3, \n                  parms = parameters,\n                  method = rk4)\n\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar( mfrow = c(1, 1))\nplot( output$time, output$I1, type = \"l\", col = 4, lwd = 2, ylim = c(0, N1),\n      xlab = \"Time\", ylab = \"Number\", main = \"\")\nlines( output$time, output$I2, lwd = 2, col = 2, type = \"l\")\nlines( output$time, output$I3, lwd = 2, col = 3, type = \"l\")\nlegend(\"topright\", \n       legend = c(\"Infected in population 1\", \n                  \"Infected in population 2\",\n                  \"Infected in population 3\"),\n       lty = rep(1, 2), col = c(4, 2,3), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "00_01_1_IntroToR_practical.html",
    "href": "00_01_1_IntroToR_practical.html",
    "title": "P01. Introduction to R, part 1",
    "section": "",
    "text": "A. Create simple objects of different types in the workspace\n\nitem1 &lt;- 1\nitem2 &lt;- \"a\"\nitem3 &lt;- 3.78901\n\nB. Objects with more than 1 entry are called vectors\n\n# create some vectors using c() (short for concatenate)\n# all items of a vector must be the same class\n\nobject1 &lt;- c(\"a\", \"b\", \"c\")\nobject2 &lt;- 1:3\nobject3 &lt;- c(1.3, -4.5, 6.99)\n\n# you can create vectors using other named items or objects\nobject4 &lt;- c(item1, item2, item3)\n\n# take a look\nobject1\nobject2\nobject3\nobject4\n\nC. Look for your objects in the environment tab (upper right)\nD. What class of objects is each object?\nAnswer:\n\n# use class() to find this\nclass(object1)\nclass(object2)\nclass(object3)\nclass(object4)\n\nIs object 4 the class you expected?\nAnswer:\nE. You can manipulate objects and make operations on them\n\nobject2 + 1\nobject3*object3\nobject2/object3\nobject1 + object2\n\nwhat happened at each of these commands? is it what you expected?\nAnswer:\nF. You can view the history of commands that were run.\ncheck the history of commands in the history tab (upper right)\nG. Make some other objects\n\ndf1 &lt;- data.frame(ID=1:5,\nanimal=c(\"bear\", \"cat\", \"horse\", \"cat\", \"pig\"),\nweight=c(200, 5, 600, 8, 100))\nmat1 &lt;- matrix(data=1:50, nrow=10, ncol=5)\n\n# view these objects\ndf1\nmat1\nView(df1)\nView(mat1)\n\nIn R, what is the difference between a data.frame and a matrix? hint: google it.\nAnswer:\nH. Calculate the mean weight of the animals in df1. (i.e. mean of column 3 of df1)\n\n# you can either refer to a column by name or by index\n# check what the names are\ncolnames(df1)\n\n# reference a column by name\ndf1$weight\n\n# check how to use the function \"mean\"\n# ? allows you to view the help file of any inbuilt function\n?mean\n\n# calculate the mean\nmean(df1$weight)\nmean(df1[, 3])\n\nAnswer:\nI. does mat1 have column names at this point?\nAnswer:\n\n# set column names for mat1\ncolnames(mat1) &lt;- c(\"A\", \"B\", \"C\", \"D\", \"E\")\nmat1\n\nJ. What is the value of the element row 5, column C in mat1? what is the value of row 8, column E?\n\n# inspect the element by referencing the row, then column, either by name or number\nmat1[5, \"C\"]\nmat1[5, 3]\n\nAnswer:\nK. Discard all of mat1 except the 1st and 4th column.\n\n# subset mat1 to keep only the 1st and 4th column by number or name\nmat1[ , c(1, 4)]\nmat1[ , c(\"A\", \"D\")]\n\n# Create a new object of the smaller matrix.\n# assign the subsetted version as a new object, mat2\nmat2 &lt;- mat1[ , c(\"A\", \"D\")]\nmat2 &lt;- mat1[ , c(1, 4)]\n\nThe solutions to this practical can be accessed here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Modern Techniques in Modelling",
    "section": "",
    "text": "Mathematical models are increasingly used to understand the transmission of infectious diseases in populations and to evaluate the potential impact of control programmes in reducing morbidity and mortality. With this short course, we aim to bridge the gap between theoretical training in infectious disease modelling, and the specialist technical skills needed for research in this area.\nParticipants will use R to code stochastic and deterministic epidemic models from scratch. Pre-course refresher material on R is available here.\nThe course sessions are:\nSession 1 - Introduction: Slides\nSession 2 - Types of models: Slides\nSession 3 - Discrete time deterministic models: Slides, Practical, Solutions\nSession 4 - Ordinary differential equations: Slides, Practical, Solutions\nSession 5 - Metapopulations with ODEs: Slides, Practical, Solutions\nSession 6 - Sensitivity analysis & sampling: Slides, Practical, Solutions\nSession 7 - Modelling problem: Slides, Problems\nSession 8 - Stochastic individual-based models: Slides, Practical, Solutions\nSession 9 - Network modelling: Slides, Practical, Solutions\nSession 10 - Stochastic continuous models: Slides, Practical, Solutions\nWrap-up slides are available here."
  },
  {
    "objectID": "index.html#course-overview",
    "href": "index.html#course-overview",
    "title": "Modern Techniques in Modelling",
    "section": "",
    "text": "Mathematical models are increasingly used to understand the transmission of infectious diseases in populations and to evaluate the potential impact of control programmes in reducing morbidity and mortality. With this short course, we aim to bridge the gap between theoretical training in infectious disease modelling, and the specialist technical skills needed for research in this area.\nParticipants will use R to code stochastic and deterministic epidemic models from scratch. Pre-course refresher material on R is available here.\nThe course sessions are:\nSession 1 - Introduction: Slides\nSession 2 - Types of models: Slides\nSession 3 - Discrete time deterministic models: Slides, Practical, Solutions\nSession 4 - Ordinary differential equations: Slides, Practical, Solutions\nSession 5 - Metapopulations with ODEs: Slides, Practical, Solutions\nSession 6 - Sensitivity analysis & sampling: Slides, Practical, Solutions\nSession 7 - Modelling problem: Slides, Problems\nSession 8 - Stochastic individual-based models: Slides, Practical, Solutions\nSession 9 - Network modelling: Slides, Practical, Solutions\nSession 10 - Stochastic continuous models: Slides, Practical, Solutions\nWrap-up slides are available here."
  },
  {
    "objectID": "index.html#who-we-are",
    "href": "index.html#who-we-are",
    "title": "Modern Techniques in Modelling",
    "section": "Who we are",
    "text": "Who we are\nYour course organisers are Oliver Brady, Nicholas Davies, and Yang Liu.\nYour course administrator is Francesco Grisolia.\nOther lectures and demonstrators include Billy Quilty, Kath O’Reilly, and Seb Funk."
  },
  {
    "objectID": "index.html#who-you-are",
    "href": "index.html#who-you-are",
    "title": "Modern Techniques in Modelling",
    "section": "Who you are",
    "text": "Who you are\nThis course is for:\n\nIndividuals with some exposure to the theory and use of infectious disease modelling & like to start coding their own models using R OR\nIndividuals who know some R but do not have experience using R to code infectious disease models OR\nIndividuals who will be conducting research using infectious disease models in R OR\nIndividuals who want a deeper understanding of techniques for implementing models."
  },
  {
    "objectID": "index.html#other-short-courses-at-lshtm-you-may-be-interested-in",
    "href": "index.html#other-short-courses-at-lshtm-you-may-be-interested-in",
    "title": "Modern Techniques in Modelling",
    "section": "Other short courses at LSHTM you may be interested in",
    "text": "Other short courses at LSHTM you may be interested in\nIntroduction to infectious disease modelling and its applications, organised by Emilia Vynnycky and Richard White: This two-week introductory course covers a lot of modelling philosophy and techniques, and serves as an informal “prerequisite” to MTM. The main difference in approach is that this introductory course uses mainly Berkeley Madonna and Microsoft Excel for implementing models, whereas MTM uses R. The introductory course also features a series of guest lectures from prominent UK modellers and social activities in London.\nModel fitting and inference for infectious disease dynamics, organised by Seb Funk: This one-week course covers how to fit your infectious disease models to data using Bayesian inference, particularly Markov Chain Monte Carlo. It is an excellent complement to MTM and the two courses can be taken in any order."
  },
  {
    "objectID": "00_01_2_IntroToR_practical.html",
    "href": "00_01_2_IntroToR_practical.html",
    "title": "P01. Introduction to R, part 2",
    "section": "",
    "text": "A. read in a data file\n\nmyTBdata &lt;- read.table(\"TB_stats.txt\", header=TRUE)\n\nIn order to run this, your computer need to know where “TB_stats.txt” is. You could download it here.\nWhat does the “header=TRUE” option mean?\nAnswer:\nB. Have a look at the first few lines\n\n# Now let's investigate the data file\nhead(myTBdata)\n\nHow many rows can you see? What is the first row?\nAnswer:\nC. What are the names of the columns?\n\nnames(myTBdata)\n\nIs this what you expected?\nAnswer:\nD. How many rows and columns are there in your data ?\n\ndim(myTBdata)\n\nWhat is the first number telling you? And the second?\nAnswer:\nE. How are your data stored?\n\nattributes(myTBdata)\n\nWhat new piece of information have you learned from the ‘attributes()’ function?\nAnswer:\nF. Now take a look at some summary statistics for your data\n\nsummary(myTBdata)\n\nLet’s extract some information from our data\nG. First, Calculate the total number of deaths across all countries.\nThe following two methods should give you the same answer\n\ntotal_TB_mortality1 &lt;- sum(myTBdata[,2:3]) # method 1\ntotal_TB_mortality2 &lt;- sum(myTBdata$HIV_pos_TB_mortality + myTBdata$HIV_neg_TB_mortality) # method 2\n\nDo you think one method is better than the other?\nAnswer:\nH. Now let’s check that both methods give the same answer.\nWe’ll use two ways to check this. First, let’s output both answers\n\ntotal_TB_mortality1\ntotal_TB_mortality2\n\nNow, let’s ask R to check whether they are both equal\n\ntotal_TB_mortality1==total_TB_mortality2 \n# logical expression which gives TRUE if equal and FALSE if not\n\nWhy might you prefer to use the second check (using the logical expression) than the first?\nAnswer:\nI. How different is the TB mortality rate in HIV positive persons in Lesotho compared to Zimbabwe?\nFirst, let’s add “mortality rate” as another column in our data frame\n\nmyTBdata$Mortality_Per1000 &lt;- 1000 * (myTBdata$HIV_pos_TB_mortality + myTBdata$HIV_neg_TB_mortality)/myTBdata$Population\n\nNow subset the dataset to extract the TB mortality rate for both Lesotho and Zimbabwe\n\nLesotho_mortalityrate &lt;- myTBdata[myTBdata$Country==\"Lesotho\", \"Mortality_Per1000\"]\nZimbabwe_mortalityrate &lt;- myTBdata[myTBdata$Country==\"Zimbabwe\", \"Mortality_Per1000\"]\nRelative_Mortality_Rate &lt;- Lesotho_mortalityrate / Zimbabwe_mortalityrate\n\nHow many times higher is the mortality rate for TB in Lesotho as it is in Zimbabwe?\n\npaste(\"The relative mortality rate is\", round(Relative_Mortality_Rate, 2), sep=\" \")\n\nJ. Finally in this section, let’s look at what can go wrong when reading in data files.\nIn order to complete this section, you would need to download readfileexample_1.txt, readfileexample_2.txt, and readfileexample_3.txt.\n(a) There is not an equal number of columns in each of the rows.\n\nreadFile_a &lt;- read.table(\"readfileexample_1.txt\", header=TRUE)\n\nHow do you fix this error? Hint: set missing values in the data file to be ‘Not Assigned’ by adding them as NA in the original file. Try running this line again with the updated file.\n(b) The wrong delimiter is used\n\nreadFile_b &lt;- read.table(\"readfileexample_2.txt\", header=TRUE)\n\nIs an error given? Check out ‘readFile_b’ - is it correct?\nAnswer:\nHow do you fix this? Ask R for help (?read.table) Which option do you need to specify?\nAnswer:\nIs there another way of fixing this problem?\nAnswer:\n(c) The names are read in as data rows rather than names\n\nreadFile_c &lt;- read.csv(\"readfileexample_2.txt\", header=FALSE)\n\nIs an error given? Check out ‘readFile_c’ - is it correct?\nAnswer:\nType a new line of code to correct this problem (hint: copy-paste from above and change one of the options)\n\n##### YOUR CODE GOES HERE #####\n\n(d) One of more of the columns contain different classes\n\nreadFile_d &lt;- read.table(\"readfileexample_3.txt\", header=TRUE)\n\nIs an error given? Check out ‘readFile_d’ - is it correct?\nAnswer:\nHow do you fix this issue? Hint: check the ‘class’ of the problem column. Try running this line again with an updated file.\n\n##### YOUR CODE GOES HERE #####\n\nThe solutions can be accessed here."
  },
  {
    "objectID": "00_04_ggplot_practical.html",
    "href": "00_04_ggplot_practical.html",
    "title": "P03. Introduction to ggplot",
    "section": "",
    "text": "Consider an SIR model. A CSV file has been provided for each of the three populations in the model: S - susceptible, I - infectious, R - recovered. The model used to simulate the disease is\n\nf_sir &lt;- function(time, state, parameters) {\n    \n    with(as.list(c(state, parameters)), {\n        \n        infections  &lt;- beta*S*I\n        deaths      &lt;- gamma*I\n        \n        dS &lt;- -infections \n        dI &lt;-  infections - deaths\n        dR &lt;-               deaths\n        \n        return(list(c(dS, dI, dR)))\n    })\n}\n\nwhere beta is the transmission rate (per person, per day) and gamma is the recovery rate (by day). This practical is only for plotting - so you don’t necessarily need to fully understand this function in order to move on.\n\n\n\n\nThe CSV file may be downloaded from here.\n\nlibrary(ggplot2)\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\n\nall_dat &lt;- read_csv(\"beta_1.56756_gamma_0.36508.csv\")\nall_dat\n\nshould return four columns: | time | S | I | R |\n\nall_dat_long &lt;- pivot_longer(all_dat, \n                             cols = c(S, I, R),\n                             names_to = \"state\",\n                             values_to = \"proportion\")\n\nall_dat_long\n\nshould return three columns: | time | state (key) | proportion (value) |\n\n\n\n\n\n\nUse the line geometry and color each line by state. You might find the following link useful https://ggplot2.tidyverse.org/reference/index.html\n\nggplot(data = all_dat_long, \n       aes(x = time,\n           y = proportion)) +\n    geom_line(aes(color = &lt;YOUR CODE HERE&gt;)) \n\n\n\n\nCopy and paste the code from the previous plot and re-run it to see how the ordering of the states has changed\n\nall_dat_long$state &lt;- factor(all_dat_long$state,\n                             levels = c(\"S\", \"I\", \"R\"))\n\nplot_SIR &lt;- ggplot(data = all_dat_long, \n                   aes(&lt;YOUR CODE HERE&gt;) +\n                geom_line(&lt;YOUR CODE HERE&gt;) \n\nplot_SIR\n\n\n\n\n\nplot_SIR + \n    theme_bw() + \n    xlab(\"&lt;YOUR CODE HERE&gt;\") + \n    ylab(\"&lt;YOUR CODE HERE&gt;\") +\n    theme(legend.position = \"bottom\") \n\n\n\n\n\nplot_SIR_faceted &lt;- ggplot(data = all_dat_long,\n       aes(x = time,\n           y = proportion)) +\n    geom_line() + \n    theme_bw() + \n    xlab(\"Time (days)\") + \n    ylab(\"Population proportion\") +\n    facet_wrap(facets = vars(state)) \n\nplot_SIR_faceted"
  },
  {
    "objectID": "00_04_ggplot_practical.html#part-1-single-outbreak",
    "href": "00_04_ggplot_practical.html#part-1-single-outbreak",
    "title": "P03. Introduction to ggplot",
    "section": "",
    "text": "Consider an SIR model. A CSV file has been provided for each of the three populations in the model: S - susceptible, I - infectious, R - recovered. The model used to simulate the disease is\n\nf_sir &lt;- function(time, state, parameters) {\n    \n    with(as.list(c(state, parameters)), {\n        \n        infections  &lt;- beta*S*I\n        deaths      &lt;- gamma*I\n        \n        dS &lt;- -infections \n        dI &lt;-  infections - deaths\n        dR &lt;-               deaths\n        \n        return(list(c(dS, dI, dR)))\n    })\n}\n\nwhere beta is the transmission rate (per person, per day) and gamma is the recovery rate (by day). This practical is only for plotting - so you don’t necessarily need to fully understand this function in order to move on.\n\n\n\n\nThe CSV file may be downloaded from here.\n\nlibrary(ggplot2)\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\n\nall_dat &lt;- read_csv(\"beta_1.56756_gamma_0.36508.csv\")\nall_dat\n\nshould return four columns: | time | S | I | R |\n\nall_dat_long &lt;- pivot_longer(all_dat, \n                             cols = c(S, I, R),\n                             names_to = \"state\",\n                             values_to = \"proportion\")\n\nall_dat_long\n\nshould return three columns: | time | state (key) | proportion (value) |\n\n\n\n\n\n\nUse the line geometry and color each line by state. You might find the following link useful https://ggplot2.tidyverse.org/reference/index.html\n\nggplot(data = all_dat_long, \n       aes(x = time,\n           y = proportion)) +\n    geom_line(aes(color = &lt;YOUR CODE HERE&gt;)) \n\n\n\n\nCopy and paste the code from the previous plot and re-run it to see how the ordering of the states has changed\n\nall_dat_long$state &lt;- factor(all_dat_long$state,\n                             levels = c(\"S\", \"I\", \"R\"))\n\nplot_SIR &lt;- ggplot(data = all_dat_long, \n                   aes(&lt;YOUR CODE HERE&gt;) +\n                geom_line(&lt;YOUR CODE HERE&gt;) \n\nplot_SIR\n\n\n\n\n\nplot_SIR + \n    theme_bw() + \n    xlab(\"&lt;YOUR CODE HERE&gt;\") + \n    ylab(\"&lt;YOUR CODE HERE&gt;\") +\n    theme(legend.position = \"bottom\") \n\n\n\n\n\nplot_SIR_faceted &lt;- ggplot(data = all_dat_long,\n       aes(x = time,\n           y = proportion)) +\n    geom_line() + \n    theme_bw() + \n    xlab(\"Time (days)\") + \n    ylab(\"Population proportion\") +\n    facet_wrap(facets = vars(state)) \n\nplot_SIR_faceted"
  },
  {
    "objectID": "00_04_ggplot_practical.html#part-2-100-outbreaks",
    "href": "00_04_ggplot_practical.html#part-2-100-outbreaks",
    "title": "P03. Introduction to ggplot",
    "section": "Part 2: 100 outbreaks",
    "text": "Part 2: 100 outbreaks\nWe are still considering an outbreak of a disease with S, I, and R. But this time, we are working with 100 simulations. This time, the file you are going to work with can be downloaded here.\n\nPreparing data for plotting\n\na) Read in the 100 simulation data set\n\n# \nall_dat_100 &lt;- read_csv(\"100_simulations_wide.csv\")\nall_dat_100\n\nshould return five columns: | sim | time | S | I | R |\n\nall_dat_100_long &lt;- pivot_longer(all_dat_100, \n                                 cols = &lt;YOUR CODE HERE&gt;,\n                                 names_to = &lt;YOUR CODE HERE&gt;,\n                                 values_to = &lt;YOUR CODE HERE&gt;)\nall_dat_100_long$state &lt;- &lt;YOUR CODE HERE&gt; \nall_dat_100_long\n\nshould return four columns: | sim | time | state (key) | proportion (value) |\n\n\nb) Plot all 100 simulations from the SIR model\nHint: you will need to use the group aesthetic with your line and may choose to set the lines to be semi-transparent. Use faceting (small multiples) to show each state in its own subplot; faceting will be easier in all plots from this point on than colouring by state.\n\nggplot(data = all_dat_100_long,\n       aes(x = time, \n           y = proportion)) +\n    geom_line(aes(group = sim), alpha = 0.05) +\n    theme_bw() + \n    facet_grid(&lt;YOUR CODE HERE&gt;) +\n    xlab(\"Time(days)\") +\n    ylab(\"Proportion of population\")\n\n\n\n\nCalculating summary statistics\n\nc) Use the group_by() function to tell R that we want to calculate summary statistics for each state at each time\n\nall_dat_100_long_grouped &lt;- group_by(all_dat_100_long, state, time) \nall_dat_100_long_grouped\n\nshould return four columns: | sim | time | state (key) | proportion (value) |\nshould also let you know there are 303 groups\n\n\nd) Use the summarise function to calculate the median and 95% interval for each state at each time point.\nYou will need to calculate all three summary statistics separately, and will do so within the same summarise()\n\nall_dat_100_long_summarised &lt;- \n    summarise(all_dat_100_long_grouped,\n              q0.025 = quantile(proportion, probs = 0.025),\n              q0.500 = quantile(proportion, probs = 0.5),\n              q0.975 = quantile(proportion, probs = 0.975))\n\n\n\ne) Use geom_ribbon to plot the 95% interval and geom_line to plot the median for each state.\nFor its aesthetics, geom_ribbon requires a ymin and ymax and can be coloured and filled and made semi-transparent. Ensure you label the axes appropriately.\n\nggplot(data = all_dat_100_long_summarised,\n       aes(x = time)) +\n    geom_ribbon(aes(ymin = q0.025,  # lower edge of ribbon\n                    ymax = q0.975), # upper edge of ribbon\n                alpha = 0.5,   # make semi-transparent\n                fill = \"lightskyblue\", # fill blue\n                color = NA) +     # no border color\n    geom_line(aes(y = q0.500)) +       # line for median\n    facet_grid(cols = vars(state)) +\n    theme_bw() +               # nicer theme\n    xlab(\"Time (days)\") +      # human friendly axis label\n    ylab(\"Population\")        # human friendly axis label\n\n\n\nf) If you have time left, you may wish to investigate visualising all 100 simulations, colouring by state, as before, and faceting by simulation\n\nggplot(data = all_dat_100_long,\n       aes(x = time)) +\n    geom_line(aes(y = proportion, color = state)) +\n    facet_wrap(facets = vars(sim)) +\n    theme_bw() +               # nicer theme\n    xlab(\"Time (days)\") +      # human friendly axis label\n    ylab(\"Population\") +       # human friendly axis label\n    theme(legend.position = \"bottom\")\n\n\n\ng) Discuss whether you think faceting by state or simulation gives a clearer understanding of how the simulations vary\nSolutions can be accessed here."
  },
  {
    "objectID": "08_StochasticIBM_practical.html",
    "href": "08_StochasticIBM_practical.html",
    "title": "08. Stochastic individual-based models",
    "section": "",
    "text": "In this practical, we will implement a stochastic individual-based model of SARS-CoV-2 transmission."
  },
  {
    "objectID": "08_StochasticIBM_practical.html#practical-1.-an-individual-based-seir-model-of-sars-cov-2-transmission",
    "href": "08_StochasticIBM_practical.html#practical-1.-an-individual-based-seir-model-of-sars-cov-2-transmission",
    "title": "08. Stochastic individual-based models",
    "section": "Practical 1. An individual-based SEIR model of SARS-CoV-2 transmission",
    "text": "Practical 1. An individual-based SEIR model of SARS-CoV-2 transmission\nIn the first practical for this session, we’ll code a stochastic individual-based SEIR model with the following model diagram:\n\nHere, the force of infection is \\(\\lambda = \\beta I/N\\), the latent period duration is \\(1/\\delta\\), the infectious period is \\(1/\\gamma\\) and the waning rate is \\(\\omega\\). (Symbol names: \\(\\beta\\) = beta, \\(\\delta\\) = delta, \\(\\gamma\\) = gamma, \\(\\lambda\\) = lambda, \\(\\omega\\) = omega.)\nThe rest of this section goes through each part of the script, with questions to check your understanding. Remember, you can consult the practical solutions if you are stuck.\n\n# Individual-based SARS-CoV-2 transmission model, practical 1\nlibrary(ggplot2)\n\n\n## Model parameters\nbeta &lt;- 0.5        # Transmission parameter\ndelta &lt;- 1 / 2.5   # Rate of transitioning out of latent state\ngamma &lt;- 1 / 5     # Rate of transitioning out of infectious state\nomega &lt;- 1 / 180   # Rate of waning immunity\n\ndt &lt;- 1            # Time step of simulation (1 day)\ndays &lt;- 365        # Duration of simulation (365 days)\nsteps &lt;- days / dt # Total number of time steps\nn &lt;- 1000          # Population size\n\n\nWhat is the unit of time (seconds, days, weeks?) for this model? What have we used as the average duration of the latent period, the average duration of the infectious period, and the average duration of immunity?\n\n\n## Data frame to store simulation results\nresults &lt;- data.frame(ts = 1:steps, S = 0, E = 0, I = 0, R = 0)\n\nWe will use this data frame to track the dynamics of the system over time, including the number of people in state S, E, I, and R for each time step. After you run this line, inspect the data frame (type “results” at the prompt) to make sure you understand its structure.\n\n## Initialize simulation\n\n# Set the seed for the pseudorandom number generator, for reproducibility\nset.seed(12345)\n\n# Since this is an individual-based model, we track the properties of all n\n# individuals in the simulation. One kind of property we can track is a state,\n# such as S (susceptible), E (exposed), I (infectious), or R (recovered). We\n# will store each individual's state as a string, either \"S\", \"E\", \"I\", or \"R\".\n\nstate &lt;- rep(\"S\", n)   # Each individual's state: start with all susceptible\nstate[1:10] &lt;- \"E\"     # Start 10 individuals in the \"exposed\" state\n\nThis section begins with a call to set.seed, which should be familiar from previous practicals, to ensure we can reproduce the same sequence of random numbers for our simulation. Then the state vector is initialized.\n\nWhat is in the state vector at the end of this section? Why have we set some individuals to state “E”?\n\n\n## Run simulation\n\n# We'll use the built-in function txtProgressBar to track the simulation's\n# progress. Really helps for planning coffee breaks! It needs to know the\n# minimum and maximum values to expect, and style = 3 tells it to report the\n# percentage complete.\nbar &lt;- txtProgressBar(min = 1, max = steps, style = 3)\n\n# Loop over each time step . . .\nfor (ts in 1:steps) {\n    # Calculate the force of infection\n    lambda &lt;- beta * sum(state == \"I\") / n\n\n    # Loop through each individual . . .\n    for (i in 1:n) {\n        if (state[i] == \"S\") {\n            # Transition S -&gt; E (infection) at rate lambda\n            if (runif(1) &lt; 1 - exp(-lambda * dt)) {\n                state[i] &lt;- \"E\"\n            }\n        } else if (state[i] == \"E\") {\n            #### Fill in the rest: Transition E -&gt; I (latent to infectious) at\n            #### rate delta, transition I -&gt; R (infectious to recovered) at rate\n            #### gamma, and transition R -&gt; S (waning of immunity) at rate omega\n            ...\n        } else if (...) {\n            ...\n        }\n    }\n\n    # Save population state for this time step\n    results[ts, \"S\"] &lt;- sum(state == \"S\")\n    ##### Fill in the rest for states E, I, and R\n    results[ts, \"E\"] &lt;- ...\n    ...\n\n    # Update progress bar; close progress bar if we are finished\n    setTxtProgressBar(bar, ts)\n    if (ts == steps) {\n        close(bar)\n    }\n}\n\nThis section starts by setting up a progress bar using txtProgressBar. The details of how this works are not critical, but you should see the progress bar displayed in the R console when you run the main for loop for the simulation.\nThen the simulation’s main for loop happens. The contents of this for loop happen once for every value of ts in 1, 2, 3, …, steps. There are four parts of the for loop.\nThe first part calculates the force of infection, lambda.\n\nPart of this calculation for lambda includes the expression sum(state == \"I\"). What does this expression do?\n\nThe second part loops through each individual i and executes their state transitions. The S \\(\\rightarrow\\) E transition has been filled in for you, but you will need to fill in the E \\(\\rightarrow\\) I, I \\(\\rightarrow\\) R, and R \\(\\rightarrow\\) S transitions yourself.\n\nWhat does the expression runif(1) &lt; 1 - exp(-lambda * dt) do?\n\nThe third part saves the current state of the population (number of individuals in the S, E, I, and R states) into the results data frame. S has been completed, but you will need to fill in the details for E, I, and R.\nFinally, the fourth part of the for loop updates the progress bar.\n\n## Plot simulation results\nggplot(results) +\n    geom_line(aes(x = ts, y = S, colour = \"S\")) +\n    geom_line(aes(x = ts, y = E, colour = \"E\")) +\n    geom_line(aes(x = ts, y = I, colour = \"I\")) +\n    geom_line(aes(x = ts, y = R, colour = \"R\"))\n\nThe final section of the script plots what is in the results data frame using ggplot.\n\nWhat does the plot show? How many epidemics are there over the time period simulated?\nIf you re-run all the code from the line ## Initialize simulation down to the end of the file, the simulation will run again and, since the same value is used for set.seed, you should see the same results. But different seeds can produce different results. What happens if you use set.seed(123456) instead of 12345? Try a few other values in set.seed to explore the randomness exhibited by the model."
  },
  {
    "objectID": "08_StochasticIBM_practical.html#sec2",
    "href": "08_StochasticIBM_practical.html#sec2",
    "title": "08. Stochastic individual-based models",
    "section": "Practical 2. Adding more complex dynamics to the model",
    "text": "Practical 2. Adding more complex dynamics to the model\nStart practical 2 with this code. This is the working SEIR model from Practical 1, with a few changes as detailed below.\n\n## Model parameters\n\n\nThere is now an additional parameter in this section, iota, representing a low rate of “importation” of infections into the population of \\(1 \\times 10^{-5}\\) infections per person per day. This value now gets added to the force of infection, lambda, in the main loop. This represents the reality that few populations of people are truly “cut off” from the rest of the world, so there is usually some risk of importing infection from outside the population of interest. It also avoids stochastic extinction (i.e. when transmission ceases because of low numbers of infected people in a stochastic model).\nThe duration of the simulation, days, is now 2 years instead of 1 year.\n\n\n## Some helper functions\n\n\nThis new section contains 5 new functions which will be used during this practical. infectiousness and susceptibility do calculations on their parameters, while latent_delay, infectious_delay, and ab_increment generate random numbers for the simulation to use. The purpose of these functions should become clear as you work on the practical.\n\nThe rest of the script is the same as before (except where iota is added to the force of infection, lambda, in the loop). If you run the rest of the file, you should see the same simulation as before, though this time the simulation runs for two years instead of one year.\nNow we will try adding more complex dynamics to the simulation, step by step.\nIf at any point during your testing, the simulation is taking too long to run, you can try reducing the population size n (though this will increase the randomness of the results), increasing the time step dt (though this will reduce accuracy of the simulation), or decreasing the duration of the simulation days.\n\nI. Age\nTo add age to the model, first we need to add the line\n\nage &lt;- runif(n, 0, 80)\n\nto the code, in the # Initialize state variables section. (Recall that the runif function generates random numbers from the uniform distribution.)\n\nInspect the results of this call to runif. What does this line of code do?\n\nAdding an age for each individual doesn’t do anything on its own, but we can make it have an impact on other aspects of the simulation. The helper function infectiousness returns a positive number depending on the values of state and age passed into the function.\n\nTry running this function from the command prompt with a few example values, such as:\n\n\ninfectiousness(\"S\", 12)\ninfectiousness(\"I\", 12)\ninfectiousness(c(\"I\", \"I\", \"E\"), c(30, 75, 50))\n\nWhat is this function doing?\nGo to the lines at the top of the main for loop:\n\n\n# Calculate the force of infection\nlambda &lt;- beta * sum(state == \"I\") / n + iota\n\nThe expression state == \"I\" effectively gives an infectiousness of 1 (the numerical equivalent of TRUE) for any individual with state “I”, and an infectiousness of 0 (the numerical equivalent of FALSE) for any individual of any other state. How would you alter this line to use the infectiousness function instead of the expression state == \"I\"? Make that change and see how it affects the simulation.\n(optional) Add aging to the model, by adding a line to the section in the main for loop headed # Update individual i's non-state variables. Does aging have an impact on dynamics over this time scale?\n\n\n\nII. Delay distributions\nThe helper functions latent_delay(n) and infectious_delay(n) have been set up to generate n random durations (in days) for the latent period and infectious period, respectively. Try running these a few times from the prompt. We will use these to implement these specific delay distributions in the model, instead of the exponentially-distributed delays that the model currently uses.\nFirst we need to add the line\n\ndelay &lt;- rep(0, n)\n\nto the # Initialize state variables section.\nThen, you will need to add some code to the # Update individual i's non-state variables section of the main for loop to decrease each individual i’s delay by dt each time step, which is what counts down the time remaining in the E and I states.\nNow we need to modify how the transitions themselves work. For the latent period, first focus on the part of the main loop headed by # Transition S -&gt; E (infection) at rate lambda. Here, we first check if individual i has been infected, and if they have, we currently set their state to Exposed with state[i] &lt;- \"E\".\nYou will need to add a line here which also sets their delay to a random number returned by latent_delay(1), which draws one random number from the latent-period duration distribution. Note that inside this function, we draw a random number from a log-normal distribution with parameters meanlog = 0.5 and sdlog = 0.6. You could obtain values such as these from the literature or by trying to measure the distributions from empirical data.\nNext, in the part of the main loop headed by # Transition E -&gt; I (latent to infectious) at rate delta, change the if statement so that it checks whether delay[i] is less than zero. Run your code to check whether that has worked.\nFor the infectious period, follow similar steps. You can reuse the same variable delay for the infectious period, or use a different variable.\nNote that you can now remove the model parameters delta and gamma from your code, since they are no longer being used, and update the comments in the main loop accordingly.\n\n\nIII. Modelling neutralizing antibody levels for each individual\nCurrently, the simulation models immunity as an “on/off” state: either the individual is susceptible to infection (state S) or they are completely immune to infection (state R). As an alternative, we could give each individual an “antibody level” which increases every time they fight off an infection, wanes over time, and whose value determines how likely they are to get reinfected.\nWe’ll do this in two steps.\nStep 1. First, we’ll add the antibody dynamics without affecting the rest of the simulation. Add a new parameter\n\nwane &lt;- 0.05  # Rate of antibody waning\n\nto the ## Model parameters section, and a new variable\n\nantib &lt;- rep(0, n)  # Antibody concentration for each individual\n\nto the # Initialize state variables section. We want each individual’s antib[i] to gradually wane over time, so add the line\n\nantib[i] &lt;- antib[i] - wane * dt  # Antibody waning\n\nto the section where individual i’s non-state variables are updated. We also want each individual’s antib[i] to jump up every time they recover from an infection, so add the line\n\nantib[i] &lt;- antib[i] + ab_increment(1)\n\nto the transition from I to R. The ab_increment(1) function gives a random increase to an individual’s antibodies when they fight off an infection.\nFinally, we will want to plot mean antibody levels over time to see this in action. First, add an extra column AMean to the results data frame:\n\n## Data frame to store simulation results\nresults &lt;- data.frame(ts = 1:steps, S = 0, E = 0, \n                      I = 0, R = 0, AMean = 0)\n\nAnd add some code to the part of the main loop where the population state is saved:\n\nresults[ts, \"AMean\"] &lt;- mean(antib)\n\nNow run the simulation. We can generate an extra plot at the end of the simulation to see what is happening to antibody levels over time:\n\nggplot(results) + \n    geom_line(aes(x = ts, y = AMean)) +\n    labs(x = \"Time step\", y = \"Mean antibody level\")\n\n\nWhat do you observe?\n\nStep 2. Now, we are going to make each individual’s antibody level actually do the work of determining whether they are susceptible to infection.\nThe function susceptibility(antib) has been set up to give the susceptibility of an individual with antibody level antib, where their susceptibility is defined as the probability that they get infected given an exposure to the virus. Try a few values of antib at the command prompt:\n\nsusceptibility(0)\nsusceptibility(4)\nsusceptibility(8)\n\nNow, alter the code that determines whether an individual goes from Susceptible to Exposed by adding a check for how susceptible to infection they are:\n\n# Transition S -&gt; E (infection) at rate lambda\nif (runif(1) &lt; 1 - exp(-lambda * dt) & runif(1) &lt; susceptibility(antib[i])) {\n    # . . .\n\nThis new addition is what is going to determine whether an individual is immune or susceptible to infection, so we don’t want to use the R (recovered) state to represent immunity anymore. Instead, we are going to have individuals go straight back to the S (susceptible) state when the infectious period ends. Make this change and remove the R state from the code completely. Now run the simulation.\n\nSummarize the changes you have made to the simulation and the impact on the simulation results.\n\n\n\nIV. Vaccination\nAs an optional exercise, try adding vaccination to the code. Assume that at time step 300, all individuals who are aged 40 and above get vaccinated, which increases their antibody levels by twice as much as natural infection (so you could add 2 * ab_increment(1) to each individual’s antibody levels).\n\nWhat is the impact on the simulation results?\n\nAs a further optional exercise, try adding a variable vacc for each individual which is FALSE for anyone who has not been vaccinated and TRUE for anyone who has been vaccinated. Add two extra columns to the results data frame, AMeanU and AMeanV, and use these to keep track of mean antibody levels in ever-vaccinated versus never-vaccinated individuals.\n\nPlot these observations after running the simulation. You could use code similar to the below. What do you observe?\n\n\nggplot(results) + \n    geom_line(aes(x = ts, y = AMeanU, colour = \"Unvaccinated\")) +\n    geom_line(aes(x = ts, y = AMeanV, colour = \"Vaccinated\")) +\n    labs(x = \"Time step\", y = \"Mean antibody level\")"
  },
  {
    "objectID": "08_StochasticIBM_practical.html#sec3",
    "href": "08_StochasticIBM_practical.html#sec3",
    "title": "08. Stochastic individual-based models",
    "section": "Practical 3. Optimizing the model to run faster",
    "text": "Practical 3. Optimizing the model to run faster\nIn R, code that loops over each individual in an individual-based model can be quite slow to run. This code can be optimized significantly by vectorizing it—that is, by applying events “all at once” to the entire vector of individuals’ properties rather than one by one, to each individual in turn.\nCompare this code:\n\nfor (i in 1:n) {\n    if (state[i] == \"S\") {\n      if (runif(1) &lt; 1 - exp(-lambda * dt)) {\n          state[i] &lt;- \"E\"\n      }\n    }\n}\n\nWith this code:\n\ntrE &lt;- (state == \"S\") & (runif(n) &lt; 1 - exp(-lambda * dt))\nstate[trE] &lt;- \"E\"\n\nWhile the first code snippet loops through each individual in turn and applies the S \\(\\rightarrow\\) E transition separately to each individual, the second code snippet has the same effect, but achieves this effect without a for loop.\nBreaking down that second code snippet, first it creates a Boolean (TRUE/FALSE) vector trE (“transition to E”) which is the same length as the number of individuals being simulated. This vector has the value TRUE for all individuals who are currently in state “S” and who are calculated to be exposed to the virus, and FALSE for all other individuals. Notice that instead of runif(1), which returns a single random number, we are now using runif(n), which returns n random uniform numbers between 0 and 1.\nThe second line of the code snippet makes the S \\(\\rightarrow\\) E transition happen, by setting the state of all selected individuals from the previous line to “E”.\nThis code gives a general outline for vectorizing the simulation from Practical 2. Once vectorized, the simulation runs about 10x faster.\nFundamentally, R as a language is not designed for speed. Reimplementing the model in e.g. C++ using Rcpp would likely increase the speed of the code by another 10-20x.\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "00_PreCourseMaterial.html",
    "href": "00_PreCourseMaterial.html",
    "title": "Pre-course material",
    "section": "",
    "text": "We will be making use of R programming using RStudio in this course. Please ensure you have the latest version of this software. There will be lots of variation in how much R experience each student will have, so we have compiled some pre-course material to allow everyone to get up to the minimal level required to fully participate and enjoy the course. \nEach practical P01 - P04 below comes with a prerecorded lecture and an associated practical. Before you get started, please make sure you download R and Rstudio (local version - free) here.\n\nP01 - Introduction to R: Slides,\n\nPractical - part 1, part 2, part 3\nSolutions - part 1, part 2, part 3\nRecording - part 1, part 2, part 3\n\nP02 - Programming skills, more R fun(ctionality): Slides, Practical, Solutions, Recording\nP03 - Plotting model output with ggplot2: Slides, Practical, Solutions, Recording\nP04 - Introduction to Git using Github: Slides, Practical, Recording\n\nYou are welcome to listen to any of the recorded lectures and complete any of the associated practicals regardless of your experience. However, we’ve made a list of some recommendations below to guide what is expected: \n\nIf you are new to R, please listen to lectures P01 / P02 / P03 and complete the associated practicals.\nFor those of you who have used R previously but feel a bit rusty, you may find P02 / P03 helpful to get you back up to speed. If you try P02 and feel you need some more explanation, go back to P01 and start there. \nIf you have never used ‘tidy data’ or ggplot then complete P03.\nIf you are new to Git and Github, please listen to lecture P04. \n\n\nOptional Further Reading and Exercises\nIf you would like additional practice with R, we recommend the following online resources:\n\nhttp://tryr.codeschool.com/\nhttps://monashdatafluency.github.io/r-intro-2/\nhttps://www.r-bloggers.com/how-to-learn-r-2/\nhttps://www.edx.org/course/introduction-to-r-for-data-science-2"
  },
  {
    "objectID": "00_02_programming_solutions.html",
    "href": "00_02_programming_solutions.html",
    "title": "P02. Programming Skills: solutions",
    "section": "",
    "text": "In this practical we will gain some experience using"
  },
  {
    "objectID": "00_02_programming_solutions.html#control-statements",
    "href": "00_02_programming_solutions.html#control-statements",
    "title": "P02. Programming Skills: solutions",
    "section": "(1) Control Statements",
    "text": "(1) Control Statements\nThere are often multiple ways in R to calculate what you want - what you choose will be down to personal preference but there will be some guiding principles:\n\nhow fast is the code?\nhow easy is it to read - can other people understand what you’ve done and can you debug it easily?\n\nHere we’ll do the same tasks using three different ways to demonstrate the logics behind these guiding principles. The task involves calculating the R0 for a range of infectiousness durations and transmission rates (i.e. beta) and calculate the probability of an epidemic.\nFirst, let’s install and load our packages we will need\n\ninstall.packages(\"tictoc\")\ninstall.packages(\"purrr\")\n\nlibrary(tictoc)\nlibrary(purrr)\n\nNotice that at the start and end of “ways” we implement below, we have tic() and toc() - these are commands to tell R to, respectively, start and stop a timer and output how long each code chunk took. Therefore, to compare the time taken to run each script, you will need to select everything from tic() to toc() and press Cmd-Enter\nQuestion (a) Why do you initialise variables at the start of the script?\nAnswer:\n\nso R can assign the right amount of memory, this will speed up your code\nso R will not use previously defined values to the variable by mistake\n\n\nThe first way - using loops\n\ntic(\"loop\") # start a timer called 'loop' to see how quickly it runs\n\n# intitialise variables\ninfectiousness.duration &lt;- 1:10\nbeta &lt;- seq(0.1, 0.5, by = 0.1)\nepidemic &lt;- matrix(NA,nrow=length(infectiousness.duration), ncol=length(beta))\n\n# set our loop over infectious duration and transmission rate (beta)\n\nfor (index_i in 1:length(infectiousness.duration)){\n  for (index_j in 1:length(beta)){\n    \n    #calculate R0 for each combination\n    R0 &lt;- beta[index_j] * infectiousness.duration[index_i]\n    \n    # evaluate whethere there is an epidemic - R0&gt;=1 \n    if (R0 &gt;= 1){\n      epidemic[index_i, index_j] &lt;- 1\n    } else{\n      epidemic[index_i, index_j] &lt;- 0  \n    }\n    \n  }\n}\n# calculate the proportion of the values that leads to an epidemic\nmean(epidemic)\n\n[1] 0.62\n\ntoc() # output the time that the script took\n\nloop: 0.016 sec elapsed\n\n\nInstead of accessing each element of a matrix via for loops, R can also apply operations to matrices or dataframe as chunks. This can speed up the code, reduce the amount of code, and can make it easier to read.\n\n\nThe second way - vectorisation\nhere is an example of using “expand.grid” to enumerate all the combinations of the two parameters\n\ntic(\"vectorised\") # start a timer called 'vectorised' to see how quickly it runs\ninfectiousness.duration &lt;- 1:10\nbeta &lt;- seq(0.1, 0.5, by = 0.1)\nepidemic &lt;- expand.grid(beta.val = beta, id.val = infectiousness.duration)\n# the '*' operator can then be used on the columns of the data.frame to create another column called 'R0'\nepidemic[, \"R0\"] &lt;- epidemic$beta.val * epidemic$id.val\n# we can also check the proportion of the combinations that give rise to epidemics\nmean(epidemic$R0 &gt;= 1)\n\n[1] 0.62\n\ntoc()\n\nvectorised: 0.007 sec elapsed\n\n\n\n\nThe third way - “mapping”\nLet’s calculate the same thing finally using the map function in the package purrr\n\ntic(\"map\") # start a timer called 'vectorised' to see how quickly it runs\ninfectiousness.duration &lt;- 1:10\nbeta &lt;- seq(0.1, 0.5, by = 0.1)\nparametervals &lt;- expand.grid(beta.val = beta, id.val = infectiousness.duration)\nepidemic &lt;- unlist(purrr::map2(.x = parametervals[,\"id.val\"],\n                               .y = parametervals[,\"beta.val\"],\n                               .f = ~(.x * .y)))\nmean(epidemic &gt;= 1)\n\n[1] 0.62\n\ntoc()\n\nmap: 0.009 sec elapsed\n\n\nHow did each of the three scripts do according to our 2 criteria?\n\nhow fast is the code?\nhow easy is it to read - can other people understand what you’ve done and can you debug it easily?\n\nWhich would you choose and why?"
  },
  {
    "objectID": "00_02_programming_solutions.html#functions",
    "href": "00_02_programming_solutions.html#functions",
    "title": "P02. Programming Skills: solutions",
    "section": "(2) Functions",
    "text": "(2) Functions\nFor a simple “SIR” model, we can calculate the fraction of a population at the end of an epidemic that remain susceptible. We can calculate this via what is termed the ‘final size’ equation and this is written as:\n\\[\nln(S_{inf}) = R0*(S_{inf} - 1)\n\\]\nThat is,the natural log of the proportion susceptible at the end of the epidemic is equal to R0 multiplied by 1 minus the proportion susceptible at the end of the epidemic. How do we find the solution i.e. What is \\(S_{inf}\\) for each value of R0? Let’s turn this expression into our own R function so we can solve it.\n\nfinal.size.root &lt;- function(s.inf) {\n  final.size &lt;- R0*(s.inf - 1) - log(s.inf)\n  return(final.size)\n}\n\nWe have set the final.size.root such that whenever it evaluates 0, we have found a solution. R has some in built functions to help you solve this equation. Let’s use uniroot to find a solution. We want an answer bigger or equal to 0 and less than 1. First have a look what uniroot does, by running\n\n?uniroot\n\nTake a look at the ‘Value’ that uniroot provides: ‘A list with at least four components’. To display the value of the root, we need to tell R to use the output called `root` of the function. We can do this by using the ‘$’ notation below:\n\nsol.root &lt;- uniroot(final.size.root, c(0,0.9999))$root\nprint(sol.root)\n\n[1] 0.007005744\n\n\nQuestion (b) Did you expect R to give you an answer?\nAnswer: No, because we hadn’t specified what R0 was\nQuestion (c) What variables did it use to evaluate the function?\nAnswer: A previously defined value of R0 which was R0 = 5\nWe have to make sure that we either\n\ndefine all the variables that a function needs within the function itself or\npass these variables as arguments. Let’s try both ways.\n\nFirst, rewrite the function so that R0 is defined within the function:\n\nfinal.size.root &lt;- function(s.inf) {\n  R0 &lt;- 2\n  final.size &lt;- R0*(s.inf - 1) - log(s.inf)\n  return(final.size)\n}\n\nThis looks like it could be a useful function, perhaps we don’t want to have to ‘hard code’ R. Let’s try it a second way so that R0 is passed as an argument to the function. Start by defining a function that takes both R0 and s.inf as arguments:\n\nfinal.size.root.twoargs &lt;- function(R0, s.inf){\n  final.size &lt;- R0*(s.inf - 1) - log(s.inf)\n  return(final.size)\n}\n\nQuestion (d) What are the arguments of this new function?\nAnswer: R0 and s.inf\nQuestion (e) What is the output of this new function?\nAnswer: the same as before: R0*(s.inf - 1) - log(s.inf)\nNow let’s pick a number for R0 that we can easily change, let’s call it rep.num\n\nrep.num &lt;- 2\n\nQuestion (f) Why have we called this rep.num and not R0?\nAnswer: Because we have used R0 to be the name assigned to any value of R0 that we would like. It’s good practice to choose different names for when you call functions and when you define them.\nuniroot takes only one argument so we need to wrap our function inside another function that only has one argument. This is how we do it:\n\nsol.root &lt;- uniroot(function(s.inf){\n  return(final.size.root.twoargs(rep.num, s.inf))\n}, \nc(0,0.9999))$root\n\nNotice that we have used the keyword ‘function’ without assigning the function a name (e.g. like we did with final.size). This type of function is called an ‘anonymous function’ and they are used when you can write a simple function on one line that you do not need to keep using. The output value of the function is the output value of the two args function.\nQuestion (g) What are all the functions that we have used to calculate the root of the equation and how many arguments do they have?\nAnswer: we have used three functions:\n\nuniroot: which takes a function and a value range as arguments\nan anonymous function: which takes the variable for which the solution is needed\nfinal.size.root.twoargs: which takes two arguments R0 value and s.inf (the variable for which the solution is needed)\n\nuniroot only gives us one root (unsurprisingly). rootSolve is a package that has functions to solve for multiple roots. You can install this package by:\n\nTools &gt; InstallPackage &gt; &lt;type rootSolve&gt;\ntype install.packages(\"rootSolve\") in R\n\nNow, simply load the package so your work environment has access to all its functions\n\nlibrary(\"rootSolve\")\n\nWe will now use the rootSolve function uniroot.all to find all the solutions of the final size equation. Let’s use the same syntax as we did before, remembering to define rep.num again\n\nrep.num &lt;- 2\nsol.all.roots &lt;- uniroot.all(function(s.inf){\n  return(final.size.root.twoargs(rep.num, s.inf))\n},\nc(0,1))\nprint(sol.all.roots)\n\n[1] 1.0000000 0.2032782\n\n\nQuestion (h) What is the epidemiological interpretation of these two roots?\nAnswer: The first is the disease free equilibrium, the second is the epidemic state\nFinally, let’s see how our R0 changes our solution values. We can do this with a loop as above\n\nr0.vector &lt;- 1:10\nsol.all.roots &lt;- vector(length = length(r0.vector))\nfor (r0 in r0.vector){\n  sol.all.roots[r0] &lt;- min(uniroot.all(function(s.inf) final.size.root.twoargs(r0, s.inf), c(0,1)))\n}\n\npar(new=FALSE)\nplot(r0.vector, sol.all.roots, type= \"b\", xlim=c(1,10), ylim=c(0,1), ylab = \"Proportion of population uninfected\", xlab = \"R0\")\n\n\n\n\n\n\n\n\nCan you rewrite the for loop calculation above in a different way?\nHint: use the purrr::map function - but note that previously we had 2 variables and used map2 . Now we only have one variable, so we will use purrr::map\n\ntic(\"root map\")\nsol.all.roots &lt;- unlist(\n                      purrr::map(.x = r0.vector,\n                            .f= ~min(uniroot.all(function(s.inf) final.size.root.twoargs(.x, s.inf), c(0,1)))))\ntoc()\n\nroot map: 0.007 sec elapsed"
  },
  {
    "objectID": "10_StochasticContinuous_practical.html",
    "href": "10_StochasticContinuous_practical.html",
    "title": "10. Stochastic continuous models",
    "section": "",
    "text": "In this practical, we will implement a continuous-time, stochastic compartmental model of influenza transmission using the Gillespie algorithm."
  },
  {
    "objectID": "10_StochasticContinuous_practical.html#practical-1.-stochastic-simulation-with-the-gillespie-algorithm",
    "href": "10_StochasticContinuous_practical.html#practical-1.-stochastic-simulation-with-the-gillespie-algorithm",
    "title": "10. Stochastic continuous models",
    "section": "Practical 1. Stochastic simulation with the Gillespie algorithm",
    "text": "Practical 1. Stochastic simulation with the Gillespie algorithm\nIn this practical session, we will simulate the SIR model using the Gillespie algorithm.\n\nSetting up the model algorithm\nThe first bit of code below is a function that simulates an SIR model using the Gillespie algorithm.\n\nlibrary(ggplot2) ## for plotting\nlibrary(tidyverse) ## for manipulation of results\n\n\n## Function SIR_gillespie.\n## This takes three arguments:\n## - init_state: the initial state\n##   (a named vector containing the number in S, I and R)\n## - parms: the parameters\n##   (a named vector containing the rates beta and gamma)\n## - tf: the end time\nSIR_gillespie &lt;- function(init_state, parms, tf) {\n\n  time &lt;- 0 ## initialise time to 0\n\n  ## assign parameters to easy-access variables\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n\n  ## assign states to easy-access variables\n  S &lt;- init_state[\"S\"]\n  I &lt;- init_state[\"I\"]\n  R &lt;- init_state[\"R\"]\n  N &lt;- S + I + R\n\n  ## create results data frame\n  results_df &lt;- data.frame(time=0, t(init_state))\n\n  ## loop until end time is reached\n  while (time &lt; tf) {\n    ## update current rates\n    rates &lt;- c()\n    rates[\"infection\"] &lt;- beta * S * I / N\n    rates[\"recovery\"] &lt;- gamma * I\n\n    if (sum(rates) &gt; 0) { ## check if any event can happen\n      ## time of next event\n      time &lt;- time + rexp(n=1, rate=sum(rates))\n      ## check if next event is supposed to happen before end time\n      if (time &lt;= tf) {\n        ## generate cumulative sum of rates, to determine the type of the next\n        ## event\n        cumulative_rates &lt;- cumsum(rates)\n        ## determine type of next event\n        type &lt;- runif(n=1, min=0, max=sum(rates))\n        if (type &lt; cumulative_rates[\"infection\"]) {\n          ## infection\n          S &lt;- S - 1\n          I &lt;- I + 1\n        } else if (type &lt; cumulative_rates[\"recovery\"]) {\n          ## recovery\n          I &lt;- I - 1\n          R &lt;- R + 1\n        }\n      } else { ## next event happens after end time\n        time &lt;- tf\n      }\n    } else { ## no event can happen - go straight to end time\n      time &lt;- tf\n    }\n    ## add new row to results data frame\n    results_df &lt;- rbind(results_df, c(time=time, S=S, I=I, R=R))\n  }\n  ## return results data frame\n  return(results_df)\n}\n\nTake 10 minutes to familiarise yourself with the SIR_gillespie() function and make sure you understand its inner workings.\nNow, run the SIR_gillespie() function using the commands below.\n\ninit.values &lt;- c(S=249, I=1, R=0) ## initial state\nparms &lt;- c(beta=1, gamma=0.5) ## parameter vector\ntmax &lt;- 20 ## end time\n\n## run Gillespie simulation\nr &lt;- SIR_gillespie(init_state=init.values, parms=parms, tf=tmax)\n\nThe data frame r now contains the results of the simulation.\n\nInspect the contents of the data frame and write some code to plot the results; you can use plot or ggplot for this. Run the simulation and plot the results multiple times to convince yourself the output is different every time.\n\n\n\nSummarising multiple stochastic runs\nNext, we’ll run multiple simulations at once.\n\n## Run multiple simulation runs and plot a few of them\nnsim &lt;- 100 ## number of trial simulations\n\ntraj &lt;- tibble(i=1:nsim) %&gt;%\n  rowwise() %&gt;%\n  mutate(trajectory=list(as.data.frame(\n           SIR_gillespie(init.values, parms, tmax)))) %&gt;%\n  unnest(trajectory)\n\n## convert to long data frame\nmlr &lt;- traj %&gt;%\n  gather(compartment, value, 3:ncol(.))\n\nThe code above runs the simulation 100 times and stores the resulting model trajectories in a data frame, traj, which contains the results from multiple simulation runs and an additional column that represents the simulation index.\n\nWrite some code to plot the multiple simulation runs on the same plot.\n\nYou’ll notice that some outbreaks die out very quickly, while some others grow to affect large parts of the population.\n\nPlot the distribution of overall outbreak sizes. What proportion of outbreaks dies out quickly?\n\nNext, we calculate the mean and standard deviation of each state across the multiple runs. To do that, we need the value of the different states at pre-defined time steps, whereas SIR_gillespie only returns the times at which certain events happened. In order to, for example, extract the values of the trajectory at integer time points, we can use the following:\n\n## Extract the values of the trajectory at integer time points\ntimeTraj &lt;- mlr %&gt;%\n  group_by(i, compartment) %&gt;%\n  summarise(traj=list(data.frame(\n              time=seq(0, tmax, by=0.1),\n              value=approx(x=time, y=value, xout=seq(0, tmax, by=0.1),\n                           method=\"constant\")$y))) %&gt;%\n  unnest(traj)\n\nNow, we calculate a summary trajectory containing the mean and standard deviation (sd) of the number of infectious people at every time step:\n\n## Calculate summary trajectory with mean & sd of infectious people over time\nsumTraj &lt;- timeTraj %&gt;%\n  filter(compartment==\"I\") %&gt;%\n  group_by(time) %&gt;%\n  summarise(mean=mean(value),\n            sd=sd(value))\n\n## plot\nggplot(sumTraj, aes(x=time, y=mean, ymin=pmax(0, mean-sd), ymax=mean+sd)) +\n  geom_line() +\n  geom_ribbon(alpha=0.3)\n\n\n\n\n\n\n\n\nYour plot should look something like the above.\nAs a second summary, we can also consider only trajectories that have not gone extinct, that is, where \\(I&gt;0\\):\n\n## Only consider trajectories that have not gone extinct:\nsumTrajAll &lt;- sumTraj %&gt;%\n  mutate(trajectories=\"all\")\n\nsumTrajGr0 &lt;- timeTraj %&gt;%\n  filter(compartment==\"I\", value &gt; 0) %&gt;%\n  group_by(time) %&gt;%\n  summarise(mean=mean(value),\n            sd=sd(value)) %&gt;%\n  mutate(trajectories=\"greater_than_zero\")\n\niTraj &lt;- bind_rows(sumTrajAll, sumTrajGr0)\n\n## plot\nggplot(iTraj, aes(x=time, y=mean, ymin=pmax(0, mean-sd), ymax=mean+sd,\n                  colour=trajectories, fill=trajectories)) +\n  geom_line() +\n  geom_ribbon(alpha=0.3) +\n  scale_color_brewer(palette=\"Set1\")\n\n\n\n\n\n\n\n\n\nExercise: We have plotted the mean \\(\\pm\\) standard deviation; is this a reasonable summary statistic? What else could one plot? Implement your own plot of trajectory plus uncertainty.\n\n\n\nComparing the stochastic model to the equivalent deterministic ODE model\nWe will now compare the stochastic model runs and their averages to the equivalent deterministic ODE model trajectory.\n\nUsing code from the ODE practical, load the deSolve package, define the model function (e.g. SIR_model from the ODE practical), run the model with the same parameters as the Gillespie model, and store the output in a data frame called ode_output (remember, you need to convert the matrix returned by deSolve’s ode() to a data frame using as.data.frame()).\n\nYou can then plot both the stochastic and deterministic model runs using the following code:\n\n## Combine into one big data frame\nallTraj &lt;- ode_output %&gt;%\n  gather(compartment, value, 2:ncol(.)) %&gt;% ## convert to long format\n  filter(compartment==\"I\") %&gt;%\n  rename(mean=value) %&gt;% ## in deterministic, mean=value\n  mutate(trajectories=\"deterministic\", ## label trajectories\n         sd=0) %&gt;% ## in deterministic, sd=0\n  bind_rows(iTraj)\n\n## plot\nggplot(allTraj, aes(x=time, y=mean, colour=trajectories)) +\n  geom_line() +\n  scale_color_brewer(palette=\"Set1\")\n\n\nCompare the deterministic trajectory to some of the individual stochastic trajectories and to their mean. Does the deterministic trajectory capture “typical” behaviour of the stochastic trajectories?\nRepeat the experiment with different values of the parameters. When does deterministic vs stochastic make more or less of a difference?\nRewrite the model code to be an SEIR model. How do the results differ?"
  },
  {
    "objectID": "10_StochasticContinuous_practical.html#practical-2.-the-adaptivetau-package",
    "href": "10_StochasticContinuous_practical.html#practical-2.-the-adaptivetau-package",
    "title": "10. Stochastic continuous models",
    "section": "Practical 2. The adaptivetau package",
    "text": "Practical 2. The adaptivetau package\nIn this practical session, we will use the “adaptivetau” package to run simulations. Start in a new file by loading the required packages:\n\nlibrary(ggplot2) ## for plotting\nlibrary(adaptivetau) ## for stochastic simulations\nlibrary(tidyverse) ## for manipulation of results\n\nFor adaptivetau, we first need to define the “transitions”, or events that can happen in the model. In the SIR model, these are:\n\n## Define transitions\ntransitions &lt;- list(\n  c(S = -1, I = +1),\n  c(I = -1, R = +1))\n\nWe then need to specify a rate function:\n\n## Specify rate function, giving rate for each transition\nSIRrateF &lt;- function(state, parms, time) {\n  beta &lt;- parms[[\"beta\"]]\n  gamma &lt;- parms[[\"gamma\"]]\n\n  S &lt;- state[[\"S\"]]\n  I &lt;- state[[\"I\"]]\n  R &lt;- state[[\"R\"]]\n\n  N &lt;- S + I + R\n\n  rates &lt;- c(beta * S * I/N,\n             gamma * I)\n\n  return(rates)\n}\n\nWe then define our initial conditions and parameters:\n\n## Initial values\ninit.values &lt;- c(S = 249, ## number of susceptibles\n                 I = 10, ## number infectious\n                 R = 0) ## number immune\n\n## Parameters\nparms &lt;- c(beta = 2, ## infection rate\n           gamma = 1) ## recovery rate\n\nNow we will use the ssa.adaptivetau() function to run the model and plot the results.\n\n## Run a trial simulation for 60 time steps\ntmax &lt;- 60 ## number of time steps to simulate\nr &lt;- ssa.adaptivetau(init.values, transitions, SIRrateF, parms, tf = tmax)\n\n## Plot results\nr_df &lt;- as.data.frame(r)\nplot(r_df$time, r_df$I, type = \"l\")\n\n\n\n\n\n\n\n\nRun the above multiple times – as before, the results should change every time.\nWe will now again run multiple simulations and store them in a data frame, traj, which contains multiple simulation runs and an additional column i that represents the simulation id:\n\n## Run the simulation multiple times\nnsim &lt;- 100 ## number of trial simulations\n\ntraj &lt;- tibble(i=1:nsim) %&gt;%\n  rowwise() %&gt;%\n  mutate(trajectory=list(as.data.frame(\n           ssa.adaptivetau(init.values, transitions, SIRrateF, parms, tf=tmax)))) %&gt;%\n  unnest(trajectory)\n\n## Plot the resulting trajectories\nggplot(traj) +\n    geom_line(aes(x = time, y = I, group = i, colour = i))\n\n\n\n\n\n\n\n\n\nExercise: Compare the run time of the command above to running 100 simulations using our Gillespie algorithm from Practical 1. How much is the speed gain?\nExercise: Re-write the code above to simulate from the SEITL model introduced in the slides for this session. Analyse the outputs using the same routines you used with the SIR model.\n\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "03_DiscreteDeterministic_practical.html",
    "href": "03_DiscreteDeterministic_practical.html",
    "title": "03. Discrete-time deterministic models",
    "section": "",
    "text": "time_sir &lt;- seq(0, 20, by = 1)\n\ny_sir &lt;- matrix(data = NA,\n                nrow = length(time_sir),\n                ncol = 3)\n\nupdate_sir &lt;- function(t, y, parms){\n    beta  &lt;- parms[\"beta\"]\n    gamma &lt;- parms[\"gamma\"]\n\n    out &lt;- ???\n\n    return(out)\n}\n\nparms_sir &lt;- c(beta = 1.3,\n               gamma = 0.23)\n\n# initial values at t=0\n\ny_sir[1, ] &lt;- c(???, ???, ???)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(x = time_sir, y = y_sir[,2])\n\nA.1.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.1.(b) Approximately how long does it take for the susceptibles to go to 0?\n\n\n\nA.2.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.2.(b) Approximately how long does it take for the susceptibles to go to 0?\n\nparms_sir &lt;- c(beta = ???,\n               gamma = ???)\n\ny_sir[1, ] &lt;- ???\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(x = ???, y = ???, ylim = c(0,1))\n\n\n\n\nA.3.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.3.(b) Approximately how long does it take for the susceptibles to go to 0?\n\nparms_sir &lt;- ???\n\ny_sir[1, ] &lt;- c(0.99, 0.01, 0)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(???)"
  },
  {
    "objectID": "03_DiscreteDeterministic_practical.html#a.-sir-model-from-lecture",
    "href": "03_DiscreteDeterministic_practical.html#a.-sir-model-from-lecture",
    "title": "03. Discrete-time deterministic models",
    "section": "",
    "text": "time_sir &lt;- seq(0, 20, by = 1)\n\ny_sir &lt;- matrix(data = NA,\n                nrow = length(time_sir),\n                ncol = 3)\n\nupdate_sir &lt;- function(t, y, parms){\n    beta  &lt;- parms[\"beta\"]\n    gamma &lt;- parms[\"gamma\"]\n\n    out &lt;- ???\n\n    return(out)\n}\n\nparms_sir &lt;- c(beta = 1.3,\n               gamma = 0.23)\n\n# initial values at t=0\n\ny_sir[1, ] &lt;- c(???, ???, ???)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(x = time_sir, y = y_sir[,2])\n\nA.1.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.1.(b) Approximately how long does it take for the susceptibles to go to 0?\n\n\n\nA.2.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.2.(b) Approximately how long does it take for the susceptibles to go to 0?\n\nparms_sir &lt;- c(beta = ???,\n               gamma = ???)\n\ny_sir[1, ] &lt;- ???\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(x = ???, y = ???, ylim = c(0,1))\n\n\n\n\nA.3.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.3.(b) Approximately how long does it take for the susceptibles to go to 0?\n\nparms_sir &lt;- ???\n\ny_sir[1, ] &lt;- c(0.99, 0.01, 0)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(???)"
  },
  {
    "objectID": "03_DiscreteDeterministic_practical.html#b.-sir-model",
    "href": "03_DiscreteDeterministic_practical.html#b.-sir-model",
    "title": "03. Discrete-time deterministic models",
    "section": "B. SIR model",
    "text": "B. SIR model\n\nB.1 Incorporating births\nAdapt the SIR model in the slides to incorporate birth of new susceptibles proportional to the sum of the S, I, and R populations. Balance these new births with deaths from each of the S I and R groups, with both the per capita birth and death rates being delta=0.01\n\nnew_sir &lt;- function(t, y, parms){\n    \n    beta  &lt;- parms[\"beta\"]\n    gamma &lt;- parms[\"gamma\"]\n    delta &lt;- parms[\"delta\"]\n\n    ??? &lt;- ???\n    ??? &lt;- ???\n    ??? &lt;- ???    \n        \n    return(???)\n    \n}\n\nnew_parms &lt;- ???\n\n\n\nB.2 Visualising for the whole population\nCalculate N(t) = S(t) + I(t) the total number of alive individuals. Make a plot of S(t), I(t), R(t) and N(t). Your function N(t) should be constant at 1 for all values of t. If this is not the case, ensure the model contains births of new S proportional to N, and deaths of each of S, I, and R.\n\ny_sir &lt;- cbind(y_sir, rowSums(y_sir))\npar(mfrow = c(2,2))\n\nfor (i in 1:ncol(y_sir)){\n\n    plot(y_sir[,i] ~ time_sir, type = \"p\", \n         xlab = \"Time (years)\")\n\n}\n\nB.2.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nB.2.(b) Approximately how long does it take for the susceptibles to go to 0?\n\n\nB.3 Discussion\nDiscuss what happens to the population of S, I, and R over time. Consider the parameters of the model, what they represent, and whether the assumptions they represent are realistic.\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "04_ODEs_solutions.html",
    "href": "04_ODEs_solutions.html",
    "title": "04. Ordinary differential equations (ODEs): Solutions",
    "section": "",
    "text": "Click here to return to the practical.\n\n\nThe code below will solve the SI model with beta = 0.4 over 50 days with initial conditions S(0) = 99, I(0) = 1. Run the following lines including the plot() line to create a plot of the output\n\nlibrary(deSolve) # Load in the deSolve package. If the package is not installed, install using the install.packages() function\n# Define model function\n\nSI_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  N &lt;- S + I\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N\n  res &lt;- list(c(dS, dI))\n  return(res)\n}\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nstate &lt;- c( S = S_0, I = I_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SI_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar( mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines( output$time, output$I, lwd = 2, col = \"red\", type = \"l\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\"),\n       lty = c(1, 1), col = c(\"blue\", \"red\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\n\nAnswer: The number of infecteds as a higher intercept but same asymptote\n\n\n\nAnswer: The time steps of the model solution\n\n\n\nAnswer: Solution becomes less precise.\n\n\n\n\n\nNow, let’s solve a Susceptible-Infected-Recovered set of ordinary equations. There are now states; Susceptible, Infected, Recovered. Once infected people recover at a rate gamma = 0.1. The code for the model function ONLY is given below.\n\n# Define model function \nSIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n  N &lt;- S + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dI, dR ))\n  return(res)\n}\n\n\n\n\n\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4, gamma = 0.1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nR_0 &lt;- 0\nstate &lt;- c(S = S_0, I = I_0, R = R_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar(mfrow = c(1, 1))\nplot(output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n     xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend( \"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n        lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\nHint: Recall that for an SIR model, the basic reproduction number, R_0 = beta / gamma\nAnswer: The epidemic does not take off\n\nparameters &lt;- c(beta = 0.09, gamma = 0.1)\n\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe code below has been written to solve a Susceptible-Exposed-Infected-Recovered model. In the model individuals can be in one of four states. Once infected, susceptible individuals move to the exposed class. Exposed individuals become infectious at a rate delta = 0.14.\n\n\n\n\n\n# Define model function \nSEIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[1]\n  E &lt;- state[2]\n  I &lt;- state[3]\n  R &lt;- state[4]\n  N &lt;- S + E + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  delta &lt;- parms[\"delta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I ) / N\n  dE &lt;- (beta * S * I) / N - delta * E\n  dI &lt;- delta * E - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dE, dI, dR))\n  return(res)\n}\n\n# Define parameters  \nparameters &lt;- c( beta = 0.4, gamma = 0.1, delta = 0.14)\n\n# Define time to run model\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0  &lt;- N - I_0\nR_0 &lt;- 0\nstate &lt;- c(S = S_0, E = 0, I = I_0, R = R_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SEIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlines(output$time, output$E, lwd = 2, col = \"cyan\")\nlegend(\"topright\", legend =  c(\"Susceptible\", \"Exposed\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\", \"cyan\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere we assume that susceptible individuals are vaccinated at a rate v = 0.05. The vaccine is 100% effective, so once vaccinated, individuals cannot become infected. HINT: you will need to create a new class V, you can assume that the initial number of vaccinated individuals is 0.\n\n# Define model function \nSIRV_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n  V &lt;- state[\"V\"]\n  N &lt;- S + I + R + V\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  v &lt;- parms[\"v\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N - v * S\n  dI &lt;- (beta * S * I) / N - gamma * I\n  dR &lt;- gamma * I\n  dV &lt;- v * S\n  res &lt;- list(c(dS, dI, dR, dV))\n  return(res)\n}\n\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4, gamma = 0.1, v = 0.05)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nR_0 &lt;- 0\nV_0 &lt;- 0\nstate &lt;- c(S = S_0, I = I_0, R = R_0, V = V_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SIRV_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot results\npar(mfrow = c(1, 1))\nplot(output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n     xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"green\")\nlines(output$time, output$R, lwd = 2, col = \"red\")\nlines(output$time, output$V, lwd = 2, col = \"purple\")\nlegend( \"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\", \"Vaccinated\"),\n        lty=1, col = c(\"blue\", \"red\", \"green\", 'purple'), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "04_ODEs_solutions.html#solving-the-si-model-using-desolve",
    "href": "04_ODEs_solutions.html#solving-the-si-model-using-desolve",
    "title": "04. Ordinary differential equations (ODEs): Solutions",
    "section": "",
    "text": "The code below will solve the SI model with beta = 0.4 over 50 days with initial conditions S(0) = 99, I(0) = 1. Run the following lines including the plot() line to create a plot of the output\n\nlibrary(deSolve) # Load in the deSolve package. If the package is not installed, install using the install.packages() function\n# Define model function\n\nSI_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  N &lt;- S + I\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N\n  res &lt;- list(c(dS, dI))\n  return(res)\n}\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nstate &lt;- c( S = S_0, I = I_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SI_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar( mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines( output$time, output$I, lwd = 2, col = \"red\", type = \"l\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\"),\n       lty = c(1, 1), col = c(\"blue\", \"red\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\n\nAnswer: The number of infecteds as a higher intercept but same asymptote\n\n\n\nAnswer: The time steps of the model solution\n\n\n\nAnswer: Solution becomes less precise."
  },
  {
    "objectID": "04_ODEs_solutions.html#solving-the-sir-model-using-desolve",
    "href": "04_ODEs_solutions.html#solving-the-sir-model-using-desolve",
    "title": "04. Ordinary differential equations (ODEs): Solutions",
    "section": "",
    "text": "Now, let’s solve a Susceptible-Infected-Recovered set of ordinary equations. There are now states; Susceptible, Infected, Recovered. Once infected people recover at a rate gamma = 0.1. The code for the model function ONLY is given below.\n\n# Define model function \nSIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n  N &lt;- S + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dI, dR ))\n  return(res)\n}\n\n\n\n\n\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4, gamma = 0.1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nR_0 &lt;- 0\nstate &lt;- c(S = S_0, I = I_0, R = R_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar(mfrow = c(1, 1))\nplot(output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n     xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend( \"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n        lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\nHint: Recall that for an SIR model, the basic reproduction number, R_0 = beta / gamma\nAnswer: The epidemic does not take off\n\nparameters &lt;- c(beta = 0.09, gamma = 0.1)\n\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "04_ODEs_solutions.html#solving-the-seir-model-using-desolve",
    "href": "04_ODEs_solutions.html#solving-the-seir-model-using-desolve",
    "title": "04. Ordinary differential equations (ODEs): Solutions",
    "section": "",
    "text": "The code below has been written to solve a Susceptible-Exposed-Infected-Recovered model. In the model individuals can be in one of four states. Once infected, susceptible individuals move to the exposed class. Exposed individuals become infectious at a rate delta = 0.14.\n\n\n\n\n\n# Define model function \nSEIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[1]\n  E &lt;- state[2]\n  I &lt;- state[3]\n  R &lt;- state[4]\n  N &lt;- S + E + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  delta &lt;- parms[\"delta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I ) / N\n  dE &lt;- (beta * S * I) / N - delta * E\n  dI &lt;- delta * E - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dE, dI, dR))\n  return(res)\n}\n\n# Define parameters  \nparameters &lt;- c( beta = 0.4, gamma = 0.1, delta = 0.14)\n\n# Define time to run model\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0  &lt;- N - I_0\nR_0 &lt;- 0\nstate &lt;- c(S = S_0, E = 0, I = I_0, R = R_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SEIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlines(output$time, output$E, lwd = 2, col = \"cyan\")\nlegend(\"topright\", legend =  c(\"Susceptible\", \"Exposed\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\", \"cyan\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere we assume that susceptible individuals are vaccinated at a rate v = 0.05. The vaccine is 100% effective, so once vaccinated, individuals cannot become infected. HINT: you will need to create a new class V, you can assume that the initial number of vaccinated individuals is 0.\n\n# Define model function \nSIRV_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n  V &lt;- state[\"V\"]\n  N &lt;- S + I + R + V\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  v &lt;- parms[\"v\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N - v * S\n  dI &lt;- (beta * S * I) / N - gamma * I\n  dR &lt;- gamma * I\n  dV &lt;- v * S\n  res &lt;- list(c(dS, dI, dR, dV))\n  return(res)\n}\n\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4, gamma = 0.1, v = 0.05)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nR_0 &lt;- 0\nV_0 &lt;- 0\nstate &lt;- c(S = S_0, I = I_0, R = R_0, V = V_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SIRV_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot results\npar(mfrow = c(1, 1))\nplot(output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n     xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"green\")\nlines(output$time, output$R, lwd = 2, col = \"red\")\nlines(output$time, output$V, lwd = 2, col = \"purple\")\nlegend( \"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\", \"Vaccinated\"),\n        lty=1, col = c(\"blue\", \"red\", \"green\", 'purple'), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "timetable.html",
    "href": "timetable.html",
    "title": "Timetable",
    "section": "",
    "text": "Day 1\n\n\n\n\n\n\n\n\n\n\nDate\nTime\nSession\nTitle\nLead\n\n\n\n\n2024/09/09\n10.00-10.30\n01\nIntroduction\nYang/Nick/Oli\n\n\nMonday\n10.30-11.00\n02\nDifferent types of models\nYang/Nick/Oli\n\n\n\n11.00-11.30\n\nBREAK\n\n\n\n\n11.30-12.30\n03\nDiscrete-time deterministic models\nBilly Quilty\n\n\n\n12.30-13.30\n\nLUNCH\n\n\n\n\n13.30-14.30\n03\nDiscrete-time deterministic models\nBilly Quilty\n\n\n\n14.30-15.00\n\nBREAK\n\n\n\n\n15.00-16.00\n04\nODE models\nNick Davies\n\n\n\n\n\nDay 2\n\n\n\n\n\n\n\n\n\n\nDate\nTime\nSession\nTitle\nLead\n\n\n\n\n2024/09/10\n10.00-11.30\n04\nODE models (continued)\nNick Davies\n\n\nTuesday\n11.30-12.00\n\nBREAK\n\n\n\n\n12.00-12.45\n05\nMetapopulations with ODEs\nNick Davies\n\n\n\n12.45-13.30\n\nLUNCH\n\n\n\n\n13.30-15.00\n06\nSimulation, sensitivity, and sampling\nYang Liu\n\n\n\n15.00-15.30\n\nBREAK\n\n\n\n\n15.30-16.00\n07\nPresentation of modelling problem\nOliver Brady\n\n\n\n\n\nDay 3\n\n\n\n\n\n\n\n\n\n\nDate\nTime\nSession\nTitle\nLead\n\n\n\n\n2024/09/11\n10.00-11.00\n08\nStochastic individual-based models\nNick Davies\n\n\nWednesday\n11.00-11.30\n\nBREAK\n\n\n\n\n11.30-12.30\n08\nStochastic individual-based models\nNick Davies\n\n\n\n12.30-13.30\n\nLUNCH\n\n\n\n\n13.30-14.30\n09\nNetwork models\nKath O’Reilly\n\n\n\n14.30-15.00\n\nBREAK\n\n\n\n\n15.00-16.00\n09\nNetwork models\nKath O’Reilly\n\n\n\n\n\nDay 4\n\n\n\n\n\n\n\n\n\n\nDate\nTime\nSession\nTitle\nLead\n\n\n\n\n2024/09/12\n10.00-11.00\n10\nStochastic continuous-time models\nSeb Funk\n\n\nThursday\n11.00-11.30\n\nBREAK\n\n\n\n\n11.30-12.30\n10\nStochastic continuous-time models\nSeb Funk\n\n\n\n12.30-13.30\n\nLUNCH\n\n\n\n\n13.30-14.30\n11\nGroup work\nSeb Funk\n\n\n\n14.30-14.45\n\nBREAK\n\n\n\n\n14.45-15.45\n12\nGroup presentations\nSeb Funk\n\n\n\n15.45-16.15\n13\nWrap-up\nYang/Nick/Oli"
  },
  {
    "objectID": "09_Networks_solutions.html",
    "href": "09_Networks_solutions.html",
    "title": "09. Networks (solutions)",
    "section": "",
    "text": "# Network modelling, practical 1: Introduction to the igraph package\n\nlibrary(igraph) # For network functionality\nlibrary(data.table)\nlibrary(ggplot2)\n\n## 1. Building and plotting graphs\n\n# Complete graph with 4 nodes\ngr &lt;- make_full_graph(4)\nprint(gr)\nplot(gr)\n\n# Plot different graphs each with 16 vertices, but different connections \n# between vertices:\ngr &lt;- make_full_graph(16)\nplot(gr)\ngr &lt;- make_ring(16)\nplot(gr)\ngr &lt;- make_ring(16, circular = FALSE)\nplot(gr)\ngr &lt;- make_lattice(c(4, 4))\nplot(gr)\n\n# Compare a connected graph with 16 vertices to an Erdős-Rényi G(n, p) graph\n# with 16 vertices:\nplot(make_full_graph(16), layout = layout_in_circle)\nplot(sample_gnp(16, 0.2), layout = layout_in_circle)\n\n# Other random graphs: The \"small-world\" model by Watts and Strogatz, where \n# there are connections between neighbours, some of which are randomly rewired:\nplot(sample_smallworld(1, 16, 2, 0.1), layout = layout_in_circle)\n\n# The \"preferential attachment\" model by Barabási and Albert, which is built\n# by adding nodes one at a time, and each time a node is added, it is connected\n# to other nodes, where the connection is more likely to be made to a node that\n# already has more connections (a \"rich get richer\" dynamic).\nplot(sample_pa(16, directed = FALSE))\n\n\n## 2. Getting and setting properties of the graph\n\n# Start by making a new 'lattice' graph:\nnetwork &lt;- make_lattice(c(5, 5))\nprint(network)\nplot(network)\n\n# Some simple calculations: vcount() or ecount() give the number of vertices or \n# edges in the graph; degree() gives the number of neighbours of each vertex. \nvcount(network)\necount(network)\ndegree(network)\n\n# With igraph, you can get and set attributes of the entire graph using the\n# `$` operator. For example, let's set the graph's layout to a grid:\nnetwork$layout &lt;- layout_on_grid(network)\nprint(network)\nplot(network)\n\n# You can also modify properties of the vertices and of the edges, using\n# V() and E() respectively.\nV(network)$color &lt;- \"azure\"\nE(network)$color &lt;- \"pink\"\nplot(network) # lovely\n\n# You can use V(network)[[]] or E(network)[[]] to see the properties of the\n# vertices/edges laid out as a data frame:\nV(network)[[]]\nE(network)[[]]\n\n# The \"color\" attribute is now also listed when we print the network:\nnetwork\n\n# Finally, we can also use brackets [] to change properties of only certain\n# vertices/edges. \n\nV(network)[12]$color &lt;- \"orange\"\nplot(network)\n\nV(network)[color == \"orange\"]$color &lt;- \"pink\"\nplot(network)\n\n# Pink is contagious:\nV(network)[.nei(color == \"pink\")]$color &lt;- \"pink\"\nplot(network)\n\n# What happens if you re-run the last two lines above several times?\n\n# Other interesting attributes for vertices include:\nV(network)$label &lt;- NA        # text label for the vertices (set to NA for no labels)\nV(network)$size &lt;- 5          # size of vertex markers\nV(network)$shape &lt;- \"square\"  # shape of markers\nplot(network)\n# See ?igraph.plotting for more.\n\n\n## Bonus: Code a network model\n# Here is one possible way of doing it...\nnetwork &lt;- make_lattice(c(5, 5))\n\n# Set all vertices to \"susceptible\" except for one \"infected\"\nV(network)$state &lt;- \"S\"\nV(network)[1]$state &lt;- \"I\"\n\n# Pick plotting colours\ncolours &lt;- c(S = \"lightblue\", I = \"red\", R = \"pink\")\n\n# Print and loop through time steps\nt_max &lt;- 10\nfor (t in 1:t_max)\n{\n    # Plot network\n    plot(network, \n        vertex.color = colours[V(network)$state], \n        layout = layout_on_grid)\n    \n    # Pause so we can see animation\n    Sys.sleep(1.0)\n    \n    # Find \"infector\" vertices\n    infectors &lt;- V(network)[state == \"I\"]\n    \n    # Infect susceptible neighbours of infectors\n    V(network)[.nei(infectors) & state == \"S\"]$state &lt;- \"I\"\n    \n    # Recover infectors\n    V(network)[infectors]$state &lt;- \"R\"\n}"
  },
  {
    "objectID": "09_Networks_solutions.html#practical-1.-introduction-to-the-igraph-package",
    "href": "09_Networks_solutions.html#practical-1.-introduction-to-the-igraph-package",
    "title": "09. Networks (solutions)",
    "section": "",
    "text": "# Network modelling, practical 1: Introduction to the igraph package\n\nlibrary(igraph) # For network functionality\nlibrary(data.table)\nlibrary(ggplot2)\n\n## 1. Building and plotting graphs\n\n# Complete graph with 4 nodes\ngr &lt;- make_full_graph(4)\nprint(gr)\nplot(gr)\n\n# Plot different graphs each with 16 vertices, but different connections \n# between vertices:\ngr &lt;- make_full_graph(16)\nplot(gr)\ngr &lt;- make_ring(16)\nplot(gr)\ngr &lt;- make_ring(16, circular = FALSE)\nplot(gr)\ngr &lt;- make_lattice(c(4, 4))\nplot(gr)\n\n# Compare a connected graph with 16 vertices to an Erdős-Rényi G(n, p) graph\n# with 16 vertices:\nplot(make_full_graph(16), layout = layout_in_circle)\nplot(sample_gnp(16, 0.2), layout = layout_in_circle)\n\n# Other random graphs: The \"small-world\" model by Watts and Strogatz, where \n# there are connections between neighbours, some of which are randomly rewired:\nplot(sample_smallworld(1, 16, 2, 0.1), layout = layout_in_circle)\n\n# The \"preferential attachment\" model by Barabási and Albert, which is built\n# by adding nodes one at a time, and each time a node is added, it is connected\n# to other nodes, where the connection is more likely to be made to a node that\n# already has more connections (a \"rich get richer\" dynamic).\nplot(sample_pa(16, directed = FALSE))\n\n\n## 2. Getting and setting properties of the graph\n\n# Start by making a new 'lattice' graph:\nnetwork &lt;- make_lattice(c(5, 5))\nprint(network)\nplot(network)\n\n# Some simple calculations: vcount() or ecount() give the number of vertices or \n# edges in the graph; degree() gives the number of neighbours of each vertex. \nvcount(network)\necount(network)\ndegree(network)\n\n# With igraph, you can get and set attributes of the entire graph using the\n# `$` operator. For example, let's set the graph's layout to a grid:\nnetwork$layout &lt;- layout_on_grid(network)\nprint(network)\nplot(network)\n\n# You can also modify properties of the vertices and of the edges, using\n# V() and E() respectively.\nV(network)$color &lt;- \"azure\"\nE(network)$color &lt;- \"pink\"\nplot(network) # lovely\n\n# You can use V(network)[[]] or E(network)[[]] to see the properties of the\n# vertices/edges laid out as a data frame:\nV(network)[[]]\nE(network)[[]]\n\n# The \"color\" attribute is now also listed when we print the network:\nnetwork\n\n# Finally, we can also use brackets [] to change properties of only certain\n# vertices/edges. \n\nV(network)[12]$color &lt;- \"orange\"\nplot(network)\n\nV(network)[color == \"orange\"]$color &lt;- \"pink\"\nplot(network)\n\n# Pink is contagious:\nV(network)[.nei(color == \"pink\")]$color &lt;- \"pink\"\nplot(network)\n\n# What happens if you re-run the last two lines above several times?\n\n# Other interesting attributes for vertices include:\nV(network)$label &lt;- NA        # text label for the vertices (set to NA for no labels)\nV(network)$size &lt;- 5          # size of vertex markers\nV(network)$shape &lt;- \"square\"  # shape of markers\nplot(network)\n# See ?igraph.plotting for more.\n\n\n## Bonus: Code a network model\n# Here is one possible way of doing it...\nnetwork &lt;- make_lattice(c(5, 5))\n\n# Set all vertices to \"susceptible\" except for one \"infected\"\nV(network)$state &lt;- \"S\"\nV(network)[1]$state &lt;- \"I\"\n\n# Pick plotting colours\ncolours &lt;- c(S = \"lightblue\", I = \"red\", R = \"pink\")\n\n# Print and loop through time steps\nt_max &lt;- 10\nfor (t in 1:t_max)\n{\n    # Plot network\n    plot(network, \n        vertex.color = colours[V(network)$state], \n        layout = layout_on_grid)\n    \n    # Pause so we can see animation\n    Sys.sleep(1.0)\n    \n    # Find \"infector\" vertices\n    infectors &lt;- V(network)[state == \"I\"]\n    \n    # Infect susceptible neighbours of infectors\n    V(network)[.nei(infectors) & state == \"S\"]$state &lt;- \"I\"\n    \n    # Recover infectors\n    V(network)[infectors]$state &lt;- \"R\"\n}"
  },
  {
    "objectID": "09_Networks_solutions.html#practical-2.-a-network-model-of-mpox-transmission",
    "href": "09_Networks_solutions.html#practical-2.-a-network-model-of-mpox-transmission",
    "title": "09. Networks (solutions)",
    "section": "Practical 2. A network model of mpox transmission",
    "text": "Practical 2. A network model of mpox transmission\n\n# Network modelling, practical 2: A network model of mpox transmission\n\nlibrary(igraph)\nlibrary(data.table)\nlibrary(ggplot2)\n\n\n### Setting up the network\n\n# Set up a transmission network of n nodes by preferential attachment with \n# affinity proportional to degree^m.\ncreate_network &lt;- function(n, d, layout = layout_nicely)\n{\n    # Create the network by preferential attachment, passing on the parameters \n    # n and power\n    network &lt;- sample_pa(n, d, directed = FALSE)\n\n    # Add the \"state\" attribute to the vertices of the network, which can be\n    # \"S\", \"I\", \"R\", or \"V\". \n    # Start out everyone as susceptible ...\n    V(network)$state &lt;- \"S\"\n    # ... except make 5 random individuals infectious.\n    V(network)$state[sample(vcount(network), 5, prob = degree(network))] &lt;- \"I\"\n\n    # Reorder vertices so they go in order from least to most connected. This\n    # is to help with degree-targeted vaccination, and also to make the \n    # most connected vertices plot on top so they don't get hidden. \n    network &lt;- permute(network, rank(degree(network), ties.method = \"first\"))\n    # Set the network layout so it doesn't change every time it's plotted.\n    network$layout &lt;- layout(network)\n    \n    return (network)\n}\n\n## See how the parameter d to create_network changes the network structure\nnet &lt;- create_network(40, 0)\nplot(net)\n\nnet &lt;- create_network(40, 1)\nplot(net)\n\nnet &lt;- create_network(40, 2)\nplot(net)\n\n# Plot a network, highlighting the degree of each node by different colours.\nplot_degree &lt;- function(network)\n{\n    # Set up palette\n    colors &lt;- hcl.colors(5, \"Zissou 1\")\n    \n    # Classify nodes by degree\n    deg &lt;- cut(degree(network), \n        breaks = c(1, 2, 5, 10, 20, Inf),\n        labels = c(\"1\", \"2-4\", \"5-9\", \"10-19\", \"20+\"),\n        include.lowest = TRUE, right = FALSE)\n\n    # Plot network\n    plot(network, \n        vertex.color = colors[deg],\n        vertex.label = NA,\n        vertex.size = 4)\n    legend(\"topright\", levels(deg), fill = colors, title = \"Degree\")\n}\n\n## Look at the degree distribution plotted for different values of d\nnet &lt;- create_network(500, 1)\nplot_degree(net)\n\nnet &lt;- create_network(500, 1.5)\nplot_degree(net)\n\nnet &lt;- create_network(500, 2)\nplot_degree(net)\n\n# Plot a network, colouring by state (S/I/R/V).\nplot_state &lt;- function(network)\n{\n    # Set up palette\n    colors &lt;- c(S = \"lightblue\", I = \"red\", R = \"darkblue\", V = \"white\")\n    \n    # Plot network\n    plot(network, \n        vertex.color = colors[V(network)$state], \n        vertex.label = NA,\n        vertex.size = 4)\n    legend(\"topright\", names(colors), fill = colors, title = \"State\")\n}\n\n## Test the plot_state function\nnet &lt;- create_network(500, 1)\nplot_state(net)\n\n\n### Running the model\n\n# Enact one step of the network model: infectious individuals infect \n# susceptible neighbours with probability p, and recover after one time step.\nnetwork_step &lt;- function(net, p)\n{\n    # Identify all susceptible neighbours of infectious individuals, \n    # who are \"at risk\" of infection\n    at_risk &lt;- V(net)[state == \"S\" & .nei(state == \"I\")]\n    \n    # Use the transmission probability to select who gets exposed from\n    # among those at risk\n    exposed &lt;- at_risk[runif(length(at_risk)) &lt; p]\n    \n    # All currently infectious individuals will recover\n    V(net)[state == \"I\"]$state &lt;- \"R\"\n    \n    # All exposed individuals become infectious\n    V(net)[exposed]$state &lt;- \"I\"\n\n    return (net)\n}\n\n# Run the transmission model on the network with maximum simulation time t_max\n# and transmission probability p; plot the network as the model is running if\n# animate = TRUE.\nrun_model &lt;- function(net, t_max, p, animate = FALSE)\n{\n    # Plot network degree\n    if (animate) {\n        plot_degree(net)\n        Sys.sleep(2.0)\n    }\n\n    # Set up results\n    dt &lt;- list()\n\n    # Iterate over each time step\n    for (t in 0:t_max)\n    {\n        # Store results\n        dt[[length(dt) + 1]] &lt;- data.table(\n            S = sum(V(net)$state == \"S\"),\n            I = sum(V(net)$state == \"I\"),\n            R = sum(V(net)$state == \"R\"),\n            V = sum(V(net)$state == \"V\")\n        )\n\n        # Plot current state\n        if (animate) {\n            Sys.sleep(0.5)\n            plot_state(net)\n        }\n        \n        # Stop early if no infectious individuals are left\n        if (!any(V(net)$state == \"I\")) {\n            break;\n        }\n\n        # Run one step of the network model\n        net &lt;- network_step(net, p)\n    }\n    \n    # Return results, including empirical calculation of Rt\n    results &lt;- rbindlist(dt, idcol = \"t\")\n    results$Rt &lt;- results$I / shift(results$I, 1) # new infections per new infection last time step\n    return (results)\n}\n\n\n## Run an example simulation\nnet &lt;- create_network(500, 1)\nrun_model(net, 100, 0.8, TRUE)\n\n\n### Bonus material: vaccination and multiple runs\n\n# Vaccinate a fraction v of the nodes in the network. The parameter k, between\n# -1 and 1, determines the association between network degree and vaccination.\nvaccinate_network &lt;- function(network, v, k)\n{\n    # Count total population (n) and number to vaccinate (nv)\n    n &lt;- vcount(network)\n    nv &lt;- rbinom(1, n, v)\n\n    # If k &gt; 0, vaccinate the nv most-connected individuals; if k &lt;= 0, \n    # vaccinate the nv least-connected individuals.\n    if (k &gt; 0) {\n        target &lt;- (n - nv + 1):n\n    } else {\n        target &lt;- 1:nv\n    }\n    V(network)[target]$state &lt;- \"V\"\n    \n    # Now randomly shuffle the state of a fraction 1 - abs(k) of individuals.\n    shuffle &lt;- which(rbinom(n, 1, 1 - abs(k)) == 1)\n    V(network)[shuffle]$state &lt;- sample(V(network)[shuffle]$state)\n\n    return (network)\n}\n\n# Run the model nsim times with parameters in params (n, d, v, k, t_max, p),\n# showing the animated network the first nanim times, and returning a data.table\n# with the results of each simulation.\nrun_scenario &lt;- function(params, nsim, nanim = 1)\n{\n    results &lt;- list()\n    \n    for (sim in 1:nsim)\n    {\n        net &lt;- create_network(params$n, params$d)\n        net &lt;- vaccinate_network(net, params$v, params$k)\n\n        results[[sim]] &lt;- run_model(net, params$t_max, params$p, animate = sim &lt;= nanim)\n        \n        cat(\".\")\n    }\n    cat(\"\\n\");\n    \n    results &lt;- rbindlist(results, idcol = \"run\")\n    return (results)\n}\n\n## Test multiple runs\nparams &lt;- list(\n    n = 500,\n    d = 0,\n    p = 0.8,\n    v = 0.3,\n    k = -0.5,\n    t_max = 100\n)\n\n# Do a test run!\nx &lt;- run_scenario(params, nsim = 50)\nggplot(x) +\n    geom_line(aes(x = t, y = R, group = run))\n\nReturn to the practical here."
  },
  {
    "objectID": "00_01_3_IntroToR_practical.html",
    "href": "00_01_3_IntroToR_practical.html",
    "title": "P01. Introduction to R, part 3",
    "section": "",
    "text": "A. Read in the same data as before\nThis file can be downloaded from here.\n\nmyTBdata &lt;- read.table(\"TB_stats.txt\", header=TRUE)\n\nB. Plot the mortality in HIV negative against HIV positive check the plot function help file\n\n?plot\n\nplot is a generic function, and depending on what type of data you pass the function R will use different sub-functions (you dont need to worry about how it handles this!).\n\n# make the plot\nplot(x=myTBdata$HIV_neg_TB_mortality, y=myTBdata$HIV_pos_TB_mortality)\n\nC. Add meaningful axes labels\n\nplot(x=myTBdata$HIV_neg_TB_mortality, \n     y=myTBdata$HIV_pos_TB_mortality,\n     xlab=\"Mortality in HIV negative people\",\n     ylab=\"Mortality in HIV positive people\")\n\nD. Add a meaningful title\n\nplot(x=myTBdata$HIV_neg_TB_mortality, \n     y=myTBdata$HIV_pos_TB_mortality,\n     xlab=\"Mortality in HIV negative people\",\n     ylab=\"Mortality in HIV positive people\",\n     main=\"Comparison of mortality in HIV negative and positive\")\n\nE. Change the colour of the points to red\n\nplot(x=myTBdata$HIV_neg_TB_mortality, \n     y=myTBdata$HIV_pos_TB_mortality,\n     xlab=\"Mortality in HIV negative people\",\n     ylab=\"Mortality in HIV positive people\",\n     main=\"Comparison of mortality in HIV negative and positive\",\n     col=\"red\")\n\nF. It’s hard to see the numbers because some are small and some very large Using a log scale is useful for that.You can either log the values and re-plot, or use the log option in plot()\n\nplot(x=myTBdata$HIV_neg_TB_mortality, \n     y=myTBdata$HIV_pos_TB_mortality,\n     xlab=\"Mortality in HIV negative people\",\n     ylab=\"Mortality in HIV positive people\",\n     main=\"Comparison of mortality in HIV negative and positive\",\n     col=\"red\",\n     log=\"xy\")\n\nG. Now let’s make a different kind of plot Show the distribution of Total_TB_mortality in a histogram and then change the x axis label. Note, same options as before.\n\nhist(myTBdata$Total_TB_mortality)\n\nhist(myTBdata$Total_TB_mortality,\n     xlab=\"Number\")\n\nNow add a meaningful title to the plot\n\n# Add your code here\n\nH. Check what other aspects of the histogram you can change\n\n?hist\n\nThen change the color to “blue” in the last plot\n\nhist(myTBdata$Total_TB_mortality,\n     xlab=\"Number\",\n     main=\"Total TB mortality\",\n     col=\"blue\")\n\nI. Now let’s plot a histogram of mortality per 1000\nHint: calculate it as in the previous practical\n\n# Add your code here\n\nAnd add a title, and x axis label\n\n# Add your code here\n\nchange the color to something different hint: to find more colours, run “colors()” or google “Colors in R”\n\n# Add your code here\n\nJ. Now let’s show both histograms at the same time you need to make a call to “par”, short for parameters, setting the plot parameter “mfrow” (Multi-Figure ROW-wise) gives 1 row, and 2 columns of plot\n\npar(mfrow=c(1,2))\nhist(myTBdata$Total_TB_mortality,\n     xlab=\"Number\",\n     main=\"Total TB mortality\",\n     col=\"blue\")\n\ncut and paste your plot code from I. here and run it. Then resize the plot window and see what happens\nK. Export the figure and save it as a PNG with a useful name\nHint: use the Export button in the plot window\nL. R has functions for every kind of plot for example:\n\n?barplot\n?boxplot\n?contour\n\nand stackoverflow.com has a lot of comments and help on every kind of plot\nAdvanced plotting exercises\nMake a plot where:\n\nx=Total_TB_mortality and y=HIV_pos_TB_mortality\nboth aces are on the on the log scale\ncolour the points\nadd axis labels and a title\n\n\n# Add your code here\n\nadd HIV_neg_TB_mortality on the same y axis, in a different colour.\nHint: use points(). see ?points for information\n\n# Add your code here\n\ndo you need to change the y axis label? i.e. does it still make sense now that it shows negative and positive mortality?\nAnswer:\nSome of the points no longer fit on the graph. Why is this? You need to alter the y limit (ylim), which is an option of plot. What value will you choose?\nHint: the maximum value that the data go to change the ylim of the plot.\n\n# Add your code here\n\nThe plot now has 2 data sets in different colours, so it needs a legend check the help of legend (there’s a lot of options!)\nHint: use x=“topright” instead of setting the x and y values for location.\nHint: use the option “fill” to change the colours\n\n# Add your code here\n\nThe solutions can be accessed here."
  },
  {
    "objectID": "05_Metapop_practical.html",
    "href": "05_Metapop_practical.html",
    "title": "05. Metapopulations with ODEs",
    "section": "",
    "text": "The code below has been written to solve a Susceptible-Infected-Recovered model with two populations. Familiarise yourself with the expanded model before moving onto the activities that follow. Note: the compartments C1 and C2 reflect the cumulative numbers of people infected. This will be used later on.\n# Load in the deSolve package\nlibrary(deSolve)\n# If the package is not installed, install using the install.packages() function\n\n# Define model function \nSIR_metapop_model &lt;- function(times, state, parms){\n  ## Define variables\n  S1 &lt;- state[\"S1\"]\n  I1 &lt;- state[\"I1\"]\n  R1 &lt;- state[\"R1\"]\n  C1 &lt;- state[\"C1\"]\n  N1 &lt;- S1 + I1 + R1\n  S2 &lt;- state[\"S2\"]\n  I2 &lt;- state[\"I2\"]\n  R2 &lt;- state[\"R2\"]\n  C2 &lt;- state[\"C2\"]\n  N2 &lt;- S2 + I2 + R2\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  alpha &lt;- parms[\"alpha\"]\n  lambda1 &lt;- (beta * I1 / N1 + alpha * beta * I2 / N2)\n  lambda2 &lt;- (beta * I2 / N2 + alpha * beta * I1 / N1)\n  # Define differential equations\n  dS1 &lt;- - lambda1 * S1\n  dI1 &lt;- lambda1 * S1 - gamma * I1\n  dR1 &lt;- gamma * I1\n  dC1 &lt;- lambda1 * S1\n  dS2 &lt;- - lambda2 * S2\n  dI2 &lt;-  lambda2 * S2 - gamma * I2\n  dR2 &lt;- gamma * I2\n  dC2 &lt;- lambda2 * S2\n  res &lt;- list(c(dS1, dI1, dR1, dC1, dS2, dI2, dR2, dC2))\n  return(res)\n}\n\n# Define parameters  \nparameters &lt;- c( beta = 0.4, gamma = 0.1, alpha = 1)\n\n# Define time to run model\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN1 &lt;- 1000; N2 &lt;- 1000\nI1_0 &lt;- 1; I2_0 &lt;- 0\nR1_0 &lt;- 0; R2_0 &lt;- 0\nC1_0 &lt;- 0; C2_0 &lt;- 0\nS1_0  &lt;- N1 - I1_0\nS2_0  &lt;- N2 - I2_0\nstate &lt;- c(S1 = S1_0, I1 = I1_0, R1 = R1_0, C1 = C1_0, \n           S2 = S2_0, I2 = I2_0, R2 = R2_0, C2 = C2_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, \n                  times = times, \n                  func = SIR_metapop_model, \n                  parms = parameters,\n                  method = rk4)\n\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar(mfrow = c(1, 1))\nplot(output$time, output$I1, type = \"l\", col = 4, lwd = 2, ylim = c(0, N1),\n      xlab = \"Time\", ylab = \"Number\", main = \"\")\nlines(output$time, output$I2, lwd = 2, col = 2, type = \"l\")\nlegend(\"topright\", \n       legend = c(\"Infected in population 1\", \n                  \"Infected in population 2\"),\n       lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "05_Metapop_practical.html#question-a",
    "href": "05_Metapop_practical.html#question-a",
    "title": "05. Metapopulations with ODEs",
    "section": "Question A",
    "text": "Question A\nWhen you simulate the above model, you’ll notice that currently the epidemics are nearly identical in the two populations. Update the model parameters so the transmission rate between the two populations is equal to 5% of the transmission rate within each population. What happens to the size and timing of the epidemics?"
  },
  {
    "objectID": "05_Metapop_practical.html#question-b",
    "href": "05_Metapop_practical.html#question-b",
    "title": "05. Metapopulations with ODEs",
    "section": "Question B",
    "text": "Question B\nWhat happens if the epidemic starts with 10 people infected in both populations? Why does this happen?"
  },
  {
    "objectID": "05_Metapop_practical.html#question-c",
    "href": "05_Metapop_practical.html#question-c",
    "title": "05. Metapopulations with ODEs",
    "section": "Question C",
    "text": "Question C\nThe model is currently set up to record the number of cumulative cases in each population (i.e. C1 and C2). The below code will plot these cumulative numbers of cases. Update the code so you are plotting incidence, i.e. new cases appearing over time, rather than cumulative cases.\n\npar(mfrow = c(1, 1))\nplot(output$time, output$C1, type = \"l\", col = 4, lwd = 2, ylim = c(0, N1+100), \n     xlab = \"Time\", ylab = \"Number\", main = \"\")\nlines( output$time, output$C2, lwd = 2, col = 2, type = \"l\")\nlegend(\"topright\", \n       legend = c(\"Cumulative cases in population 1\", \n                  \"Cumulative cases in population 2\"),\n       lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\nHint: Create a new variable that calculates the difference between adjacent timesteps, i.e. C1[2:t] - C1[1:(t-1)]"
  },
  {
    "objectID": "05_Metapop_practical.html#question-d",
    "href": "05_Metapop_practical.html#question-d",
    "title": "05. Metapopulations with ODEs",
    "section": "Question D",
    "text": "Question D\nWhat does the incidence look like if only 50% of the cases in population 2 are reported?\nHint: There are several ways to do this - some are easier than others."
  },
  {
    "objectID": "05_Metapop_practical.html#question-e",
    "href": "05_Metapop_practical.html#question-e",
    "title": "05. Metapopulations with ODEs",
    "section": "Question E",
    "text": "Question E\nIf you have time, expand the model to include three populations (denoted 1, 2, 3). How would you model an epidemic where:\n\nmixing between population 1 and population 2 is 5% of the rate of mixing within these populations\nmixing between population 1 and population 3 is 10% of the rate of mixing within these populations\nthere is no mixing between population 2 and population 3\n\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "06_SensitivitySampling_practical.html",
    "href": "06_SensitivitySampling_practical.html",
    "title": "06. Sensitivity analysis and sampling",
    "section": "",
    "text": "First, let’s run an ODE model. Download and open up the SIRmodel.R\n\n\nAnswer:\n\n\n\nAnswer:\n\n\n\nAnswer:\n# First let's clear our workspace, remove plots and load the libraries we need\nrm(list=ls())\ndev.off()\nlibrary(deSolve)\nlibrary(ggplot2)\n\n# Let's read in these functions so we have them to hand\n&lt;YOUR CODE HERE&gt;\n\n# Let's choose a beta value of 0.4 and a gamma value of 0.2\nmax.prevalence &lt;- solveODE(parameters &lt;- c(beta = 0.4, gamma = 0.2))\nprint(max.prevalence)\n\n# Now let's look at the effect of the maximum prevalence of the epidemic across \n# gamma = 0.1 -1.0 (increment on 0.1)\ngamma.vec &lt;- &lt;YOUR CODE HERE&gt;\n\n# initialise max/prevalence container\nmax.prevalence &lt;- vector()\n\n# Add in a loop to make this happen\n\n&lt;YOUR CODE HERE&gt;\n\nmp &lt;- solveODE(parameters = c(beta = 0.4, gamma = gamma.val),\nplot.all.results = FALSE)\nmax.prevalence &lt;- c(max.prevalence, mp)\n\n&lt;YOUR CODE HERE&gt;\n\n# Now we have our max.prevalence, we need to plot this against our \n# infectiousness duration - plot max.prevalence as a function of the \n# \\*infectiousness duration\\*\n\npar(new=FALSE)\npar(mfrow=c(1,1))\n\nplot(&lt;YOUR CODE HERE&gt;, \n     &lt;YOUR CODE HERE&gt;, \n     type = \"b\",\n     xlab = \"Infectiousness Duration (days)\",\n     ylab = \"Maximum Prevalence\",\n     main = \"One-way uncertainty analysis\")\n\n# Now try to increase the resolution of gamma to get a better idea of the \n# relationship but remember to clear max.prevalence first!\n\n&lt;YOUR CODE HERE&gt;\n\n\n\nAnswer:"
  },
  {
    "objectID": "06_SensitivitySampling_practical.html#one-way-sensitivity-analyses",
    "href": "06_SensitivitySampling_practical.html#one-way-sensitivity-analyses",
    "title": "06. Sensitivity analysis and sampling",
    "section": "",
    "text": "First, let’s run an ODE model. Download and open up the SIRmodel.R\n\n\nAnswer:\n\n\n\nAnswer:\n\n\n\nAnswer:\n# First let's clear our workspace, remove plots and load the libraries we need\nrm(list=ls())\ndev.off()\nlibrary(deSolve)\nlibrary(ggplot2)\n\n# Let's read in these functions so we have them to hand\n&lt;YOUR CODE HERE&gt;\n\n# Let's choose a beta value of 0.4 and a gamma value of 0.2\nmax.prevalence &lt;- solveODE(parameters &lt;- c(beta = 0.4, gamma = 0.2))\nprint(max.prevalence)\n\n# Now let's look at the effect of the maximum prevalence of the epidemic across \n# gamma = 0.1 -1.0 (increment on 0.1)\ngamma.vec &lt;- &lt;YOUR CODE HERE&gt;\n\n# initialise max/prevalence container\nmax.prevalence &lt;- vector()\n\n# Add in a loop to make this happen\n\n&lt;YOUR CODE HERE&gt;\n\nmp &lt;- solveODE(parameters = c(beta = 0.4, gamma = gamma.val),\nplot.all.results = FALSE)\nmax.prevalence &lt;- c(max.prevalence, mp)\n\n&lt;YOUR CODE HERE&gt;\n\n# Now we have our max.prevalence, we need to plot this against our \n# infectiousness duration - plot max.prevalence as a function of the \n# \\*infectiousness duration\\*\n\npar(new=FALSE)\npar(mfrow=c(1,1))\n\nplot(&lt;YOUR CODE HERE&gt;, \n     &lt;YOUR CODE HERE&gt;, \n     type = \"b\",\n     xlab = \"Infectiousness Duration (days)\",\n     ylab = \"Maximum Prevalence\",\n     main = \"One-way uncertainty analysis\")\n\n# Now try to increase the resolution of gamma to get a better idea of the \n# relationship but remember to clear max.prevalence first!\n\n&lt;YOUR CODE HERE&gt;\n\n\n\nAnswer:"
  },
  {
    "objectID": "06_SensitivitySampling_practical.html#monte-carlo-sampling",
    "href": "06_SensitivitySampling_practical.html#monte-carlo-sampling",
    "title": "06. Sensitivity analysis and sampling",
    "section": "(2) Monte Carlo Sampling",
    "text": "(2) Monte Carlo Sampling\nNow suppose that we have a previous epidemiological study that suggested that R0 has a mean value of 5, but uncertainty within the range of [-1, +1]. However, we still don’t know whether the infectiousness period is 1 day or 10 days. We will now use the functions in SIRmodel_R0.R to make a similar plot as above, but this time, incorporate the uncertainty of R0 for each discrete value of gamma. We’re going to first use a direct Monte Carlo Sampling method.\n# Read in our set of functions in SIRmodel_R0.R\n&lt;YOUR CODE HERE&gt;\n\n# First, let's set a fixed seed for the random number generator\n# this will allow us to run the code again and retrieve the same 'simulation'\nset.seed(2019)\n\n# Now, draw R0 1,000 times from a suitable distribution (e.g. normal)\nr0.all = &lt;YOUR CODE HERE&gt;\nsize.df = length(r0.all) * length(gamma.vec)\n\n# initialise max.prevalence again, this time it needs to be a dataframe \n# or a matrix\nmax.prevalence = data.frame(r0.value = vector(mode = \"numeric\", \n                                            length = size.df),\ngamma = vector(mode= \"numeric\", length = size.df),\nmax.prev = vector(mode= \"numeric\", length = size.df))\nindex = 0\n\n# create a loop over each of these R0 values in turn\nfor (r0.val in r0.all){\n# create a loop over each of these Gamma values in turn\n    for (gamma.val in gamma.vec){\n    index = index + 1\n    mp = solveODE_2(parameters = c(R0 = r0.val, gamma = gamma.val))\n    max.prevalence[index, \"r0.value\"] = r0.val\n    max.prevalence[index, \"gamma\"] = gamma.val\n    max.prevalence[index, \"max.prev\"] = mp\n    }\n}\n\n# Take a look at max.prevalence by using the 'head() function\nhead(max.prevalence)\n\n(e) How have we saved the output?\nAnswer:\nNow plot this output using the R function MCplot() in SIRmodel_R0.R\nMCplot(max.prevalence)\n\n\n(f) What conclusions can you draw from the plot?\nAnswer:"
  },
  {
    "objectID": "06_SensitivitySampling_practical.html#latin-hypercube-sampling-lhs-vs-monte-carlo-sampling",
    "href": "06_SensitivitySampling_practical.html#latin-hypercube-sampling-lhs-vs-monte-carlo-sampling",
    "title": "06. Sensitivity analysis and sampling",
    "section": "(3) Latin hypercube sampling (LHS) vs Monte Carlo Sampling",
    "text": "(3) Latin hypercube sampling (LHS) vs Monte Carlo Sampling\n# First let's load in the library we'll need for later\nlibrary(lhs)\n\n# We're going to first sample directly from a full distribution uniform \n# distribution from 0 to 1. How many samples will we need to take? \n# Let's try a few options and see how well they do\n\npar(mfrow=c(3,2))\nhist(rnorm(10))\nhist(rnorm(100))\nhist(rnorm(1000))\nhist(rnorm(10000))\nhist(rnorm(20000))\n\n# Now let's plot the sample sizes against the variance of the sample distribution\n\nplot(\n    c(10,100,1000,10000,50000,100000),\n    c(var(rnorm(10)), var(rnorm(100)), var(rnorm(1000)), var(rnorm(10000)), \n      var(rnorm(50000)), var(rnorm(100000))),\n    ylab = \"variance\", main = \"Variance of sampled normal\"\n    )\nabline(h = 1)\n\n# Let's now use 100 samples to see the difference between a Monte Carlo \n# sampling and a LHS sampling approach\n# Pick some small number of samples\nn &lt;- 100\n\n# First we're going to sample 100 times from a random sample\nmc_unif &lt;- runif(n)\n\n# 100 lh samples across 1 parameter\nlatin_unif &lt;- randomLHS(n, 1)\n\n# plot these two distribution\ndev.off()\npar(mfrow=c(3,2))\nhist(mc_unif)\nhist(latin_unif)\n\n# You can see how the Latin Hypercube does a great job of sampling evenly across \n# the distribution. Let's now sample from a Normal distribution using a random \n# monte carlo sample across the whole distribution.\nmc_norm &lt;- rnorm(n, mean = 0, sd = 1)\n\n# How do we sample using an LHS? We use the previous numbers generated from the \n# uniform LHS to draw samples from the Normal using the Inverse Cumulative \n# Sampling\nlatin_norm &lt;- qnorm(latin_unif, mean = 0, sd = 1)\n\n# plot these two normal distributions\nhist(mc_norm)\nhist(latin_norm)\n\n# the latin hypercube sample looks much better! Why does this work?\n# first let's look at the norm probability distibution\nx &lt;- seq(-6,6, by =0.1) # random variable X\nnormdens &lt;- dnorm(x, mean = 0, sd = 1) # prob distribution, f(X)\nnormcumul &lt;- pnorm(x, mean = 0, sd = 1) # cumulative distribution, F(X)\n\nplot(x, normdens, \"l\")\nplot(x, normcumul, \"l\")\n\n# Most of the density is in the middle range of values (-1 to 1).\n\n# So we want a method to sample from this more often than the other areas in \n# the distribution. Specifically, we want to sample values from X proportionally \n# to the probability of those values occuring. Let's generate some samples \n# between 0-1. These can be values on our Y-axis. Then, if we ask what is the \n# value of the cumulative distribution that corresponds to these uniform \n# values we are taking the inverse for illustration let's just choose 10 points.\n\nex_latin &lt;- randomLHS(10, 1)\n\n# which X values are given by using these as the Y value (denoted by \"X\"s)?\n\nabline(h = ex_latin, col = \"red\")\npoints(qnorm(ex_latin, mean = 0, sd = 1), y=rep(0,10), pc = \"x\")\n\n# You can see that the samples are clustered around the middle: in areas of X \n# with higher density, the gradient of the cumluative distribution (F(X)) will \n# be very steep, causing more values between 0 and 1 to map to this range of X \n# with high density That is, F\\^{-1}(R) = X where R is a uniform random number \n# between 0 and 1.\n\n# So, you can sample from any distribution whose cumluative function is \n# 'invertable' by plugging in uniform random numbers to the inverse cumulative \n# function of your new distribution. For more information check out: \n# https://en.wikipedia.org/wiki/Inverse_transform_sampling\n\n# Likewise, to perform LHS on a uni- or mulitvariate non-uniform distribution, \n# we can transform our LHS samples from a uniform distribution as above.\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "00_01_2_IntroToR_solutions.html",
    "href": "00_01_2_IntroToR_solutions.html",
    "title": "P01. Introduction to R, part 2: solutions",
    "section": "",
    "text": "A. read in a data file\n\nmyTBdata &lt;- read.table(\"TB_stats.txt\", header=TRUE)\n\nIn order to run this, your computer need to know where “TB_stats.txt” is. You could download it here.\nWhat does the “header=TRUE” option mean?\nAnswer: R reads in the first row as the column headers (or, names)\nB. Have a look at the first few lines\n\n# Now let's investigate the data file\nhead(myTBdata)\n\n                   Country HIV_neg_TB_mortality HIV_pos_TB_mortality\n1                   Angola                11000                 7200\n2               Bangladesh                73000                  230\n3                   Brazil                 5500                 2200\n4                 Cambodia                 8600                  440\n5 Central_African_Republic                 2200                 2700\n6                    China                35000                 2600\n  Total_TB_mortality HIV_pos_TB_incidence Population\n1              93000                28000   25000000\n2             362000                  630  161000000\n3              84000                13000  208000000\n4              59000                 1400   15600000\n5              19000                 8600    4900000\n6             918000                15000 1380000000\n\n\nHow many rows can you see? What is the first row?\nAnswer: 1 row of column names and 6 rows of data\nC. What are the names of the columns?\n\nnames(myTBdata)\n\n[1] \"Country\"              \"HIV_neg_TB_mortality\" \"HIV_pos_TB_mortality\"\n[4] \"Total_TB_mortality\"   \"HIV_pos_TB_incidence\" \"Population\"          \n\n\nIs this what you expected?\nAnswer: We would expect there to be 6 elements to correspond to the 6 columns. Each column name is stored as a separate element in a vector.\nD. How many rows and columns are there in your data ?\n\ndim(myTBdata)\n\n[1] 30  6\n\n\nWhat is the first number telling you? And the second?\nAnswer: dim(…) gives you a 2 element vector; the first number is the number of rows, the second number is the number of columns.\nE. How are your data stored?\n\nattributes(myTBdata)\n\n$names\n[1] \"Country\"              \"HIV_neg_TB_mortality\" \"HIV_pos_TB_mortality\"\n[4] \"Total_TB_mortality\"   \"HIV_pos_TB_incidence\" \"Population\"          \n\n$class\n[1] \"data.frame\"\n\n$row.names\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30\n\n\nWhat new piece of information have you learned from the ‘attributes()’ function?\nAnswer: We now know that our data set is stored as a data.frame.\nF. Now take a look at some summary statistics for your data\n\nsummary(myTBdata)\n\n   Country          HIV_neg_TB_mortality HIV_pos_TB_mortality\n Length:30          Min.   :   780       Min.   :   40       \n Class :character   1st Qu.:  3725       1st Qu.:  935       \n Mode  :character   Median : 14500       Median : 3300       \n                    Mean   : 40543       Mean   :11269       \n                    3rd Qu.: 29250       3rd Qu.:10800       \n                    Max.   :480000       Max.   :73000       \n Total_TB_mortality HIV_pos_TB_incidence   Population       \n Min.   :  12000    Min.   :   450       Min.   :2.140e+06  \n 1st Qu.:  43250    1st Qu.:  5050       1st Qu.:1.560e+07  \n Median : 122500    Median : 14000       Median :5.370e+07  \n Mean   : 301600    Mean   : 33376       Mean   :1.546e+08  \n 3rd Qu.: 305500    3rd Qu.: 37500       3rd Qu.:1.325e+08  \n Max.   :2840000    Max.   :258000       Max.   :1.380e+09  \n\n\nLet’s extract some information from our data\nG. First, Calculate the total number of deaths across all countries.\nThe following two methods should give you the same answer\n\ntotal_TB_mortality1 &lt;- sum(myTBdata[,2:3]) # method 1\ntotal_TB_mortality2 &lt;- sum(myTBdata$HIV_pos_TB_mortality + myTBdata$HIV_neg_TB_mortality) # method 2\n\nDo you think one method is better than the other?\nAnswer: While method 1 is certaintly shorter, method 2 is generally better for two reasons: 1) it is easier to read because the column names provide information; 2) it is less liable to cause errors (if you for some reason change the indexing of your columns, method 1 might break).\nH. Now let’s check that both methods give the same answer.\nWe’ll use two ways to check this. First, let’s output both answers\n\ntotal_TB_mortality1\n\n[1] 1554340\n\ntotal_TB_mortality2\n\n[1] 1554340\n\n\nNow, let’s ask R to check whether they are both equal\n\ntotal_TB_mortality1==total_TB_mortality2 \n\n[1] TRUE\n\n# logical expression which gives TRUE if equal and FALSE if not\n\nWhy might you prefer to use the second check (using the logical expression) than the first?\nAnswer: For checking two numbers are the same, it is easy to output two numbers and manually check. However, for larger datasets or for multiple checks, comparison will be much quicker if they are automated.\nI. How different is the TB mortality rate in HIV positive persons in Lesotho compared to Zimbabwe?\nFirst, let’s add “mortality rate” as another column in our data frame\n\nmyTBdata$Mortality_Per1000 &lt;- 1000 * (myTBdata$HIV_pos_TB_mortality + myTBdata$HIV_neg_TB_mortality)/myTBdata$Population\n\nNow subset the dataset to extract the TB mortality rate for both Lesotho and Zimbabwe\n\nLesotho_mortalityrate &lt;- myTBdata[myTBdata$Country==\"Lesotho\", \"Mortality_Per1000\"]\nZimbabwe_mortalityrate &lt;- myTBdata[myTBdata$Country==\"Zimbabwe\", \"Mortality_Per1000\"]\nRelative_Mortality_Rate &lt;- Lesotho_mortalityrate / Zimbabwe_mortalityrate\n\nHow many times higher is the mortality rate for TB in Lesotho as it is in Zimbabwe?\n\npaste(\"The relative mortality rate is\", round(Relative_Mortality_Rate, 2), sep=\" \")\n\n[1] \"The relative mortality rate is 5.47\"\n\n\nJ. Finally in this section, let’s look at what can go wrong when reading in data files.\nIn order to complete this section, you would need to download readfileexample_1.txt, readfileexample_2.txt, and readfileexample_3.txt.\n(a) There is not an equal number of columns in each of the rows.\n\nreadFile_a &lt;- read.table(\"readfileexample_1.txt\", header=TRUE)\n\nHow do you fix this error? Hint: set missing values in the data file to be ‘Not Assigned’ by adding them as NA in the original file. Try running this line again with the updated file.\n(b) The wrong delimiter is used\n\nreadFile_b &lt;- read.table(\"readfileexample_2.txt\", header=TRUE)\n\n\n\n  Clinic.NumberOfTests.NumberOfPositiveTests\n1                                     1,10,5\n2                                      2,5,2\n3                                      3,6,1\n4                                    4,NA,NA\n5                                    5,NA,NA\n\n\nIs an error given? Check out ‘readFile_b’ - is it correct?\nAnswer: No error is given but if you type head(readFile_b), the file has not read properly. The file should be read in as a 5 x 3 data.frame. However, instead it is a 5 x 1\nHow do you fix this? Ask R for help (?read.table) Which option do you need to specify?\nAnswer: We must specify the delimiter of the text file\n\nreadFile_b &lt;- read.table(\"readfileexample_2.txt\", sep = \",\", header=TRUE)\n\n\n\n  Clinic NumberOfTests NumberOfPositiveTests\n1      1            10                     5\n2      2             5                     2\n3      3             6                     1\n4      4            NA                    NA\n5      5            NA                    NA\n\n\nIs there another way of fixing this problem?\nAnswer: We could use the function read.csv() which automatically uses the\n\nreadFile_b &lt;- read.csv(\"readfileexample_2.txt\", header=TRUE)\n\n\n\n  Clinic NumberOfTests NumberOfPositiveTests\n1      1            10                     5\n2      2             5                     2\n3      3             6                     1\n4      4            NA                    NA\n5      5            NA                    NA\n\n\n(c) The names are read in as data rows rather than names\n\nreadFile_c &lt;- read.csv(\"readfileexample_2.txt\", header=FALSE)\n\n\n\n      V1            V2                    V3\n1 Clinic NumberOfTests NumberOfPositiveTests\n2      1            10                     5\n3      2             5                     2\n4      3             6                     1\n5      4          &lt;NA&gt;                  &lt;NA&gt;\n6      5          &lt;NA&gt;                  &lt;NA&gt;\n\n\nIs an error given? Check out ‘readFile_c’ - is it correct?\nAnswer: No, R has read in the first row of the file as regular data points\nType a new line of code to correct this problem (hint: copy-paste from above and change one of the options)\n\nreadFile_c &lt;- read.csv(\"readfileexample_2.txt\", header=TRUE)\n\n\n\n  Clinic NumberOfTests NumberOfPositiveTests\n1      1            10                     5\n2      2             5                     2\n3      3             6                     1\n4      4            NA                    NA\n5      5            NA                    NA\n\n\n(d) One of more of the columns contain different classes\n\nreadFile_d &lt;- read.table(\"readfileexample_3.txt\", header=TRUE)\n\n\n\n  Clinic Catchment_1000s Doctors\n1      1             1.2      10\n2      2               5      12\n3      3             0.4       3\n4      4             1.1       5\n5      5             ten       6\n\n\nIs an error given? Check out ‘readFile_d’ - is it correct?\nAnswer: It appears to look OK. However one of the values has mistakenly been inputted as ‘ten’ rather than ‘10’. This means that the column has been saved as non-numeric.\nHow do you fix this issue? Hint: check the ‘class’ of the problem column. Try running this line again with an updated file.\nAnswer: CHANGE THE 5th row, 2nd column to the number 10 in the file and re-run the code"
  },
  {
    "objectID": "00_05_git.html",
    "href": "00_05_git.html",
    "title": "P04. Git and Github",
    "section": "",
    "text": "1. Check if git is installed\nGo to a Command Prompt window and type:\n    git --version\nIf not, then go to: https://git-scm.com/download and run the download. Accept all default options.\n2. Create a github account: github.com/join\n3. Download GitHub Desktop: https://desktop.github.com/\nOpen it, and sign in using your GitHub account"
  },
  {
    "objectID": "00_05_git.html#before-you-start",
    "href": "00_05_git.html#before-you-start",
    "title": "P04. Git and Github",
    "section": "",
    "text": "1. Check if git is installed\nGo to a Command Prompt window and type:\n    git --version\nIf not, then go to: https://git-scm.com/download and run the download. Accept all default options.\n2. Create a github account: github.com/join\n3. Download GitHub Desktop: https://desktop.github.com/\nOpen it, and sign in using your GitHub account"
  },
  {
    "objectID": "00_05_git.html#working-on-your-own",
    "href": "00_05_git.html#working-on-your-own",
    "title": "P04. Git and Github",
    "section": "Working on your own",
    "text": "Working on your own\n1. Open GitHub Desktop\n2. There should be 4 options underneath “Let’s get started!”\n3. Click “Create a New Repository on your Hard Drive”\n4. Fill in the details about your new repository\n5. Create Repository\n6. Once you’ve created it, it asks if you would like to publish to GitHub. Say yes!\n7. What happened now? Hint: check on GitHub.com in your account\n8. The app asks if you want to view the Files in the repository\n9. Say yes. Is there anything there?\n10. Go back to RStudio, and create a new R script. Write something, then save the script into the repository.\n11. What has happened in the GitHub Desktop app?\n12. Now we are going to commit this change. In the app make sure the file is selected in the check box. Write a commit message (make it useful, but not too long). Press commit.\n13. What has happened? Has the file appeared on GitHub.com?\n14. The blue button asks if you want to push to the origin. Say yes.\n15. What has happened now? Has the file appeared on GitHub.com? Can you see the commit message?\n16. Go back to RStudio. Make some changes to the script. Save it.\n17. Check in the GitHub app. What has happened?\n18. Add a commit message, commit, and push.\n19. Go back to RStudio, make another script and save it in the same folder.\n20. Commit and push."
  },
  {
    "objectID": "00_05_git.html#now-what",
    "href": "00_05_git.html#now-what",
    "title": "P04. Git and Github",
    "section": "Now what?",
    "text": "Now what?\n1. Find the repository folder.\n2. DELETE IT!\n3. Go back to the GitHub app. What does it say?\n4. Press “Clone again”.\n5. What has happened?"
  },
  {
    "objectID": "00_05_git.html#what-if-the-repository-exists-on-github-but-you-want-to-work-on-a-different-computer",
    "href": "00_05_git.html#what-if-the-repository-exists-on-github-but-you-want-to-work-on-a-different-computer",
    "title": "P04. Git and Github",
    "section": "What if the repository exists on Github but you want to work on a different computer?",
    "text": "What if the repository exists on Github but you want to work on a different computer?\n1. Delete the repository folder again.\n2. In the app, this time click “remove”.\n—&gt; OH NO! (or is it…)\n3. Back at the main menu, click “Clone a Repository from the Internet”\n4. Select the URL tab, and put in the URL of the repository on GitHub, click Clone.\n5. Check for the folder on your computer.\nIt’s back! (or it should be)\nIf you were working on this analysis on 2 (or more) computers, git can help you stay up to date.\nBut, the difference is you need the “Pull” button as well.\nWhat does this do?\nKey points:\n- Whenever you save a file in the repository (the special folder) the App will track it.\n- If you want to keep those changes, commit and push them to GitHub.com.\n- Write a useful commit message for each one, to help you remember what they do.\n- Make each commit quite small (~2-5 per day, if you’re doing analysis all day)\n- More than 1 person can do this at the same time and it will help you keep track of all the changes."
  },
  {
    "objectID": "00_05_git.html#extension-what-does-git-ignore-do",
    "href": "00_05_git.html#extension-what-does-git-ignore-do",
    "title": "P04. Git and Github",
    "section": "Extension: What does Git Ignore do?",
    "text": "Extension: What does Git Ignore do?"
  },
  {
    "objectID": "00_05_git.html#extension-pair-exercise",
    "href": "00_05_git.html#extension-pair-exercise",
    "title": "P04. Git and Github",
    "section": "Extension: Pair exercise",
    "text": "Extension: Pair exercise\n1. Invite your partner to your repository\n2. Modify the file in this repository and then save, commit and push it.\n3. Now the partner should check if they have the changes. No!\n4. They need to “Pull” changes from Github.com. Find the right button, and click it.\n5. Do the same, but for the other partner.\n6. Next, both edit the same file, commit the changes, and both push at the same time.\n7. What has happened?\nYou’ve got a merge conflict!\n8. Follow the instructions to choose the lines you want to keep in the file\n9. Then commit and merge! And push the commit.\n10. Check on github.com how this looks in the commit log.\n11. Both pull and check what the file looks like now.\nWell done!"
  },
  {
    "objectID": "00_01_1_IntroToR_solutions.html",
    "href": "00_01_1_IntroToR_solutions.html",
    "title": "P01. Introduction to R, part 1: solutions",
    "section": "",
    "text": "A. Create simple objects of different types in the workspace\n\nitem1 &lt;- 1\nitem2 &lt;- \"a\"\nitem3 &lt;- 3.78901\n\nB. Objects with more than 1 entry are called vectors\n\n# create some vectors using c() (short for concatenate)\n# all items of a vector must be the same class\n\nobject1 &lt;- c(\"a\", \"b\", \"c\")\nobject2 &lt;- 1:3\nobject3 &lt;- c(1.3, -4.5, 6.99)\n\n# you can create vectors using other named items or objects\nobject4 &lt;- c(item1, item2, item3)\n\n# take a look\nobject1\n\n[1] \"a\" \"b\" \"c\"\n\nobject2\n\n[1] 1 2 3\n\nobject3\n\n[1]  1.30 -4.50  6.99\n\nobject4\n\n[1] \"1\"       \"a\"       \"3.78901\"\n\n\nC. Look for your objects in the environment tab (upper right)\nD. What class of objects is each object?\nAnswer: 1. character, 2. integer, 3. numeric, 4. character\n\n# use class() to find this\nclass(object1)\n\n[1] \"character\"\n\nclass(object2)\n\n[1] \"integer\"\n\nclass(object3)\n\n[1] \"numeric\"\n\nclass(object4)\n\n[1] \"character\"\n\n\nIs object 4 the class you expected?\nAnswer: No, it has been converted (cast) to a character this is because it is a combination of different types.\nE. You can manipulate objects and make operations on them\n\nobject2 + 1\n\n[1] 2 3 4\n\nobject3*object3\n\n[1]  1.6900 20.2500 48.8601\n\nobject2/object3\n\n[1]  0.7692308 -0.4444444  0.4291845\n\n# object1 + object2\n\nwhat happened at each of these commands? is it what you expected?\nAnswer: here was an error for the last one, because characters cannot be added.\nF. You can view the history of commands that were run.\nCheck the history of commands in the history tab (upper right).\nG. Make some other objects\n\ndf1 &lt;- data.frame(ID=1:5,\nanimal=c(\"bear\", \"cat\", \"horse\", \"cat\", \"pig\"),\nweight=c(200, 5, 600, 8, 100))\nmat1 &lt;- matrix(data=1:50, nrow=10, ncol=5)\n\n# view these objects\ndf1\n\n  ID animal weight\n1  1   bear    200\n2  2    cat      5\n3  3  horse    600\n4  4    cat      8\n5  5    pig    100\n\nmat1\n\n      [,1] [,2] [,3] [,4] [,5]\n [1,]    1   11   21   31   41\n [2,]    2   12   22   32   42\n [3,]    3   13   23   33   43\n [4,]    4   14   24   34   44\n [5,]    5   15   25   35   45\n [6,]    6   16   26   36   46\n [7,]    7   17   27   37   47\n [8,]    8   18   28   38   48\n [9,]    9   19   29   39   49\n[10,]   10   20   30   40   50\n\n# View(df1)\n# View(mat1)\n\nIn R, what is the difference between a data.frame and a matrix? hint: google it.\nAnswer: Matrices can be only of 1 class, e.g. numeric, integer, etc. Data frames can be a mixture of classes by column, e.g. col1=numeric, col2=character. View will let you open seperate windows to view the dataframe and matrice in R.\nH. Calculate the mean weight of the animals in df1. (i.e. mean of column 3 of df1)\n\n# you can either refer to a column by name or by index\n# check what the names are\ncolnames(df1)\n\n[1] \"ID\"     \"animal\" \"weight\"\n\n# reference a column by name\ndf1$weight\n\n[1] 200   5 600   8 100\n\n# check how to use the function \"mean\"\n# ? allows you to view the help file of any inbuilt function\n# ?mean\n\n# calculate the mean\nmean(df1$weight)\n\n[1] 182.6\n\nmean(df1[, 3])\n\n[1] 182.6\n\n\nAnswer: 182.6. ?mean will open up the helpfile of the function mean in the Help window.\nI. does mat1 have column names at this point?\nAnswer: No. But we can assign them.\n\n# set column names for mat1\ncolnames(mat1) &lt;- c(\"A\", \"B\", \"C\", \"D\", \"E\")\nmat1\n\n       A  B  C  D  E\n [1,]  1 11 21 31 41\n [2,]  2 12 22 32 42\n [3,]  3 13 23 33 43\n [4,]  4 14 24 34 44\n [5,]  5 15 25 35 45\n [6,]  6 16 26 36 46\n [7,]  7 17 27 37 47\n [8,]  8 18 28 38 48\n [9,]  9 19 29 39 49\n[10,] 10 20 30 40 50\n\n\nJ. What is the value of the element row 5, column C in mat1? what is the value of row 8, column E?\n\n# inspect the element by referencing the row, then column, either by name or number\nmat1[5, \"C\"]\n\n C \n25 \n\nmat1[5, 3]\n\n C \n25 \n\nmat1[8, \"E\"]\n\n E \n48 \n\n\nAnswer: 25, 48\nK. Discard all of mat1 except the 1st and 4th column.\n\n# subset mat1 to keep only the 1st and 4th column by number or name\nmat1[ , c(1, 4)]\n\n       A  D\n [1,]  1 31\n [2,]  2 32\n [3,]  3 33\n [4,]  4 34\n [5,]  5 35\n [6,]  6 36\n [7,]  7 37\n [8,]  8 38\n [9,]  9 39\n[10,] 10 40\n\nmat1[ , c(\"A\", \"D\")]\n\n       A  D\n [1,]  1 31\n [2,]  2 32\n [3,]  3 33\n [4,]  4 34\n [5,]  5 35\n [6,]  6 36\n [7,]  7 37\n [8,]  8 38\n [9,]  9 39\n[10,] 10 40\n\n# Create a new object of the smaller matrix.\n# assign the subsetted version as a new object, mat2\nmat2 &lt;- mat1[ , c(\"A\", \"D\")]\nmat2 &lt;- mat1[ , c(1, 4)]"
  },
  {
    "objectID": "10_StochasticContinuous_solutions.html",
    "href": "10_StochasticContinuous_solutions.html",
    "title": "10. Stochastic continuous time models (solutions)",
    "section": "",
    "text": "library(ggplot2) ## for plotting\nlibrary(tidyverse) ## for manipulation of results\n\n## Function SIR_gillespie.\n## This takes three arguments:\n## - init_state: the initial state\n##   (a named vector containing the number in S, I and R)\n## - parms: the parameters\n##   (a named vector containing the rates beta and gamma)\n## - tf: the end time\nSIR_gillespie &lt;- function(init_state, parms, tf) {\n\n  time &lt;- 0 ## initialise time to 0\n\n  ## assign parameters to easy-access variables\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n\n  ## assign states to easy-access variables\n  S &lt;- init_state[\"S\"]\n  I &lt;- init_state[\"I\"]\n  R &lt;- init_state[\"R\"]\n  N &lt;- S + I + R\n\n  ## create results data frame\n  results_df &lt;- data.frame(time=0, t(init_state))\n\n  ## loop until end time is reached\n  while (time &lt; tf) {\n    ## update current rates\n    rates &lt;- c()\n    rates[\"infection\"] &lt;- beta * S * I / N\n    rates[\"recovery\"] &lt;- gamma * I\n\n    if (sum(rates) &gt; 0) { ## check if any event can happen\n      ## time of next event\n      time &lt;- time + rexp(n=1, rate=sum(rates))\n      ## check if next event is supposed to happen before end time\n      if (time &lt;= tf) {\n        ## generate cumulative sum of rates, to determine the type of the next\n        ## event\n        cumulative_rates &lt;- cumsum(rates)\n        ## determine type of next event\n        type &lt;- runif(n=1, min=0, max=sum(rates))\n        if (type &lt; cumulative_rates[\"infection\"]) {\n          ## infection\n          S &lt;- S - 1\n          I &lt;- I + 1\n        } else if (type &lt; cumulative_rates[\"recovery\"]){\n          ## recovery\n          I &lt;- I - 1\n          R &lt;- R + 1\n        }\n      } else { ## next event happens after end time\n        time &lt;- tf\n      }\n    } else { ## no event can happen - go straight to end time\n      time &lt;- tf\n    }\n    ## add new row to results data frame\n    results_df &lt;- rbind(results_df, c(time=time, S=S, I=I, R=R))\n  }\n  ## return results data frame\n  return(results_df)\n}\n\ninit.values &lt;- c(S=249, I=1, R=0) ## initial state\nparms &lt;- c(beta=1, gamma=0.5) ## parameter vector\ntmax &lt;- 20 ## end time\n\n## run Gillespie simulation\nr &lt;- SIR_gillespie(init_state=init.values, parms=parms, tf=tmax)\n\n## Plot the result\nggplot(r) +\n    geom_line(aes(time, I, colour = \"I\"))\n\n## Re-run this from the line `r &lt;- SIR_gillespie(...)` a few times to \n## convince yourself the output is different every time.\n\n## Run multiple simulation runs and plot a few of them\nnsim &lt;- 100 ## number of trial simulations\n\n## We store the simulations in a data frame, traj, which\n## contains the results from multiple simulation runs and an additional column\n## that represents the simulation index\ntraj &lt;- tibble(i=1:nsim) %&gt;%\n  rowwise() %&gt;%\n  mutate(trajectory=list(as.data.frame(\n           SIR_gillespie(init.values, parms, tmax)))) %&gt;%\n  unnest(trajectory)\n\n## convert to long data frame\nmlr &lt;- traj %&gt;%\n  gather(compartment, value, 3:ncol(.))\n\n## Next, plot the multiple simulation runs\nggplot(mlr,\n       aes(x=time, y=value, group=i, color=compartment)) +\n  geom_line() +\n  facet_wrap(~compartment)\n\n## Plot the distribution of overall outbreak sizes.\n\n## create data frame of outbreak sizes\noutbreak_sizes &lt;- mlr %&gt;%\n  filter(compartment==\"R\") %&gt;%\n  group_by(i) %&gt;%\n  filter(time==max(time)) %&gt;%\n  select(i, size=value)\n\n## plot it as a histogram\nggplot(outbreak_sizes, aes(x=size)) +\n  geom_histogram()\n\n## determine number of large outbreaks (defined as larger than 50)\noutbreak_sizes %&gt;%\n  filter(size &gt; 50) %&gt;%\n  nrow\n\n## Extract the values of the trajectory at integer time points\ntimeTraj &lt;- mlr %&gt;%\n  group_by(i, compartment) %&gt;%\n  summarise(traj=list(data.frame(\n              time=seq(0, tmax, by=0.1),\n              value=approx(x=time, y=value, xout=seq(0, tmax, by=0.1),\n                           method=\"constant\")$y))) %&gt;%\n  unnest(traj)\n\n## Calculate summary trajectory with mean & sd of infectious people over time\nsumTraj &lt;- timeTraj %&gt;%\n  filter(compartment==\"I\") %&gt;%\n  group_by(time) %&gt;%\n  summarise(mean=mean(value),\n            sd=sd(value))\n\n## plot\nggplot(sumTraj, aes(x=time, y=mean, ymin=pmax(0, mean-sd), ymax=mean+sd)) +\n  geom_line() +\n  geom_ribbon(alpha=0.3)\n\n## Only consider trajectories that have not gone extinct:\nsumTrajAll &lt;- sumTraj %&gt;%\n  mutate(trajectories=\"all\")\n\nsumTrajGr0 &lt;- timeTraj %&gt;%\n  filter(compartment==\"I\", value &gt; 0) %&gt;%\n  group_by(time) %&gt;%\n  summarise(mean=mean(value),\n            sd=sd(value)) %&gt;%\n  mutate(trajectories=\"greater_than_zero\")\n\niTraj &lt;- bind_rows(sumTrajAll, sumTrajGr0)\n\n## plot\nggplot(iTraj, aes(x=time, y=mean, ymin=pmax(0, mean-sd), ymax=mean+sd,\n                  colour=trajectories, fill=trajectories)) +\n  geom_line() +\n  geom_ribbon(alpha=0.3) +\n  scale_color_brewer(palette=\"Set1\")\n\n## We now compare the two averages to the deterministic trajectory\n\n## Model function (from ODE practical)\nlibrary(deSolve)\nSIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n  N &lt;- S + I + R\n                                        # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n                                        # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dI, dR ))\n  return(res)\n}\n\node_output_raw &lt;-\n  ode(y = init.values, times = seq(0, tmax), func = SIR_model, parms = parms,\n      method = \"rk4\")\n## Convert to data frame for easy extraction of columns\node_output &lt;- as.data.frame(ode_output_raw)\n\n## Combine into one big data frame\nallTraj &lt;- ode_output %&gt;%\n  gather(compartment, value, 2:ncol(.)) %&gt;% ## convert to long format\n  filter(compartment==\"I\") %&gt;%\n  rename(mean=value) %&gt;% ## in deterministic, mean=value\n  mutate(trajectories=\"deterministic\", ## label trajectories\n         sd=0) %&gt;% ## in deterministic, sd=0\n  bind_rows(iTraj)\n\n## plot\nggplot(allTraj, aes(x=time, y=mean, colour=trajectories)) +\n  geom_line() +\n  scale_color_brewer(palette=\"Set1\")"
  },
  {
    "objectID": "10_StochasticContinuous_solutions.html#practical-1.-stochastic-simulation-with-the-gillespie-algorithm",
    "href": "10_StochasticContinuous_solutions.html#practical-1.-stochastic-simulation-with-the-gillespie-algorithm",
    "title": "10. Stochastic continuous time models (solutions)",
    "section": "",
    "text": "library(ggplot2) ## for plotting\nlibrary(tidyverse) ## for manipulation of results\n\n## Function SIR_gillespie.\n## This takes three arguments:\n## - init_state: the initial state\n##   (a named vector containing the number in S, I and R)\n## - parms: the parameters\n##   (a named vector containing the rates beta and gamma)\n## - tf: the end time\nSIR_gillespie &lt;- function(init_state, parms, tf) {\n\n  time &lt;- 0 ## initialise time to 0\n\n  ## assign parameters to easy-access variables\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n\n  ## assign states to easy-access variables\n  S &lt;- init_state[\"S\"]\n  I &lt;- init_state[\"I\"]\n  R &lt;- init_state[\"R\"]\n  N &lt;- S + I + R\n\n  ## create results data frame\n  results_df &lt;- data.frame(time=0, t(init_state))\n\n  ## loop until end time is reached\n  while (time &lt; tf) {\n    ## update current rates\n    rates &lt;- c()\n    rates[\"infection\"] &lt;- beta * S * I / N\n    rates[\"recovery\"] &lt;- gamma * I\n\n    if (sum(rates) &gt; 0) { ## check if any event can happen\n      ## time of next event\n      time &lt;- time + rexp(n=1, rate=sum(rates))\n      ## check if next event is supposed to happen before end time\n      if (time &lt;= tf) {\n        ## generate cumulative sum of rates, to determine the type of the next\n        ## event\n        cumulative_rates &lt;- cumsum(rates)\n        ## determine type of next event\n        type &lt;- runif(n=1, min=0, max=sum(rates))\n        if (type &lt; cumulative_rates[\"infection\"]) {\n          ## infection\n          S &lt;- S - 1\n          I &lt;- I + 1\n        } else if (type &lt; cumulative_rates[\"recovery\"]){\n          ## recovery\n          I &lt;- I - 1\n          R &lt;- R + 1\n        }\n      } else { ## next event happens after end time\n        time &lt;- tf\n      }\n    } else { ## no event can happen - go straight to end time\n      time &lt;- tf\n    }\n    ## add new row to results data frame\n    results_df &lt;- rbind(results_df, c(time=time, S=S, I=I, R=R))\n  }\n  ## return results data frame\n  return(results_df)\n}\n\ninit.values &lt;- c(S=249, I=1, R=0) ## initial state\nparms &lt;- c(beta=1, gamma=0.5) ## parameter vector\ntmax &lt;- 20 ## end time\n\n## run Gillespie simulation\nr &lt;- SIR_gillespie(init_state=init.values, parms=parms, tf=tmax)\n\n## Plot the result\nggplot(r) +\n    geom_line(aes(time, I, colour = \"I\"))\n\n## Re-run this from the line `r &lt;- SIR_gillespie(...)` a few times to \n## convince yourself the output is different every time.\n\n## Run multiple simulation runs and plot a few of them\nnsim &lt;- 100 ## number of trial simulations\n\n## We store the simulations in a data frame, traj, which\n## contains the results from multiple simulation runs and an additional column\n## that represents the simulation index\ntraj &lt;- tibble(i=1:nsim) %&gt;%\n  rowwise() %&gt;%\n  mutate(trajectory=list(as.data.frame(\n           SIR_gillespie(init.values, parms, tmax)))) %&gt;%\n  unnest(trajectory)\n\n## convert to long data frame\nmlr &lt;- traj %&gt;%\n  gather(compartment, value, 3:ncol(.))\n\n## Next, plot the multiple simulation runs\nggplot(mlr,\n       aes(x=time, y=value, group=i, color=compartment)) +\n  geom_line() +\n  facet_wrap(~compartment)\n\n## Plot the distribution of overall outbreak sizes.\n\n## create data frame of outbreak sizes\noutbreak_sizes &lt;- mlr %&gt;%\n  filter(compartment==\"R\") %&gt;%\n  group_by(i) %&gt;%\n  filter(time==max(time)) %&gt;%\n  select(i, size=value)\n\n## plot it as a histogram\nggplot(outbreak_sizes, aes(x=size)) +\n  geom_histogram()\n\n## determine number of large outbreaks (defined as larger than 50)\noutbreak_sizes %&gt;%\n  filter(size &gt; 50) %&gt;%\n  nrow\n\n## Extract the values of the trajectory at integer time points\ntimeTraj &lt;- mlr %&gt;%\n  group_by(i, compartment) %&gt;%\n  summarise(traj=list(data.frame(\n              time=seq(0, tmax, by=0.1),\n              value=approx(x=time, y=value, xout=seq(0, tmax, by=0.1),\n                           method=\"constant\")$y))) %&gt;%\n  unnest(traj)\n\n## Calculate summary trajectory with mean & sd of infectious people over time\nsumTraj &lt;- timeTraj %&gt;%\n  filter(compartment==\"I\") %&gt;%\n  group_by(time) %&gt;%\n  summarise(mean=mean(value),\n            sd=sd(value))\n\n## plot\nggplot(sumTraj, aes(x=time, y=mean, ymin=pmax(0, mean-sd), ymax=mean+sd)) +\n  geom_line() +\n  geom_ribbon(alpha=0.3)\n\n## Only consider trajectories that have not gone extinct:\nsumTrajAll &lt;- sumTraj %&gt;%\n  mutate(trajectories=\"all\")\n\nsumTrajGr0 &lt;- timeTraj %&gt;%\n  filter(compartment==\"I\", value &gt; 0) %&gt;%\n  group_by(time) %&gt;%\n  summarise(mean=mean(value),\n            sd=sd(value)) %&gt;%\n  mutate(trajectories=\"greater_than_zero\")\n\niTraj &lt;- bind_rows(sumTrajAll, sumTrajGr0)\n\n## plot\nggplot(iTraj, aes(x=time, y=mean, ymin=pmax(0, mean-sd), ymax=mean+sd,\n                  colour=trajectories, fill=trajectories)) +\n  geom_line() +\n  geom_ribbon(alpha=0.3) +\n  scale_color_brewer(palette=\"Set1\")\n\n## We now compare the two averages to the deterministic trajectory\n\n## Model function (from ODE practical)\nlibrary(deSolve)\nSIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n  N &lt;- S + I + R\n                                        # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n                                        # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dI, dR ))\n  return(res)\n}\n\node_output_raw &lt;-\n  ode(y = init.values, times = seq(0, tmax), func = SIR_model, parms = parms,\n      method = \"rk4\")\n## Convert to data frame for easy extraction of columns\node_output &lt;- as.data.frame(ode_output_raw)\n\n## Combine into one big data frame\nallTraj &lt;- ode_output %&gt;%\n  gather(compartment, value, 2:ncol(.)) %&gt;% ## convert to long format\n  filter(compartment==\"I\") %&gt;%\n  rename(mean=value) %&gt;% ## in deterministic, mean=value\n  mutate(trajectories=\"deterministic\", ## label trajectories\n         sd=0) %&gt;% ## in deterministic, sd=0\n  bind_rows(iTraj)\n\n## plot\nggplot(allTraj, aes(x=time, y=mean, colour=trajectories)) +\n  geom_line() +\n  scale_color_brewer(palette=\"Set1\")"
  },
  {
    "objectID": "10_StochasticContinuous_solutions.html#practical-2.-the-adaptivetau-package",
    "href": "10_StochasticContinuous_solutions.html#practical-2.-the-adaptivetau-package",
    "title": "10. Stochastic continuous time models (solutions)",
    "section": "Practical 2. The adaptivetau package",
    "text": "Practical 2. The adaptivetau package\n\nlibrary(ggplot2) ## for plotting\nlibrary(adaptivetau) ## for stochastic simulations\nlibrary(tidyverse) ## for manipulation of results\n\n## Define transitions\ntransitions &lt;- list(\n  c(S = -1, I = +1),\n  c(I = -1, R = +1))\n\n## Specify rate function, giving rate for each transition\nSIRrateF &lt;- function(state, parms, time) {\n  beta &lt;- parms[[\"beta\"]]\n  gamma &lt;- parms[[\"gamma\"]]\n\n  S &lt;- state[[\"S\"]]\n  I &lt;- state[[\"I\"]]\n  R &lt;- state[[\"R\"]]\n\n  N &lt;- S + I + R\n\n  rates &lt;- c(beta * S * I/N,\n             gamma * I)\n\n  return(rates)\n}\n\n## Initial values\ninit.values &lt;- c(S = 249, ## number of susceptibles\n                 I = 10, ## number infectious\n                 R = 0) ## number immune\n\n## Parameters\nparms &lt;- c(beta = 2, ## infection rate\n           gamma = 1) ## recovery rate\n\n## Run a trial simulation for 60 time steps\ntmax &lt;- 60 ## number of time steps to simulate\n\nr &lt;- ssa.adaptivetau(init.values, transitions, SIRrateF, parms, tf = tmax)\n\n## Plot results\nr_df &lt;- as.data.frame(r)\nplot(r_df$time, r_df$I, type = \"l\")\n\n## Run the simulation multiple times\nnsim &lt;- 100 ## number of trial simulations\n\nsystem.time(traj &lt;- tibble(i=1:nsim) %&gt;%\n  rowwise() %&gt;%\n  mutate(trajectory=list(as.data.frame(\n           ssa.adaptivetau(init.values, transitions, SIRrateF, parms, tf=tmax)))) %&gt;%\n  unnest(trajectory))\n\n## Plot the resulting trajectories\nggplot(traj) +\n    geom_line(aes(x = time, y = I, group = i, colour = i))\n\nReturn to the practical here."
  },
  {
    "objectID": "08_StochasticIBM_code3.html",
    "href": "08_StochasticIBM_code3.html",
    "title": "08. Stochastic individual-based models (practical 3)",
    "section": "",
    "text": "For practical 3, start with the following code:\n\n# Individual-based SARS-CoV-2 transmission model, practical 3\nlibrary(ggplot2)\n\n\n## Model parameters\nbeta &lt;- 0.5        # Transmission parameter\niota &lt;- 1e-5       # Importation rate\nwane &lt;- 0.05       # Rate of antibody waning\n\ndt &lt;- 1            # Time step of simulation (1 day)\ndays &lt;- 365 * 4    # Duration of simulation (4 years)\nsteps &lt;- days / dt # Total number of time steps\nn &lt;- 5000          # Population size\n\n\n## Some helper functions\n# Calculates infectiousness as a function of state and age: zero if state is\n# not \"I\"; nonzero if state is \"I\", and slightly decreasing with age\ninfectiousness &lt;- function(state, age) {\n    ifelse(state == \"I\", 1.25 - age / 160, 0)\n}\n\n# Calculates susceptibility of individuals with antibody level(s) ab\nsusceptibility &lt;- function(ab) {\n    pnorm(ab, 5, 1)\n}\n\n# Generates n random delays from the latent-period distribution\n# (approximately 2 days, on average)\nlatent_delay &lt;- function(n) {\n    rlnorm(n, meanlog = 0.5, sdlog = 0.6)\n}\n\n# Generates n random delays from the infectious-period distribution\n# (approximately 5 days, on average)\ninfectious_delay &lt;- function(n) {\n    rlnorm(n, meanlog = 1.5, sdlog = 0.5)\n}\n\n# Generates n random increments to antibody levels following recovery\nab_increment &lt;- function(n) {\n    rnorm(n, mean = 12, sd = 2)\n}\n\n\n## Data frame to store simulation results\nresults &lt;- data.frame(ts = 1:steps, S = 0, E = 0, I = 0, AMeanU = 0, AMeanV = 0)\n\n\n## Initialize simulation\n\n# Set the seed for the pseudorandom number generator, for reproducibility\nset.seed(12345)\n\n# Initialize state variables\nstate &lt;- rep(\"S\", n)   # Each individual's state: start with all susceptible\nage &lt;- runif(n, 0, 80) # Each individual's age: random distribution from 0 to 80\ndelay &lt;- rep(0, n)     # Delay for latent and infectious periods\nantib &lt;- rep(0, n)     # Antibody concentration for each individual\nvacc &lt;- rep(FALSE, n)  # Vaccinated status\n\nstate[1:10] &lt;- \"E\"     # Start 10 individuals in the \"exposed\" state\n\n\n## Run simulation\n\n# Initialize progress bar\nbar &lt;- txtProgressBar(min = 1, max = steps, style = 3)\n\n# Loop over each time step . . .\nfor (ts in 1:steps) {\n    # Calculate the force of infection\n    lambda &lt;- beta * sum(infectiousness(state, age)) / n + iota\n\n    ##### NOTE - There is no inner loop over individuals anymore!\n\n    # Update non-state variables (for all individuals simultaneously)\n    # Time remaining in latent/infectious periods\n    delay &lt;- delay - dt\n    ##### Fill in: Antibody waning\n    antib &lt;- ...\n    ##### Fill in: Vaccination at time step 300 for over-40s\n    if (ts == 300) {\n        vacc[...] &lt;- ...\n        antib[...] &lt;- ...\n    }\n\n    # Update state variables (for all individuals simultaneously)\n    ##### trE selects all individuals who will transition states from S to E.\n    trE &lt;- (state == \"S\") & (runif(n) &lt; 1 - exp(-lambda * dt)) &\n      (runif(n) &gt; susceptibility(antib))\n    trI &lt;- ... ##### Fill in similar conditions for trI (E-&gt;I) and trS (I-&gt;S).\n    trS &lt;- ...\n\n    # Fill in: Do state transitions\n    # transition S -&gt; E\n    state[trE] &lt;- \"E\"\n    delay[trE] &lt;- latent_delay(sum(trE))\n\n    # transition E -&gt; I\n    ...\n\n    # transition I -&gt; S\n    ...\n\n    # Save population state for this time step\n    results[ts, \"S\"] &lt;- sum(state == \"S\")\n    results[ts, \"E\"] &lt;- sum(state == \"E\")\n    results[ts, \"I\"] &lt;- sum(state == \"I\")\n    results[ts, \"AMeanU\"] &lt;- mean(antib[!vacc])\n    results[ts, \"AMeanV\"] &lt;- mean(antib[vacc])\n\n    # Update progress bar; close progress bar if we are finished\n    setTxtProgressBar(bar, ts)\n    if (ts == steps) {\n        close(bar)\n    }\n}\n\n## Plot simulation results\nggplot(results) +\n    geom_line(aes(x = ts, y = S, colour = \"S\")) +\n    geom_line(aes(x = ts, y = E, colour = \"E\")) +\n    geom_line(aes(x = ts, y = I, colour = \"I\"))\n\nggplot(results) +\n    geom_line(aes(x = ts, y = AMeanU, colour = \"Unvaccinated\")) +\n    geom_line(aes(x = ts, y = AMeanV, colour = \"Vaccinated\")) +\n    labs(x = \"Time step\", y = \"Mean antibody level\")\n\nReturn to the practical here."
  },
  {
    "objectID": "08_StochasticIBM_code3.html#practical-3.-optimizing-the-model-to-run-faster",
    "href": "08_StochasticIBM_code3.html#practical-3.-optimizing-the-model-to-run-faster",
    "title": "08. Stochastic individual-based models (practical 3)",
    "section": "",
    "text": "For practical 3, start with the following code:\n\n# Individual-based SARS-CoV-2 transmission model, practical 3\nlibrary(ggplot2)\n\n\n## Model parameters\nbeta &lt;- 0.5        # Transmission parameter\niota &lt;- 1e-5       # Importation rate\nwane &lt;- 0.05       # Rate of antibody waning\n\ndt &lt;- 1            # Time step of simulation (1 day)\ndays &lt;- 365 * 4    # Duration of simulation (4 years)\nsteps &lt;- days / dt # Total number of time steps\nn &lt;- 5000          # Population size\n\n\n## Some helper functions\n# Calculates infectiousness as a function of state and age: zero if state is\n# not \"I\"; nonzero if state is \"I\", and slightly decreasing with age\ninfectiousness &lt;- function(state, age) {\n    ifelse(state == \"I\", 1.25 - age / 160, 0)\n}\n\n# Calculates susceptibility of individuals with antibody level(s) ab\nsusceptibility &lt;- function(ab) {\n    pnorm(ab, 5, 1)\n}\n\n# Generates n random delays from the latent-period distribution\n# (approximately 2 days, on average)\nlatent_delay &lt;- function(n) {\n    rlnorm(n, meanlog = 0.5, sdlog = 0.6)\n}\n\n# Generates n random delays from the infectious-period distribution\n# (approximately 5 days, on average)\ninfectious_delay &lt;- function(n) {\n    rlnorm(n, meanlog = 1.5, sdlog = 0.5)\n}\n\n# Generates n random increments to antibody levels following recovery\nab_increment &lt;- function(n) {\n    rnorm(n, mean = 12, sd = 2)\n}\n\n\n## Data frame to store simulation results\nresults &lt;- data.frame(ts = 1:steps, S = 0, E = 0, I = 0, AMeanU = 0, AMeanV = 0)\n\n\n## Initialize simulation\n\n# Set the seed for the pseudorandom number generator, for reproducibility\nset.seed(12345)\n\n# Initialize state variables\nstate &lt;- rep(\"S\", n)   # Each individual's state: start with all susceptible\nage &lt;- runif(n, 0, 80) # Each individual's age: random distribution from 0 to 80\ndelay &lt;- rep(0, n)     # Delay for latent and infectious periods\nantib &lt;- rep(0, n)     # Antibody concentration for each individual\nvacc &lt;- rep(FALSE, n)  # Vaccinated status\n\nstate[1:10] &lt;- \"E\"     # Start 10 individuals in the \"exposed\" state\n\n\n## Run simulation\n\n# Initialize progress bar\nbar &lt;- txtProgressBar(min = 1, max = steps, style = 3)\n\n# Loop over each time step . . .\nfor (ts in 1:steps) {\n    # Calculate the force of infection\n    lambda &lt;- beta * sum(infectiousness(state, age)) / n + iota\n\n    ##### NOTE - There is no inner loop over individuals anymore!\n\n    # Update non-state variables (for all individuals simultaneously)\n    # Time remaining in latent/infectious periods\n    delay &lt;- delay - dt\n    ##### Fill in: Antibody waning\n    antib &lt;- ...\n    ##### Fill in: Vaccination at time step 300 for over-40s\n    if (ts == 300) {\n        vacc[...] &lt;- ...\n        antib[...] &lt;- ...\n    }\n\n    # Update state variables (for all individuals simultaneously)\n    ##### trE selects all individuals who will transition states from S to E.\n    trE &lt;- (state == \"S\") & (runif(n) &lt; 1 - exp(-lambda * dt)) &\n      (runif(n) &gt; susceptibility(antib))\n    trI &lt;- ... ##### Fill in similar conditions for trI (E-&gt;I) and trS (I-&gt;S).\n    trS &lt;- ...\n\n    # Fill in: Do state transitions\n    # transition S -&gt; E\n    state[trE] &lt;- \"E\"\n    delay[trE] &lt;- latent_delay(sum(trE))\n\n    # transition E -&gt; I\n    ...\n\n    # transition I -&gt; S\n    ...\n\n    # Save population state for this time step\n    results[ts, \"S\"] &lt;- sum(state == \"S\")\n    results[ts, \"E\"] &lt;- sum(state == \"E\")\n    results[ts, \"I\"] &lt;- sum(state == \"I\")\n    results[ts, \"AMeanU\"] &lt;- mean(antib[!vacc])\n    results[ts, \"AMeanV\"] &lt;- mean(antib[vacc])\n\n    # Update progress bar; close progress bar if we are finished\n    setTxtProgressBar(bar, ts)\n    if (ts == steps) {\n        close(bar)\n    }\n}\n\n## Plot simulation results\nggplot(results) +\n    geom_line(aes(x = ts, y = S, colour = \"S\")) +\n    geom_line(aes(x = ts, y = E, colour = \"E\")) +\n    geom_line(aes(x = ts, y = I, colour = \"I\"))\n\nggplot(results) +\n    geom_line(aes(x = ts, y = AMeanU, colour = \"Unvaccinated\")) +\n    geom_line(aes(x = ts, y = AMeanV, colour = \"Vaccinated\")) +\n    labs(x = \"Time step\", y = \"Mean antibody level\")\n\nReturn to the practical here."
  },
  {
    "objectID": "00_02_programming_practical.html",
    "href": "00_02_programming_practical.html",
    "title": "P02. Programming Skills",
    "section": "",
    "text": "In this practical we will gain some experience using"
  },
  {
    "objectID": "00_02_programming_practical.html#control-statements",
    "href": "00_02_programming_practical.html#control-statements",
    "title": "P02. Programming Skills",
    "section": "(1) Control Statements",
    "text": "(1) Control Statements\nThere are often multiple ways in R to calculate what you want - what you choose will be down to personal preference but there will be some guiding principles:\n\nhow fast is the code?\nhow easy is it to read - can other people understand what you’ve done and can you debug it easily?\n\nHere we’ll do the same tasks using three different ways to demonstrate the logics behind these guiding principles. The task involves calculating the R0 for a range of infectiousness durations and transmission rates (i.e. beta) and calculate the probability of an epidemic.\nFirst, let’s install and load our packages we will need\n\ninstall.packages(\"tictoc\")\ninstall.packages(\"purrr\")\n\nlibrary(tictoc)\nlibrary(purrr)\n\nNotice that at the start and end of “ways” we implement below, we have tic() and toc() - these are commands to tell R to, respectively, start and stop a timer and output how long each code chunk took. Therefore, to compare the time taken to run each script, you will need to select everything from tic() to toc() and press Cmd-Enter\nQuestion (a) Why do you initialise variables at the start of the script?\nAnswer:\n\nThe first way - using loops\n\ntic(\"loop\") # start a timer called 'loop' to see how quickly it runs\n\n# intitialise variables\ninfectiousness.duration &lt;- 1:10\nbeta &lt;- seq(0.1, 0.5, by = 0.1)\nepidemic &lt;- matrix(NA,nrow=length(infectiousness.duration), ncol=length(beta))\n\n# set our loop over infectious duration and transmission rate (beta)\n\nfor (index_i in 1:length(infectiousness.duration)){\n  for (index_j in 1:length(beta)){\n    \n    #calculate R0 for each combination\n    R0 &lt;- beta[index_j] * infectiousness.duration[index_i]\n    \n    # evaluate whethere there is an epidemic - R0&gt;=1 \n    if (R0 &gt;= 1){\n      epidemic[index_i, index_j] &lt;- 1\n    } else{\n      epidemic[index_i, index_j] &lt;- 0  \n    }\n    \n  }\n}\n# calculate the proportion of the values that leads to an epidemic\nmean(epidemic)\n\n[1] 0.62\n\ntoc() # output the time that the script took\n\nloop: 0.011 sec elapsed\n\n\nInstead of accessing each element of a matrix via for loops, R can also apply operations to matrices or dataframe as chunks. This can speed up the code, reduce the amount of code, and can make it easier to read.\n\n\nThe second way - vectorisation\nhere is an example of using “expand.grid” to enumerate all the combinations of the two parameters\n\ntic(\"vectorised\") # start a timer called 'vectorised' to see how quickly it runs\ninfectiousness.duration &lt;- 1:10\nbeta &lt;- seq(0.1, 0.5, by = 0.1)\nepidemic &lt;- expand.grid(beta.val = beta, id.val = infectiousness.duration)\n# the '*' operator can then be used on the columns of the data.frame to create another column called 'R0'\nepidemic[, \"R0\"] &lt;- epidemic$beta.val * epidemic$id.val\n# we can also check the proportion of the combinations that give rise to epidemics\nmean(epidemic$R0 &gt;= 1)\n\n[1] 0.62\n\ntoc()\n\nvectorised: 0.006 sec elapsed\n\n\n\n\nThe third way - “mapping”\nLet’s calculate the same thing finally using the map function in the package purrr\n\ntic(\"map\") # start a timer called 'vectorised' to see how quickly it runs\ninfectiousness.duration &lt;- 1:10\nbeta &lt;- seq(0.1, 0.5, by = 0.1)\nparametervals &lt;- expand.grid(beta.val = beta, id.val = infectiousness.duration)\nepidemic &lt;- unlist(purrr::map2(.x = parametervals[,\"id.val\"],\n                               .y = parametervals[,\"beta.val\"],\n                               .f = ~(.x * .y)))\nmean(epidemic &gt;= 1)\n\n[1] 0.62\n\ntoc()\n\nmap: 0.007 sec elapsed\n\n\nHow did each of the three scripts do according to our 2 criteria?\n\nhow fast is the code?\nhow easy is it to read - can other people understand what you’ve done and can you debug it easily?\n\nWhich would you choose and why?"
  },
  {
    "objectID": "00_02_programming_practical.html#functions",
    "href": "00_02_programming_practical.html#functions",
    "title": "P02. Programming Skills",
    "section": "(2) Functions",
    "text": "(2) Functions\nFor a simple “SIR” model, we can calculate the fraction of a population at the end of an epidemic that remain susceptible. We can calculate this via what is termed the ‘final size’ equation and this is written as:\n\\[\nln(S_{inf}) = R0*(S_{inf} - 1)\n\\]\nThat is,the natural log of the proportion susceptible at the end of the epidemic is equal to R0 multiplied by 1 minus the proportion susceptible at the end of the epidemic. How do we find the solution i.e. What is \\(S_{inf}\\) for each value of R0? Let’s turn this expression into our own R function so we can solve it.\n\nfinal.size.root &lt;- function(s.inf) {\n  final.size &lt;- R0*(s.inf - 1) - log(s.inf)\n  return(final.size)\n}\n\nWe have set the final.size.root such that whenever it evaluates 0, we have found a solution. R has some in built functions to help you solve this equation. Let’s use uniroot to find a solution. We want an answer bigger or equal to 0 and less than 1. First have a look what uniroot does, by running\n\n?uniroot\n\nTake a look at the ‘Value’ that uniroot provides: ‘A list with at least four components’. To display the value of the root, we need to tell R to use the output called `root` of the function. We can do this by using the ‘$’ notation below:\n\nsol.root &lt;- uniroot(final.size.root, c(0,0.9999))$root\nprint(sol.root)\n\n[1] 0.007005744\n\n\nQuestion (b) Did you expect R to give you an answer?\nAnswer:\nQuestion (c) What variables did it use to evaluate the function?\nAnswer:\nWe have to make sure that we either\n\ndefine all the variables that a function needs within the function itself or\npass these variables as arguments. Let’s try both ways.\n\nFirst, rewrite the function so that R0 is defined within the function:\n\nfinal.size.root &lt;- function(s.inf) {\n  R0 &lt;- 2\n  final.size &lt;- R0*(s.inf - 1) - log(s.inf)\n  return(final.size)\n}\n\nThis looks like it could be a useful function, perhaps we don’t want to have to ‘hard code’ R. Let’s try it a second way so that R0 is passed as an argument to the function. Start by defining a function that takes both R0 and s.inf as arguments:\n\nfinal.size.root.twoargs &lt;- function(R0, s.inf){\n  final.size &lt;- R0*(s.inf - 1) - log(s.inf)\n  return(final.size)\n}\n\nQuestion (d) What are the arguments of this new function?\nAnswer:\nQuestion (e) What is the output of this new function?\nAnswer:\nNow let’s pick a number for R0 that we can easily change, let’s call it rep.num\n\nrep.num &lt;- 2\n\nQuestion (f) Why have we called this rep.num and not R0?\nAnswer:\nUniroot takes only one argument so we need to wrap our function inside another function that only has one argument. This is how we do it:\n\nsol.root &lt;- uniroot(function(s.inf){\n  return(final.size.root.twoargs(rep.num, s.inf))\n}, \nc(0,0.9999))$root\n\nNotice that we have used the keyword ‘function’ without assigning the function a name (e.g. like we did with final.size). This type of function is called an ‘anonymous function’ and they are used when you can write a simple function on one line that you do not need to keep using. The output value of the function is the output value of the two args function.\nQuestion (g) What are all the functions that we have used to calculate the root of the equation and how many arguments do they have?\nAnswer:\nuniroot only gives us one root (unsurprisingly). rootSolve is a package that has functions to solve for multiple roots. You can install this package by:\n\nTools &gt; InstallPackage &gt; &lt;type rootSolve&gt;\ntype install.packages(\"rootSolve\") in R\n\nNow, simply load the package so your work environment has access to all its functions\n\nlibrary(\"rootSolve\")\n\nWe will now use the rootSolve function uniroot.all to find all the solutions of the final size equation. Let’s use the same syntax as we did before, remembering to define rep.num again\n\nrep.num &lt;- 2\nsol.all.roots &lt;- uniroot.all(function(s.inf){\n  return(final.size.root.twoargs(rep.num, s.inf))\n},\nc(0,1))\nprint(sol.all.roots)\n\n[1] 1.0000000 0.2032782\n\n\nQuestion (h) What is the epidemiological interpretation of these two roots?\nAnswer:\nFinally, let’s see how our R0 changes our solution values. We can do this with a loop as above\n\nr0.vector &lt;- 1:10\nsol.all.roots &lt;- vector(length = length(r0.vector))\nfor (r0 in r0.vector){\n  sol.all.roots[r0] &lt;- min(uniroot.all(function(s.inf) final.size.root.twoargs(r0, s.inf), c(0,1)))\n}\n\npar(new=FALSE)\nplot(r0.vector, sol.all.roots, type= \"b\", xlim=c(1,10), ylim=c(0,1), ylab = \"Proportion of population uninfected\", xlab = \"R0\")\n\n\n\n\n\n\n\n\nCan you rewrite the for loop calculation above in a different way?\nHint: use the purrr::map function - but note that previously we had 2 variables and used map2 . Now we only have one variable, so we will use purrr::map\n\nsol.all.roots &lt;- YOUR CODE HERE\n\nSolutions can be accessed here."
  },
  {
    "objectID": "09_Networks_practical.html",
    "href": "09_Networks_practical.html",
    "title": "09. Networks",
    "section": "",
    "text": "In this practical, we will implement a network model of mpox transmission."
  },
  {
    "objectID": "09_Networks_practical.html#practical-1.-introduction-to-the-igraph-package",
    "href": "09_Networks_practical.html#practical-1.-introduction-to-the-igraph-package",
    "title": "09. Networks",
    "section": "Practical 1. Introduction to the igraph package",
    "text": "Practical 1. Introduction to the igraph package\nThe R package igraph allows you to create, manipulate, and plot graphs. This first practical will show you the basics of igraph and will demonstrate how we might use graphs to represent infectious disease transmission.\n\nBuilding and plotting graphs\nigraph has a number of functions that are designed to create graphs according to certain rules or designs. One of the simplest graphs, conceptually, is the “complete” or “full” graph, in which each vertex is connected to every other vertex. This is made using the igraph function make_full_graph(n), where n is the number of nodes or vertices.\nLet’s make a complete graph with 4 nodes. Run the following code:\n\nlibrary(igraph) # For network functionality\nlibrary(data.table)\nlibrary(ggplot2)\n\n# Complete graph with 4 nodes\ngr &lt;- make_full_graph(4)\nprint(gr)\n\nIGRAPH a041113 U--- 4 6 -- Full graph\n+ attr: name (g/c), loops (g/l)\n+ edges from a041113:\n[1] 1--2 1--3 1--4 2--3 2--4 3--4\n\n\nTake a look at the output of print(gr).\nThe most important parts here are probably “4 6” at the top (this means the graph has 4 vertices and 6 edges) and the list of edges at the bottom, showing which nodes are connected to which other nodes.\nThis information is easier to take in if we plot the graph. Run the following:\n\nplot(gr)\n\n\nRun the plot(gr) line multiple times. The plot changes. Does the graph change?\n\nigraph has lots of different functions for making different kinds of graphs. make_full_graph is one that we’ve already seen, but there are several others.\nHere are some examples, all of which create graphs with a different number of nodes. Try plotting each of them and think about the implications of each network for infectious disease transmission, if each node represents a person and each edge means that the two people connected by the edge can potentially infect each other.\n\nmake_full_graph(16)\nmake_ring(16)\nmake_ring(16, circular = FALSE)\nmake_lattice(c(4, 4))\n\nRemember, to read more about a specific function, you can look up the help on that function, e.g.\n\n?make_lattice\n\nAny igraph function that starts with make_ is deterministic, i.e. gives you the same graph every time you run it. There are also igraph functions that give you random graphs, i.e. the function uses some random model to build a new graph each time. These functions start with sample_.\nOne of the simplest random graphs is called a Bernoulli random graph, or an Erdős-Rényi \\(G(n,p)\\) graph. This just means that there are n nodes in the graph, and every possible pair of nodes is connected with probability p. This graph is created using the function sample_gnp(n, p).\nLet’s start by looking again at our complete graph with 16 vertices:\n\nplot(make_full_graph(16), layout = layout_in_circle)\n\n\n\n\n\n\n\n\nAbove, layout = layout_in_circle puts all the nodes evenly around a circle, so that the position of the nodes is the same each time the graph is plotted. This will make the next graph easier to compare.\nNow, let’s make a \\(G(n,p)\\) graph with \\(p = 0.2\\) and plot that.\n\nplot(sample_gnp(16, 0.2), layout = layout_in_circle)\n\n\n\n\n\n\n\n\nCompare it to the previous plot, and run these two lines multiple times to see what happens.\nTry changing the number of nodes and the connection probability and see what happens. If you set \\(p\\) to a lower value, like 0.1, you are more likely to see individual nodes with no connections to other nodes, or several separated parts of the overall graph - try it.\nThere are lots of other well-known models for generating random graphs. Some of the most famous are the “small-world” model by Watts and Strogatz, where there are initially connections between neighbours, some of which are randomly rewired:\n\nplot(sample_smallworld(1, 16, 2, 0.1), layout = layout_in_circle)\n\nOr the “preferential attachment” model by Barabási and Albert, which is built by adding nodes one at a time, and each time a node is added, it is connected to other nodes, where the connection is more likely to be made to a node that already has more connections (a “rich get richer” dynamic).\n\nplot(sample_pa(16, directed = FALSE))\n\nOne reason these two models are so well known is that they were both introduced in high-impact papers claiming that the underlying models were widely applicable to a variety of real-world networks. Worth reading if you are interested:\nWatts DJ, Strogatz SH (1998) Collective dynamics of ‘small world’ networks. Nature 393, 440-442. https://snap.stanford.edu/class/cs224w-readings/watts98smallworld.pdf\nBarabási AL, Albert R (1999) Emergence of scaling in random networks. Science 286, 509–512. https://barabasi.com/f/67.pdf\n\n\nGetting and setting properties of the graph\nLet’s start by making a new ‘lattice’ graph:\n\nnetwork &lt;- make_lattice(c(5, 5)) \nprint(network) \nplot(network)\n\nSome simple calculations: vcount() or ecount() give the number of vertices or edges in the graph; degree() gives the number of neighbours of each vertex. Try running each of these.\n\nvcount(network) \necount(network) \ndegree(network)\n\nWith igraph, you can get and set attributes of the entire graph using the $ operator. For example, let’s set the graph’s layout to a grid:\n\nnetwork$layout &lt;- layout_on_grid(network)\nprint(network)\nplot(network)\n\nNotice that this has done two things. First, it added the attribute layout (g/n) to the graph and this is now shown as being present when you run print(network). Second, it has permanently fixed the layout of the graph so that it always plots the same way.\nYou can also modify properties of the vertices and of the edges, using V() and E() respectively. Let’s change the color of the vertices and edges:\n\nV(network)$color &lt;- \"azure\"\nE(network)$color &lt;- \"pink\" \nplot(network) # lovely\n\nYou can use V(network)[[]] or E(network)[[]] to see the properties of the vertices/edges laid out as a data frame. Try it:\n\nV(network)[[]]\nE(network)[[]]\n\nNotice that both have a “color” attribute now. This also appears in the list of attributes when we print the network:\n\nprint(network)\n\nIGRAPH 7cc1e3a U--- 25 40 -- Lattice graph\n+ attr: name (g/c), dimvector (g/n), nei (g/n), mutual (g/l), circular\n| (g/l), layout (g/n), color (v/c), color (e/c)\n+ edges from 7cc1e3a:\n [1]  1-- 2  1-- 6  2-- 3  2-- 7  3-- 4  3-- 8  4-- 5  4-- 9  5--10  6-- 7\n[11]  6--11  7-- 8  7--12  8-- 9  8--13  9--10  9--14 10--15 11--12 11--16\n[21] 12--13 12--17 13--14 13--18 14--15 14--19 15--20 16--17 16--21 17--18\n[31] 17--22 18--19 18--23 19--20 19--24 20--25 21--22 22--23 23--24 24--25\n\n\nAmong the attributes here, you can now see layout (g/n), color (v/c), and color (e/c). Here, the ‘g’ in (g/n) means the property is attached to the entire graph, while the ‘v’ and ‘e’ means the respective properties are attached to vertices and edges respectively. See ?print.igraph for more explanation of the codes.\nFinally, we can also use brackets [] to change properties of only certain vertices/edges. Here are some examples:\n\nV(network)[12]$color &lt;- \"orange\"\nplot(network)\n\n\nV(network)[color == \"orange\"]$color &lt;- \"pink\" \nplot(network)\n\n\nWhat do the above lines do?\n\nThe .nei() function, when used inside V(some_network)[ ], selects all neighbours of the specified vertices. This is very useful for transmission models on networks, because it is the neighbours of infected vertices that are at risk of getting exposed to the pathogen. Try running the code below and see what it does.\n\n# Pink is contagious:\nV(network)[.nei(color == \"pink\")]$color &lt;- \"pink\"\nplot(network)\n\n\nWhat is the code above doing? What happens if you re-run the two lines above several times?\n\nSome other interesting attributes for vertices include:\n\nlabel text label for the vertices (set to NA for no labels)\nsize size of the markers when plotted\n\n\nV(network)$label &lt;- NA\nV(network)$shape &lt;- \"square\"\nplot(network)\n\n\n\n\n\n\n\n\nSee ?igraph.plotting for more!\n\n\nBonus: Code a network model\nIf you have gotten this far and still have time before the session is up, see if you can use what you have learned above to code an SIR model on a network.\nSuggestion: If you want to plot the network at each time step to watch it “animate”, you can use Sys.sleep(1.0) to pause for a second between snapshots of the network so that the plots don’t all appear at once."
  },
  {
    "objectID": "09_Networks_practical.html#practical-2.-a-network-model-of-mpox-transmission",
    "href": "09_Networks_practical.html#practical-2.-a-network-model-of-mpox-transmission",
    "title": "09. Networks",
    "section": "Practical 2. A network model of mpox transmission",
    "text": "Practical 2. A network model of mpox transmission\nFor this practical, we’ll be using igraph and the techniques described above to build a simplified model of MPV (monkeypox virus) transmission in a network of sexual contacts among men who have sex with men (MSM).\n\nSetting up the network\nWe’ll build up our model by building several “helper” functions that break down our modelling task for us. We start by creating a function that builds a network by preferential attachment (see the citation to Barabási and Albert 1999 above).\nIn preferential attachment, the graph starts with one node, and then new nodes are added to the network one at a time. Every time a new node is added, it is connected to one randomly-selected node of the existing network, where the node to attach to is selected with probability proportional to the number of connections it already has. In other words, the new node attaches to existing node \\(i\\) with probability proportional to \\(\\mathrm{deg}(i)\\), where \\(\\mathrm{deg}(i)\\) is the degree of node \\(i\\). This tends to build up connections at nodes that are already well connected, meaning that in the resulting network, a small number of nodes have many connections while most nodes have only a few. Sexual networks tend to exhibit this property, which is why we’re using preferential attachment for our model.\nThere are variations to the preferential attachment model – for example, some variants add \\(m\\) connections to existing nodes instead of 1 each time a node is added, and some variants make the probability of attaching to node \\(i\\) proportional to \\(\\mathrm{deg}(i)^d\\), with \\(d\\) some constant.\nLet’s begin by making a function create_network() that uses the sample_pa() function of igraph to create a new network; then set a property “state” for each node to “S” for susceptible; and then give 5 random individuals the state “I” for infectious.\n\nlibrary(igraph)\nlibrary(data.table)\n\n# Set up a transmission network of n nodes by preferential attachment with \n# affinity proportional to degree^m.\ncreate_network &lt;- function(n, d, layout = layout_nicely)\n{\n    # Create the network by preferential attachment, passing on the parameters \n    # n and power\n    network &lt;- sample_pa(n, d, directed = FALSE)\n\n    # Add the \"state\" attribute to the vertices of the network, which can be\n    # \"S\", \"I\", \"R\", or \"V\". \n    # Start out everyone as susceptible ...\n    V(network)$state &lt;- \"S\"\n    # ... except make 5 random individuals infectious.\n    V(network)$state[sample(vcount(network), 5, prob = degree(network))] &lt;- \"I\"\n\n    # Reorder vertices so they go in order from least to most connected. This\n    # is to help with degree-targeted vaccination, and also to make the \n    # most connected vertices plot on top so they don't get hidden. \n    network &lt;- permute(network, rank(degree(network), ties.method = \"first\"))\n    # Set the network layout so it doesn't change every time it's plotted.\n    network$layout &lt;- layout(network)\n    \n    return (network)\n}\n\nNow, let’s try using the function and looking at the results.\n\nnet &lt;- create_network(n = 40, d = 1)\nplot(net)\n\n\n\n\n\n\n\n\n\nTry varying the d parameter for create_network between 0 and 2. What changes about the network?\n\nThe above plot looks a little cluttered, so we’ll create a function plot_degree that tidies up the plot a little so that we can focus on the important features, and colours the nodes according to how well connected they are.\n\n# Plot a network, highlighting the degree of each node by different colours.\nplot_degree &lt;- function(network)\n{\n    # Set up palette\n    colors &lt;- hcl.colors(5, \"Zissou 1\")\n    \n    # Classify nodes by degree\n    deg &lt;- cut(degree(network), \n        breaks = c(1, 2, 5, 10, 20, Inf),\n        labels = c(\"1\", \"2-4\", \"5-9\", \"10-19\", \"20+\"),\n        include.lowest = TRUE, right = FALSE)\n\n    # Plot network\n    plot(network, \n        vertex.color = colors[deg],\n        vertex.label = NA,\n        vertex.size = 4)\n    legend(\"topright\", levels(deg), fill = colors, title = \"Degree\")\n}\n\nLet’s try using plot_degree:\n\nnet &lt;- create_network(500, 1.5)\nplot_degree(net)\n\n\n\n\n\n\n\n\n\nThis time we’ve created a network with 500 nodes. Try varying the d parameter again and plotting the generated networks. Are the results similar to what you saw before with 40 nodes?\n\nNow let’s create and test a similar function that will plot the state of each node:\n\n# Plot a network, colouring by state (S/I/R/V).\nplot_state &lt;- function(network)\n{\n    # Set up palette\n    colors &lt;- c(S = \"lightblue\", I = \"red\", R = \"darkblue\", V = \"white\")\n    \n    # Plot network\n    plot(network, \n        vertex.color = colors[V(network)$state], \n        vertex.label = NA,\n        vertex.size = 4)\n    legend(\"topright\", names(colors), fill = colors, title = \"State\")\n}\n\nnet &lt;- create_network(500, 1)\nplot_state(net)\n\n\n\n\n\n\n\n\n\n\nRunning the model\nNow we’ll create a function network_step() that runs a single generation (step) of the model. It will find all the susceptible neighbours of infectious individuals in the network, infect each of them with probability \\(p\\), and then change the state of all the individuals who were infectious at the beginning of the time step to “R” for recovered.\n\n# Enact one step of the network model: infectious individuals infect \n# susceptible neighbours with probability p, and recover after one time step.\nnetwork_step &lt;- function(net, p)\n{\n    # Identify all susceptible neighbours of infectious individuals, \n    # who are \"at risk\" of infection\n    at_risk &lt;- V(net)[state == \"S\" & .nei(state == \"I\")]\n    \n    # Use the transmission probability to select who gets exposed from\n    # among those at risk\n    exposed &lt;- at_risk[runif(length(at_risk)) &lt; p]\n    \n    # All currently infectious individuals will recover\n    V(net)[state == \"I\"]$state &lt;- \"R\"\n    \n    # All exposed individuals become infectious\n    V(net)[exposed]$state &lt;- \"I\"\n\n    return (net)\n}\n\nLet’s see if this works so far:\n\nnet &lt;- create_network(500, 1)\n\nnet &lt;- network_step(net, p = 0.8)\nplot_state(net)\n\n\n\n\n\n\n\n\n\nAfter creating your network with the first line above, run the last two lines repeatedly to watch the network model evolve.\n\nFinally, let’s create and test a function that will run the model on a given network from time 0 to time t_max with a given secondary attack rate p:\n\n# Run the transmission model on the network with maximum simulation time t_max\n# and transmission probability p.\nrun_model &lt;- function(net, t_max, p)\n{\n    # Plot network degree\n    plot_degree(net)\n    Sys.sleep(2.0)\n\n    # Iterate over each time step\n    for (t in 0:t_max)\n    {\n        # Plot current state\n        Sys.sleep(0.5)\n        plot_state(net)\n\n        # Stop early if no infectious individuals are left\n        if (!any(V(net)$state == \"I\")) {\n            break;\n        }\n\n        # Run one step of the network model\n        net &lt;- network_step(net, p)\n    }\n    \n    # Return final outbreak size\n    return (sum(V(net)$state == \"R\"))\n}\n\nThe code above uses Sys.sleep() to pause for short time between “frames” of the network model animation, so that it doesn’t zip by too quickly to watch. Now let’s try it out:\n\nnet &lt;- create_network(500, 1)\nrun_model(net, 100, 0.8)\n\n\nHow does the preferential attachment parameter (create_network parameter d) affect the final outbreak size?\n\n\n\nBonus: Extending the model\nIf you still have time left, try adding vaccination to the model, then extending the model to summarize the results from multiple runs.\n\nVaccination\nFor vaccination, fill in this function:\n\nvaccinate_network &lt;- function(network, v, k)\n{ \n    # ... do vaccination here ... \n    return (network)\n}\n\nso that it sets a randomly-selected fraction v of nodes in the network to state “V”? (Don’t worry about the parameter k for now.)\nOnce you’ve done that, and tested that it works by watching the results of run_model(), let’s move on to something trickier.\nUsually, as a first step, we might model each person’s propensity for getting vaccinated as being independent of their other characteristics – that is, we make the assumption that people get vaccinated completely at random.\nBut what if only the lowest-risk get people get vaccinated, because people at higher risk have less access to vaccines? Or what if we design our vaccination programme to target specifically the people who are at higher risk?\nTry extending the function vaccinate_network() that you have written to use the parameter k to control the association between risk and vaccination.\nFor example, when k = 0 we can vaccinate people at random; when k = 1 we vaccinate only those people with the highest number of connections in the network; and when k = -1 we vaccnate only those people with the lowest number of connections in the network.\nRecall that our create_network() function already makes sure that the vertices are sorted in order from lowest degree to highest degree, so that, for example, V(network)[1:10] would select the 10 least connected individuals and V(network)[(vcount(network) - 9):vcount(network)] would select the 10 most connected individuals.\nThe version of vaccinate_network() in the solutions for this practical goes a step further by allowing intermediate values for k between -1 and +1, with intermediate values moving from the extreme of vaccinating only the least-connected (\\(k = -1\\)) to vaccinating at random (\\(k = 0\\)) to vaccinating only the most-connected (\\(k = 1\\)). There are lots of different ways of doing this, but the way the practical solution does it is by first vaccinating the \\(nv\\) most connected individuals if k is positive, or the \\(nv\\) least connected individuals if \\(k\\) is negative, then randomly shuffling the vaccination status of a fraction \\(1 - |k|\\) of all individuals. Check the solutions if you like, but you can also try implementing this (or another way) yourself.\n\n\nSummarize results from multiple runs\nSince the results of a network model can vary a lot from run to run, it is helpful to be able to easily run the model many times for the same starting conditions and summarize the results. Here is one way you might extend the run_model() function to generate epidemic curves for each model run, and create a new function run_scenario() to run the model multiple times with the same parameters:\n\n# Run the transmission model on the network with maximum simulation time t_max\n# and transmission probability p; plot the network as the model is running if\n# animate = TRUE.\nrun_model &lt;- function(net, t_max, p, animate = FALSE)\n{\n    # Plot network degree\n    if (animate) {\n        plot_degree(net)\n        Sys.sleep(2.0)\n    }\n\n    # Set up results\n    dt &lt;- list()\n\n    # Iterate over each time step\n    for (t in 0:t_max)\n    {\n        # Store results\n        dt[[length(dt) + 1]] &lt;- data.table(\n            S = sum(V(net)$state == \"S\"),\n            I = sum(V(net)$state == \"I\"),\n            R = sum(V(net)$state == \"R\"),\n            V = sum(V(net)$state == \"V\")\n        )\n\n        # Plot current state\n        if (animate) {\n            Sys.sleep(0.5)\n            plot_state(net)\n        }\n        \n        # Stop early if no infectious individuals are left\n        if (!any(V(net)$state == \"I\")) {\n            break;\n        }\n\n        # Run one step of the network model\n        net &lt;- network_step(net, p)\n    }\n    \n    # Return the epi curve, including empirical calculation of Rt\n    results &lt;- rbindlist(dt, idcol = \"t\")\n    results$Rt &lt;- results$I / shift(results$I, 1) # new infections per new infection last time step\n    return (results)\n}\n\n# Run the model nsim times with parameters in params (n, d, v, k, t_max, p),\n# showing the animated network the first nanim times, and returning a data.table\n# with the results of each simulation.\nrun_scenario &lt;- function(params, nsim, nanim = 1)\n{\n    results &lt;- list()\n    \n    for (sim in 1:nsim)\n    {\n        net &lt;- create_network(params$n, params$power)\n        net &lt;- vaccinate_network(net, params$v, params$k)\n\n        results[[sim]] &lt;- run_model(net, params$t_max, params$p, animate = sim &lt;= nanim)\n        \n        cat(\".\")\n    }\n    cat(\"\\n\");\n    \n    results &lt;- rbindlist(results, idcol = \"run\")\n    return (results)\n}\n\nparams &lt;- list(\n    n = 500,\n    d = 0,\n    p = 0.8,\n    v = 0.3,\n    k = 0,\n    t_max = 100\n)\n\nx &lt;- run_scenario(params, nsim = 5, nanim = 0)\n\n.....\n\nggplot(x) +\n    geom_line(aes(x = t, y = R, group = run))\n\n\n\n\n\n\n\n\n\nHow does the vaccine-risk association parameter k affect the final size of the epidemic when averaged over 50 different model runs?\n\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "00_04_ggplot_solutions.html",
    "href": "00_04_ggplot_solutions.html",
    "title": "P03. Introduction to ggplot: solutions",
    "section": "",
    "text": "Consider an SIR model. A CSV file has been provided for each of the three populations in the model: S - susceptible, I - infectious, R - recovered. The model used to simulate the disease is\n\nf_sir &lt;- function(time, state, parameters) {\n    \n    with(as.list(c(state, parameters)), {\n        \n        infections  &lt;- beta*S*I\n        deaths      &lt;- gamma*I\n        \n        dS &lt;- -infections \n        dI &lt;-  infections - deaths\n        dR &lt;-               deaths\n        \n        return(list(c(dS, dI, dR)))\n    })\n}\n\nwhere beta is the transmission rate (per person, per day) and gamma is the recovery rate (by day). This practical is only for plotting - so you don’t necessarily need to fully understand this function in order to move on.\n\n\n\n\nThe CSV file may be downloaded from here.\n\nlibrary(ggplot2)\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\n\nall_dat &lt;- read_csv(\"beta_1.56756_gamma_0.36508.csv\")\nall_dat\n\n\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\nRows: 801 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (4): time, S, I, R\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n# A tibble: 801 × 4\n    time     S          I            R\n   &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;        &lt;dbl&gt;\n 1  0     1.00 0.000001   0           \n 2  0.05  1.00 0.00000106 0.0000000188\n 3  0.1   1.00 0.00000113 0.0000000388\n 4  0.15  1.00 0.00000120 0.0000000600\n 5  0.2   1.00 0.00000127 0.0000000826\n 6  0.25  1.00 0.00000135 0.000000107 \n 7  0.3   1.00 0.00000143 0.000000132 \n 8  0.35  1.00 0.00000152 0.000000159 \n 9  0.4   1.00 0.00000162 0.000000188 \n10  0.45  1.00 0.00000172 0.000000218 \n# ℹ 791 more rows\n\n\nshould return four columns: | time | S | I | R |\n\nall_dat_long &lt;- pivot_longer(all_dat, \n                             cols = c(S, I, R),\n                             names_to = \"state\",\n                             values_to = \"proportion\")\n\nall_dat_long\n\n# A tibble: 2,403 × 3\n    time state   proportion\n   &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1  0    S     1.00        \n 2  0    I     0.000001    \n 3  0    R     0           \n 4  0.05 S     1.00        \n 5  0.05 I     0.00000106  \n 6  0.05 R     0.0000000188\n 7  0.1  S     1.00        \n 8  0.1  I     0.00000113  \n 9  0.1  R     0.0000000388\n10  0.15 S     1.00        \n# ℹ 2,393 more rows\n\n\nshould return three columns: | time | state (key) | proportion (value) |\n\n\n\n\n\n\nUse the line geometry and color each line by state. You might find the following link useful https://ggplot2.tidyverse.org/reference/index.html\n\nggplot(data = all_dat_long, \n       aes(x = time,\n           y = proportion)) +\n    geom_line(aes(color = state)) \n\n\n\n\n\n\n\n\n\n\n\nCopy and paste the code from the previous plot and re-run it to see how the ordering of the states has changed\n\nall_dat_long$state &lt;- factor(all_dat_long$state,\n                             levels = c(\"S\", \"I\", \"R\"))\n\nplot_SIR &lt;- ggplot(data = all_dat_long, \n                   aes(x = time, y = proportion)) +\n                geom_line(aes(color = state)) \n\nplot_SIR\n\n\n\n\n\n\n\n\n\n\n\n\nplot_SIR + \n    theme_bw() + \n    xlab(\"Time (days)\") + \n    ylab(\"Population proportion\") +\n    theme(legend.position = \"bottom\") \n\n\n\n\n\n\n\n\n\n\n\n\nplot_SIR_faceted &lt;- ggplot(data = all_dat_long,\n       aes(x = time,\n           y = proportion)) +\n    geom_line() + \n    theme_bw() + \n    xlab(\"Time (days)\") + \n    ylab(\"Population proportion\") +\n    facet_wrap(facets = vars(state)) \n\nplot_SIR_faceted"
  },
  {
    "objectID": "00_04_ggplot_solutions.html#part-1-single-outbreak",
    "href": "00_04_ggplot_solutions.html#part-1-single-outbreak",
    "title": "P03. Introduction to ggplot: solutions",
    "section": "",
    "text": "Consider an SIR model. A CSV file has been provided for each of the three populations in the model: S - susceptible, I - infectious, R - recovered. The model used to simulate the disease is\n\nf_sir &lt;- function(time, state, parameters) {\n    \n    with(as.list(c(state, parameters)), {\n        \n        infections  &lt;- beta*S*I\n        deaths      &lt;- gamma*I\n        \n        dS &lt;- -infections \n        dI &lt;-  infections - deaths\n        dR &lt;-               deaths\n        \n        return(list(c(dS, dI, dR)))\n    })\n}\n\nwhere beta is the transmission rate (per person, per day) and gamma is the recovery rate (by day). This practical is only for plotting - so you don’t necessarily need to fully understand this function in order to move on.\n\n\n\n\nThe CSV file may be downloaded from here.\n\nlibrary(ggplot2)\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\n\nall_dat &lt;- read_csv(\"beta_1.56756_gamma_0.36508.csv\")\nall_dat\n\n\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\nRows: 801 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (4): time, S, I, R\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n# A tibble: 801 × 4\n    time     S          I            R\n   &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;        &lt;dbl&gt;\n 1  0     1.00 0.000001   0           \n 2  0.05  1.00 0.00000106 0.0000000188\n 3  0.1   1.00 0.00000113 0.0000000388\n 4  0.15  1.00 0.00000120 0.0000000600\n 5  0.2   1.00 0.00000127 0.0000000826\n 6  0.25  1.00 0.00000135 0.000000107 \n 7  0.3   1.00 0.00000143 0.000000132 \n 8  0.35  1.00 0.00000152 0.000000159 \n 9  0.4   1.00 0.00000162 0.000000188 \n10  0.45  1.00 0.00000172 0.000000218 \n# ℹ 791 more rows\n\n\nshould return four columns: | time | S | I | R |\n\nall_dat_long &lt;- pivot_longer(all_dat, \n                             cols = c(S, I, R),\n                             names_to = \"state\",\n                             values_to = \"proportion\")\n\nall_dat_long\n\n# A tibble: 2,403 × 3\n    time state   proportion\n   &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1  0    S     1.00        \n 2  0    I     0.000001    \n 3  0    R     0           \n 4  0.05 S     1.00        \n 5  0.05 I     0.00000106  \n 6  0.05 R     0.0000000188\n 7  0.1  S     1.00        \n 8  0.1  I     0.00000113  \n 9  0.1  R     0.0000000388\n10  0.15 S     1.00        \n# ℹ 2,393 more rows\n\n\nshould return three columns: | time | state (key) | proportion (value) |\n\n\n\n\n\n\nUse the line geometry and color each line by state. You might find the following link useful https://ggplot2.tidyverse.org/reference/index.html\n\nggplot(data = all_dat_long, \n       aes(x = time,\n           y = proportion)) +\n    geom_line(aes(color = state)) \n\n\n\n\n\n\n\n\n\n\n\nCopy and paste the code from the previous plot and re-run it to see how the ordering of the states has changed\n\nall_dat_long$state &lt;- factor(all_dat_long$state,\n                             levels = c(\"S\", \"I\", \"R\"))\n\nplot_SIR &lt;- ggplot(data = all_dat_long, \n                   aes(x = time, y = proportion)) +\n                geom_line(aes(color = state)) \n\nplot_SIR\n\n\n\n\n\n\n\n\n\n\n\n\nplot_SIR + \n    theme_bw() + \n    xlab(\"Time (days)\") + \n    ylab(\"Population proportion\") +\n    theme(legend.position = \"bottom\") \n\n\n\n\n\n\n\n\n\n\n\n\nplot_SIR_faceted &lt;- ggplot(data = all_dat_long,\n       aes(x = time,\n           y = proportion)) +\n    geom_line() + \n    theme_bw() + \n    xlab(\"Time (days)\") + \n    ylab(\"Population proportion\") +\n    facet_wrap(facets = vars(state)) \n\nplot_SIR_faceted"
  },
  {
    "objectID": "00_04_ggplot_solutions.html#part-2-100-outbreaks",
    "href": "00_04_ggplot_solutions.html#part-2-100-outbreaks",
    "title": "P03. Introduction to ggplot: solutions",
    "section": "Part 2: 100 outbreaks",
    "text": "Part 2: 100 outbreaks\nWe are still considering an outbreak of a disease with S, I, and R. But this time, we are working with 100 simulations. This time, the file you are going to work with can be downloaded here.\n\nPreparing data for plotting\n\na) Read in the 100 simulation data set\n\n# \nall_dat_100 &lt;- read_csv(\"100_simulations_wide.csv\")\nall_dat_100\n\n\n\nRows: 10100 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (5): sim, time, S, I, R\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n# A tibble: 10,100 × 5\n     sim  time     S     I      R\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1     1   0    99    1    0     \n 2     1   0.1  98.9  1.10 0.0313\n 3     1   0.2  98.7  1.21 0.0657\n 4     1   0.3  98.6  1.34 0.104 \n 5     1   0.4  98.4  1.47 0.145 \n 6     1   0.5  98.2  1.62 0.191 \n 7     1   0.6  98.0  1.78 0.242 \n 8     1   0.7  97.7  1.96 0.298 \n 9     1   0.8  97.5  2.16 0.359 \n10     1   0.9  97.2  2.37 0.426 \n# ℹ 10,090 more rows\n\n\nshould return five columns: | sim | time | S | I | R |\n\nall_dat_100_long &lt;- pivot_longer(all_dat_100, \n                                 cols = c(\"S\", \"I\", \"R\"),\n                                 names_to = \"state\",\n                                 values_to = \"proportion\")\nall_dat_100_long$state &lt;- factor(all_dat_100_long$state,\n                             levels = c(\"S\", \"I\", \"R\"))\nall_dat_100_long\n\n# A tibble: 30,300 × 4\n     sim  time state proportion\n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;      &lt;dbl&gt;\n 1     1   0   S        99     \n 2     1   0   I         1     \n 3     1   0   R         0     \n 4     1   0.1 S        98.9   \n 5     1   0.1 I         1.10  \n 6     1   0.1 R         0.0313\n 7     1   0.2 S        98.7   \n 8     1   0.2 I         1.21  \n 9     1   0.2 R         0.0657\n10     1   0.3 S        98.6   \n# ℹ 30,290 more rows\n\n\nshould return four columns: | sim | time | state (key) | proportion (value) |\n\n\nb) Plot all 100 simulations from the SIR model\nHint: you will need to use the group aesthetic with your line and may choose to set the lines to be semi-transparent. Use faceting (small multiples) to show each state in its own subplot; faceting will be easier in all plots from this point on than colouring by state.\n\nggplot(data = all_dat_100_long,\n       aes(x = time, \n           y = proportion)) +\n    geom_line(aes(group = sim), alpha = 0.05) +\n    theme_bw() + \n    facet_grid(~state) +\n    xlab(\"Time(days)\") +\n    ylab(\"Proportion of population\")\n\n\n\n\n\n\n\n\n\n\n\nCalculating summary statistics\n\nc) Use the group_by() function to tell R that we want to calculate summary statistics for each state at each time\n\nall_dat_100_long_grouped &lt;- group_by(all_dat_100_long, state, time) \nall_dat_100_long_grouped\n\n# A tibble: 30,300 × 4\n# Groups:   state, time [303]\n     sim  time state proportion\n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;      &lt;dbl&gt;\n 1     1   0   S        99     \n 2     1   0   I         1     \n 3     1   0   R         0     \n 4     1   0.1 S        98.9   \n 5     1   0.1 I         1.10  \n 6     1   0.1 R         0.0313\n 7     1   0.2 S        98.7   \n 8     1   0.2 I         1.21  \n 9     1   0.2 R         0.0657\n10     1   0.3 S        98.6   \n# ℹ 30,290 more rows\n\n\nshould return four columns: | sim | time | state (key) | proportion (value) |\nshould also let you know there are 303 groups\n\n\nd) Use the summarise function to calculate the median and 95% interval for each state at each time point.\nYou will need to calculate all three summary statistics separately, and will do so within the same summarise()\n\nall_dat_100_long_summarised &lt;- \n    summarise(all_dat_100_long_grouped,\n              q0.025 = quantile(proportion, probs = 0.025),\n              q0.500 = quantile(proportion, probs = 0.5),\n              q0.975 = quantile(proportion, probs = 0.975))\n\n`summarise()` has grouped output by 'state'. You can override using the\n`.groups` argument.\n\n\n\n\ne) Use geom_ribbon to plot the 95% interval and geom_line to plot the median for each state.\nFor its aesthetics, geom_ribbon requires a ymin and ymax and can be coloured and filled and made semi-transparent. Ensure you label the axes appropriately.\n\nggplot(data = all_dat_100_long_summarised,\n       aes(x = time)) +\n    geom_ribbon(aes(ymin = q0.025,  # lower edge of ribbon\n                    ymax = q0.975), # upper edge of ribbon\n                alpha = 0.5,   # make semi-transparent\n                fill = \"lightskyblue\", # fill blue\n                color = NA) +     # no border color\n    geom_line(aes(y = q0.500)) +       # line for median\n    facet_grid(cols = vars(state)) +\n    theme_bw() +               # nicer theme\n    xlab(\"Time (days)\") +      # human friendly axis label\n    ylab(\"Population\")        # human friendly axis label\n\n\n\n\n\n\n\n\n\n\nf) If you have time left, you may wish to investigate visualising all 100 simulations, colouring by state, as before, and faceting by simulation\n\nggplot(data = all_dat_100_long,\n       aes(x = time)) +\n    geom_line(aes(y = proportion, color = state)) +\n    facet_wrap(facets = vars(sim)) +\n    theme_bw() +               # nicer theme\n    xlab(\"Time (days)\") +      # human friendly axis label\n    ylab(\"Population\") +       # human friendly axis label\n    theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n\ng) Discuss whether you think faceting by state or simulation gives a clearer understanding of how the simulations vary\nI don’t think so - too many panels. But you may have your reason :)"
  }
]