[
  {
    "objectID": "09_Networks_practical.html",
    "href": "09_Networks_practical.html",
    "title": "09. Networks",
    "section": "",
    "text": "In this practical, we will implement a network model of mpox transmission."
  },
  {
    "objectID": "09_Networks_practical.html#practical-1.-introduction-to-the-igraph-package",
    "href": "09_Networks_practical.html#practical-1.-introduction-to-the-igraph-package",
    "title": "09. Networks",
    "section": "Practical 1. Introduction to the igraph package",
    "text": "Practical 1. Introduction to the igraph package\nThe R package igraph allows you to create, manipulate, and plot graphs. This first practical will show you the basics of igraph and will demonstrate how we might use graphs to represent infectious disease transmission.\n\nBuilding and plotting graphs\nigraph has a number of functions that are designed to create graphs according to certain rules or designs. One of the simplest graphs, conceptually, is the “complete” or “full” graph, in which each vertex is connected to every other vertex. This is made using the igraph function make_full_graph(n), where n is the number of nodes or vertices.\nLet’s make a complete graph with 4 nodes. Run the following code:\n\nlibrary(igraph) # For network functionality\nlibrary(data.table)\nlibrary(ggplot2)\n\n# Complete graph with 4 nodes\ngr &lt;- make_full_graph(4)\nprint(gr)\n\nIGRAPH 0739b88 U--- 4 6 -- Full graph\n+ attr: name (g/c), loops (g/l)\n+ edges from 0739b88:\n[1] 1--2 1--3 1--4 2--3 2--4 3--4\n\n\nTake a look at the output of print(gr).\nThe most important parts here are probably “4 6” at the top (this means the graph has 4 vertices and 6 edges) and the list of edges at the bottom, showing which nodes are connected to which other nodes.\nThis information is easier to take in if we plot the graph. Run the following:\n\nplot(gr)\n\n\nRun the plot(gr) line multiple times. The plot changes. Does the graph change?\n\nigraph has lots of different functions for making different kinds of graphs. make_full_graph is one that we’ve already seen, but there are several others.\nHere are some examples, all of which create graphs with a different number of nodes. Try plotting each of them and think about the implications of each network for infectious disease transmission, if each node represents a person and each edge means that the two people connected by the edge can potentially infect each other.\n\nmake_full_graph(16)\nmake_ring(16)\nmake_ring(16, circular = FALSE)\nmake_lattice(c(4, 4))\n\nRemember, to read more about a specific function, you can look up the help on that function, e.g.\n\n?make_lattice\n\nAny igraph function that starts with make_ is deterministic, i.e. gives you the same graph every time you run it. There are also igraph functions that give you random graphs, i.e. the function uses some random model to build a new graph each time. These functions start with sample_.\nOne of the simplest random graphs is called a Bernoulli random graph, or an Erdős-Rényi \\(G(n,p)\\) graph. This just means that there are n nodes in the graph, and every possible pair of nodes is connected with probability p. This graph is created using the function sample_gnp(n, p).\nLet’s start by looking again at our complete graph with 16 vertices:\n\nplot(make_full_graph(16), layout = layout_in_circle)\n\n\n\n\n\n\n\n\nAbove, layout = layout_in_circle puts all the nodes evenly around a circle, so that the position of the nodes is the same each time the graph is plotted. This will make the next graph easier to compare.\nNow, let’s make a \\(G(n,p)\\) graph with \\(p = 0.2\\) and plot that.\n\nplot(sample_gnp(16, 0.2), layout = layout_in_circle)\n\n\n\n\n\n\n\n\nCompare it to the previous plot, and run these two lines multiple times to see what happens.\nTry changing the number of nodes and the connection probability and see what happens. If you set \\(p\\) to a lower value, like 0.1, you are more likely to see individual nodes with no connections to other nodes, or several separated parts of the overall graph - try it.\nThere are lots of other well-known models for generating random graphs. Some of the most famous are the “small-world” model by Watts and Strogatz, where there are initially connections between neighbours, some of which are randomly rewired:\n\nplot(sample_smallworld(1, 16, 2, 0.1), layout = layout_in_circle)\n\nOr the “preferential attachment” model by Barabási and Albert, which is built by adding nodes one at a time, and each time a node is added, it is connected to other nodes, where the connection is more likely to be made to a node that already has more connections (a “rich get richer” dynamic).\n\nplot(sample_pa(16, directed = FALSE))\n\nOne reason these two models are so well known is that they were both introduced in high-impact papers claiming that the underlying models were widely applicable to a variety of real-world networks. Worth reading if you are interested:\nWatts DJ, Strogatz SH (1998) Collective dynamics of ‘small world’ networks. Nature 393, 440-442. https://snap.stanford.edu/class/cs224w-readings/watts98smallworld.pdf\nBarabási AL, Albert R (1999) Emergence of scaling in random networks. Science 286, 509–512. https://barabasi.com/f/67.pdf\n\n\nGetting and setting properties of the graph\nLet’s start by making a new ‘lattice’ graph:\n\nnetwork &lt;- make_lattice(c(5, 5)) \nprint(network) \nplot(network)\n\nSome simple calculations: vcount() or ecount() give the number of vertices or edges in the graph; degree() gives the number of neighbours of each vertex. Try running each of these.\n\nvcount(network) \necount(network) \ndegree(network)\n\nWith igraph, you can get and set attributes of the entire graph using the $ operator. For example, let’s set the graph’s layout to a grid:\n\nnetwork$layout &lt;- layout_on_grid(network)\nprint(network)\nplot(network)\n\nNotice that this has done two things. First, it added the attribute layout (g/n) to the graph and this is now shown as being present when you run print(network). Second, it has permanently fixed the layout of the graph so that it always plots the same way.\nYou can also modify properties of the vertices and of the edges, using V() and E() respectively. Let’s change the color of the vertices and edges:\n\nV(network)$color &lt;- \"azure\"\nE(network)$color &lt;- \"pink\" \nplot(network) # lovely\n\nYou can use V(network)[[]] or E(network)[[]] to see the properties of the vertices/edges laid out as a data frame. Try it:\n\nV(network)[[]]\nE(network)[[]]\n\nNotice that both have a “color” attribute now. This also appears in the list of attributes when we print the network:\n\nprint(network)\n\nIGRAPH 12b6cd1 U--- 25 40 -- Lattice graph\n+ attr: name (g/c), dimvector (g/n), nei (g/n), mutual (g/l), circular\n| (g/l), layout (g/n), color (v/c), color (e/c)\n+ edges from 12b6cd1:\n [1]  1-- 2  1-- 6  2-- 3  2-- 7  3-- 4  3-- 8  4-- 5  4-- 9  5--10  6-- 7\n[11]  6--11  7-- 8  7--12  8-- 9  8--13  9--10  9--14 10--15 11--12 11--16\n[21] 12--13 12--17 13--14 13--18 14--15 14--19 15--20 16--17 16--21 17--18\n[31] 17--22 18--19 18--23 19--20 19--24 20--25 21--22 22--23 23--24 24--25\n\n\nAmong the attributes here, you can now see layout (g/n), color (v/c), and color (e/c). Here, the ‘g’ in (g/n) means the property is attached to the entire graph, while the ‘v’ and ‘e’ means the respective properties are attached to vertices and edges respectively. See ?print.igraph for more explanation of the codes.\nFinally, we can also use brackets [] to change properties of only certain vertices/edges. Here are some examples:\n\nV(network)[12]$color &lt;- \"orange\"\nplot(network)\n\n\nV(network)[color == \"orange\"]$color &lt;- \"pink\" \nplot(network)\n\n\nWhat do the above lines do?\n\nThe .nei() function, when used inside V(some_network)[ ], selects all neighbours of the specified vertices. This is very useful for transmission models on networks, because it is the neighbours of infected vertices that are at risk of getting exposed to the pathogen. Try running the code below and see what it does.\n\n# Pink is contagious:\nV(network)[.nei(color == \"pink\")]$color &lt;- \"pink\"\nplot(network)\n\n\nWhat is the code above doing? What happens if you re-run the two lines above several times?\n\nSome other interesting attributes for vertices include:\n\nlabel text label for the vertices (set to NA for no labels)\nsize size of the markers when plotted\n\n\nV(network)$label &lt;- NA\nV(network)$shape &lt;- \"square\"\nplot(network)\n\n\n\n\n\n\n\n\nSee ?igraph.plotting for more!\n\n\nBonus: Code a network model\nIf you have gotten this far and still have time before the session is up, see if you can use what you have learned above to code an SIR model on a network.\nSuggestion: If you want to plot the network at each time step to watch it “animate”, you can use Sys.sleep(1.0) to pause for a second between snapshots of the network so that the plots don’t all appear at once."
  },
  {
    "objectID": "09_Networks_practical.html#practical-2.-a-network-model-of-mpox-transmission",
    "href": "09_Networks_practical.html#practical-2.-a-network-model-of-mpox-transmission",
    "title": "09. Networks",
    "section": "Practical 2. A network model of mpox transmission",
    "text": "Practical 2. A network model of mpox transmission\nFor this practical, we’ll be using igraph and the techniques described above to build a simplified model of MPV (monkeypox virus) transmission in a network of sexual contacts among men who have sex with men (MSM).\n\nSetting up the network\nWe’ll build up our model by building several “helper” functions that break down our modelling task for us. We start by creating a function that builds a network by preferential attachment (see the citation to Barabási and Albert 1999 above).\nIn preferential attachment, the graph starts with one node, and then new nodes are added to the network one at a time. Every time a new node is added, it is connected to one randomly-selected node of the existing network, where the node to attach to is selected with probability proportional to the number of connections it already has. In other words, the new node attaches to existing node \\(i\\) with probability proportional to \\(\\mathrm{deg}(i)\\), where \\(\\mathrm{deg}(i)\\) is the degree of node \\(i\\). This tends to build up connections at nodes that are already well connected, meaning that in the resulting network, a small number of nodes have many connections while most nodes have only a few. Sexual networks tend to exhibit this property, which is why we’re using preferential attachment for our model.\nThere are variations to the preferential attachment model – for example, some variants add \\(m\\) connections to existing nodes instead of 1 each time a node is added, and some variants make the probability of attaching to node \\(i\\) proportional to \\(\\mathrm{deg}(i)^d\\), with \\(d\\) some constant.\nLet’s begin by making a function create_network() that uses the sample_pa() function of igraph to create a new network; then set a property “state” for each node to “S” for susceptible; and then give 5 random individuals the state “I” for infectious.\n\nlibrary(igraph)\nlibrary(data.table)\n\n# Set up a transmission network of n nodes by preferential attachment with \n# affinity proportional to degree^m.\ncreate_network &lt;- function(n, d, layout = layout_nicely)\n{\n    # Create the network by preferential attachment, passing on the parameters \n    # n and power\n    network &lt;- sample_pa(n, d, directed = FALSE)\n\n    # Add the \"state\" attribute to the vertices of the network, which can be\n    # \"S\", \"I\", \"R\", or \"V\". \n    # Start out everyone as susceptible ...\n    V(network)$state &lt;- \"S\"\n    # ... except make 5 random individuals infectious.\n    V(network)$state[sample(vcount(network), 5, prob = degree(network))] &lt;- \"I\"\n\n    # Reorder vertices so they go in order from least to most connected. This\n    # is to help with degree-targeted vaccination, and also to make the \n    # most connected vertices plot on top so they don't get hidden. \n    network &lt;- permute(network, rank(degree(network), ties.method = \"first\"))\n    # Set the network layout so it doesn't change every time it's plotted.\n    network$layout &lt;- layout(network)\n    \n    return (network)\n}\n\nNow, let’s try using the function and looking at the results.\n\nnet &lt;- create_network(n = 40, d = 1)\nplot(net)\n\n\n\n\n\n\n\n\n\nTry varying the d parameter for create_network between 0 and 2. What changes about the network?\n\nThe above plot looks a little cluttered, so we’ll create a function plot_degree that tidies up the plot a little so that we can focus on the important features, and colours the nodes according to how well connected they are.\n\n# Plot a network, highlighting the degree of each node by different colours.\nplot_degree &lt;- function(network)\n{\n    # Set up palette\n    colors &lt;- hcl.colors(5, \"Zissou 1\")\n    \n    # Classify nodes by degree\n    deg &lt;- cut(degree(network), \n        breaks = c(1, 2, 5, 10, 20, Inf),\n        labels = c(\"1\", \"2-4\", \"5-9\", \"10-19\", \"20+\"),\n        include.lowest = TRUE, right = FALSE)\n\n    # Plot network\n    plot(network, \n        vertex.color = colors[deg],\n        vertex.label = NA,\n        vertex.size = 4)\n    legend(\"topright\", levels(deg), fill = colors, title = \"Degree\")\n}\n\nLet’s try using plot_degree:\n\nnet &lt;- create_network(500, 1.5)\nplot_degree(net)\n\n\n\n\n\n\n\n\n\nThis time we’ve created a network with 500 nodes. Try varying the d parameter again and plotting the generated networks. Are the results similar to what you saw before with 40 nodes?\n\nNow let’s create and test a similar function that will plot the state of each node:\n\n# Plot a network, colouring by state (S/I/R/V).\nplot_state &lt;- function(network)\n{\n    # Set up palette\n    colors &lt;- c(S = \"lightblue\", I = \"red\", R = \"darkblue\", V = \"white\")\n    \n    # Plot network\n    plot(network, \n        vertex.color = colors[V(network)$state], \n        vertex.label = NA,\n        vertex.size = 4)\n    legend(\"topright\", names(colors), fill = colors, title = \"State\")\n}\n\nnet &lt;- create_network(500, 1)\nplot_state(net)\n\n\n\n\n\n\n\n\n\n\nRunning the model\nNow we’ll create a function network_step() that runs a single generation (step) of the model. It will find all the susceptible neighbours of infectious individuals in the network, infect each of them with probability \\(p\\), and then change the state of all the individuals who were infectious at the beginning of the time step to “R” for recovered.\n\n# Enact one step of the network model: infectious individuals infect \n# susceptible neighbours with probability p, and recover after one time step.\nnetwork_step &lt;- function(net, p)\n{\n    # Identify all susceptible neighbours of infectious individuals, \n    # who are \"at risk\" of infection\n    at_risk &lt;- V(net)[state == \"S\" & .nei(state == \"I\")]\n    \n    # Use the transmission probability to select who gets exposed from\n    # among those at risk\n    exposed &lt;- at_risk[runif(length(at_risk)) &lt; p]\n    \n    # All currently infectious individuals will recover\n    V(net)[state == \"I\"]$state &lt;- \"R\"\n    \n    # All exposed individuals become infectious\n    V(net)[exposed]$state &lt;- \"I\"\n\n    return (net)\n}\n\nLet’s see if this works so far:\n\nnet &lt;- create_network(500, 1)\n\nnet &lt;- network_step(net, p = 0.8)\nplot_state(net)\n\n\n\n\n\n\n\n\n\nAfter creating your network with the first line above, run the last two lines repeatedly to watch the network model evolve.\n\nFinally, let’s create and test a function that will run the model on a given network from time 0 to time t_max with a given secondary attack rate p:\n\n# Run the transmission model on the network with maximum simulation time t_max\n# and transmission probability p.\nrun_model &lt;- function(net, t_max, p)\n{\n    # Plot network degree\n    plot_degree(net)\n    Sys.sleep(2.0)\n\n    # Iterate over each time step\n    for (t in 0:t_max)\n    {\n        # Plot current state\n        Sys.sleep(0.5)\n        plot_state(net)\n\n        # Stop early if no infectious individuals are left\n        if (!any(V(net)$state == \"I\")) {\n            break;\n        }\n\n        # Run one step of the network model\n        net &lt;- network_step(net, p)\n    }\n    \n    # Return final outbreak size\n    return (sum(V(net)$state == \"R\"))\n}\n\nThe code above uses Sys.sleep() to pause for short time between “frames” of the network model animation, so that it doesn’t zip by too quickly to watch. Now let’s try it out:\n\nnet &lt;- create_network(500, 1)\nrun_model(net, 100, 0.8)\n\n\nHow does the preferential attachment parameter (create_network parameter d) affect the final outbreak size?\n\n\n\nBonus: Extending the model\nIf you still have time left, try adding vaccination to the model, then extending the model to summarize the results from multiple runs.\n\nVaccination\nFor vaccination, fill in this function:\n\nvaccinate_network &lt;- function(network, v, k)\n{ \n    # ... do vaccination here ... \n    return (network)\n}\n\nso that it sets a randomly-selected fraction v of nodes in the network to state “V”? (Don’t worry about the parameter k for now.)\nOnce you’ve done that, and tested that it works by watching the results of run_model(), let’s move on to something trickier.\nUsually, as a first step, we might model each person’s propensity for getting vaccinated as being independent of their other characteristics – that is, we make the assumption that people get vaccinated completely at random.\nBut what if only the lowest-risk get people get vaccinated, because people at higher risk have less access to vaccines? Or what if we design our vaccination programme to target specifically the people who are at higher risk?\nTry extending the function vaccinate_network() that you have written to use the parameter k to control the association between risk and vaccination.\nFor example, when k = 0 we can vaccinate people at random; when k = 1 we vaccinate only those people with the highest number of connections in the network; and when k = -1 we vaccnate only those people with the lowest number of connections in the network.\nRecall that our create_network() function already makes sure that the vertices are sorted in order from lowest degree to highest degree, so that, for example, V(network)[1:10] would select the 10 least connected individuals and V(network)[(vcount(network) - 9):vcount(network)] would select the 10 most connected individuals.\nThe version of vaccinate_network() in the solutions for this practical goes a step further by allowing intermediate values for k between -1 and +1, with intermediate values moving from the extreme of vaccinating only the least-connected (\\(k = -1\\)) to vaccinating at random (\\(k = 0\\)) to vaccinating only the most-connected (\\(k = 1\\)). There are lots of different ways of doing this, but the way the practical solution does it is by first vaccinating the \\(nv\\) most connected individuals if k is positive, or the \\(nv\\) least connected individuals if \\(k\\) is negative, then randomly shuffling the vaccination status of a fraction \\(1 - |k|\\) of all individuals. Check the solutions if you like, but you can also try implementing this (or another way) yourself.\n\n\nSummarize results from multiple runs\nSince the results of a network model can vary a lot from run to run, it is helpful to be able to easily run the model many times for the same starting conditions and summarize the results. Here is one way you might extend the run_model() function to generate epidemic curves for each model run, and create a new function run_scenario() to run the model multiple times with the same parameters:\n\n# Run the transmission model on the network with maximum simulation time t_max\n# and transmission probability p; plot the network as the model is running if\n# animate = TRUE.\nrun_model &lt;- function(net, t_max, p, animate = FALSE)\n{\n    # Plot network degree\n    if (animate) {\n        plot_degree(net)\n        Sys.sleep(2.0)\n    }\n\n    # Set up results\n    dt &lt;- list()\n\n    # Iterate over each time step\n    for (t in 0:t_max)\n    {\n        # Store results\n        dt[[length(dt) + 1]] &lt;- data.table(\n            S = sum(V(net)$state == \"S\"),\n            I = sum(V(net)$state == \"I\"),\n            R = sum(V(net)$state == \"R\"),\n            V = sum(V(net)$state == \"V\")\n        )\n\n        # Plot current state\n        if (animate) {\n            Sys.sleep(0.5)\n            plot_state(net)\n        }\n        \n        # Stop early if no infectious individuals are left\n        if (!any(V(net)$state == \"I\")) {\n            break;\n        }\n\n        # Run one step of the network model\n        net &lt;- network_step(net, p)\n    }\n    \n    # Return the epi curve, including empirical calculation of Rt\n    results &lt;- rbindlist(dt, idcol = \"t\")\n    results$Rt &lt;- results$I / shift(results$I, 1) # new infections per new infection last time step\n    return (results)\n}\n\n# Run the model nsim times with parameters in params (n, d, v, k, t_max, p),\n# showing the animated network the first nanim times, and returning a data.table\n# with the results of each simulation.\nrun_scenario &lt;- function(params, nsim, nanim = 1)\n{\n    results &lt;- list()\n    \n    for (sim in 1:nsim)\n    {\n        net &lt;- create_network(params$n, params$power)\n        net &lt;- vaccinate_network(net, params$v, params$k)\n\n        results[[sim]] &lt;- run_model(net, params$t_max, params$p, animate = sim &lt;= nanim)\n        \n        cat(\".\")\n    }\n    cat(\"\\n\");\n    \n    results &lt;- rbindlist(results, idcol = \"run\")\n    return (results)\n}\n\nparams &lt;- list(\n    n = 500,\n    d = 0,\n    p = 0.8,\n    v = 0.3,\n    k = 0,\n    t_max = 100\n)\n\nx &lt;- run_scenario(params, nsim = 5, nanim = 0)\n\n.....\n\nggplot(x) +\n    geom_line(aes(x = t, y = R, group = run))\n\n\n\n\n\n\n\n\n\nHow does the vaccine-risk association parameter k affect the final size of the epidemic when averaged over 50 different model runs?\n\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "03_DiscreteDeterministic_solutions.html",
    "href": "03_DiscreteDeterministic_solutions.html",
    "title": "03. Discrete Time Deterministic Models: Solutions",
    "section": "",
    "text": "Click here to return to the practical."
  },
  {
    "objectID": "03_DiscreteDeterministic_solutions.html#a.-sir-model-from-lecture",
    "href": "03_DiscreteDeterministic_solutions.html#a.-sir-model-from-lecture",
    "title": "03. Discrete Time Deterministic Models: Solutions",
    "section": "A. SIR model from lecture",
    "text": "A. SIR model from lecture\n\nA.1 Implement the SIR model from the slides and plot the proportion of the population that is infectious.\nAnswer:\n\ntime_sir &lt;- seq(0, 20, by = 1)\ny_sir &lt;- matrix(data = NA,\n                nrow = length(time_sir),\n                ncol = 3)\n\nupdate_sir &lt;- function(t, y, parms){\n    beta  &lt;- parms[\"beta\"]\n    gamma &lt;- parms[\"gamma\"]\n    \n    out &lt;- c(-beta*y[1]*y[2],\n             beta*y[1]*y[2] - gamma*y[2],\n             + gamma*y[2])\n    \n    return(out)\n}\n\nparms_sir &lt;- c(beta = 1.3,\n               gamma = 0.23)\n\n# initial values at t=0\ny_sir[1, ] &lt;- c(0.99, 0.01, 0)\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- y_sir[i-1,] +\n        update_sir(time_sir[i],\n                   y_sir[i-1, ],\n                   parms_sir)\n}\n\nplot(x = time_sir, y = y_sir[,2], ylim = c(0,1))\n\n\n\n\n\n\n\n\nA.1.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nAnswer: After approximately 7 days, the proportion infectious is 0.6.\nA.1.(b) Approximately how long does it take for the susceptibles to go to 0?\nAnswer: After 13 days, the proportion susceptible is below 0.001\n\n\nA.2 Change the mean time spent infectious from 4.35 days to 2 days, keeping the rate of transmission the same.\nA.2.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nAnswer: After 8 days, the proportion infectious is 0.3\nA.2.(b) Approximately how long does it take for the susceptibles to go to 0?\nAnswer: After 20 days, the proportion susceptible is still above 0.05\n\nparms_sir &lt;- c(beta = 1.3,\n               gamma = 1/2)\n\ny_sir[1, ] &lt;- c(0.99, 0.01, 0)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- y_sir[i-1,] +\n        update_sir(time_sir[i],\n                   y_sir[i-1, ],\n                   parms_sir)\n}\n\nplot(x = time_sir, y = y_sir[,2], ylim = c(0,1))\n\n\n\nA.3 Change the mean time spent infectious back to 4.35 days and set the transmission rate to be half what is has been\nA.3.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nAnswer: After 14 days, the proportion infectious is approximately 0.31\nA.3.(b) Approximately how long does it take for the susceptibles to go to 0?\nAnswer: Even after 20 days, the susceptible group is 0.1 of the population\n\nparms_sir &lt;- c(beta = 1.3/2,\n               gamma = 0.23)\n\ny_sir[1, ] &lt;- c(0.99, 0.01, 0)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- y_sir[i-1,] +\n        update_sir(time_sir[i],\n                   y_sir[i-1, ],\n                   parms_sir)\n}\n\nplot(x = time_sir, y = y_sir[,2], ylim = c(0,1))"
  },
  {
    "objectID": "03_DiscreteDeterministic_solutions.html#b.-sir-model",
    "href": "03_DiscreteDeterministic_solutions.html#b.-sir-model",
    "title": "03. Discrete Time Deterministic Models: Solutions",
    "section": "B. SIR model",
    "text": "B. SIR model\n\nB.1 Incorporating births\nAdapt the SIR model in the slides to incorporate birth of new susceptibles proportional to the sum of the S, I, and R populations. Balance these new births with deaths from each of the S I and R groups, with both the per capita birth and death rates being delta=0.01\nAnswer:\n\nnew_sir &lt;- function(t, y, parms){\n    S &lt;- y[1]\n    I &lt;- y[2]\n    R &lt;- y[3]\n    \n    \n    beta  &lt;- parms[\"beta\"]\n    gamma &lt;- parms[\"gamma\"]\n    delta &lt;- parms[\"delta\"]\n    \n    out &lt;- c(-beta*y[1]*y[2] + delta*sum(y) - delta*S,\n             beta*y[1]*y[2] - gamma*y[2] - delta*I,\n             gamma*y[2] - delta*R)\n    \n    return(out)\n}\n\nnew_parms &lt;- c(beta = 1.3, gamma = 0.23, delta = 0.1)\n\ntime_sir &lt;- seq(0,20,by=1)\ny_sir    &lt;- matrix(data = NA, ncol = 3, nrow = length(time_sir))\ny_sir[1, ] &lt;- c(0.99, 0.01, 0)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- y_sir[i-1,] +\n        new_sir(time_sir[i],\n                y_sir[i-1, ],\n                new_parms)\n}\n\nplot(x = time_sir, y = y_sir[,2], ylim = c(0,1))\n\n\n\n\n\n\n\n\n\n\nB.2 Visualising for the whole population\nCalculate N(t) = S(t) + I(t) the total number of alive individuals. Make a plot of S(t), I(t), R(t) and N(t). Your function N(t) should be constant at 1 for all values of t. If this is not the case, ensure the model contains births of new S proportional to N, and deaths of each of S, I, and R.\nAnswer:\n\n\n\n\n\n\n\n\n\nB.2.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nAnswer: After 8 days, the proportion infectious is approximately 0.54\nB.2.(b) Approximately how long does it take for the susceptibles to go to 0?\nAnswer: The susceptible population does not go to 0, due to the birth of new susceptibles\n\n\nB.3 Discussion\nDiscuss what happens to the population of S, I, and R over time. Consider the parameters of the model, what they represent, and whether the assumptions they represent are realistic.\nAnswer:\nS(t): The population decreases to a minimum at about 9 days but the birth of new susceptibles prevents it reaching 0. It will continue to increase to a stable equilibrium.\nI(t): The population increases to a peak and then the recovery process causes the population to decrease. The infectious population does not decrease down to 0 as before as the new susceptibles will get infected. The long-term behaviour is a stable equilibrium.\nR(t): The recovered population increases to a peak and then decreases to a stable equilibrium as the recovered population die and are replaced with susceptibles. There’s an implicit assumption in the model that transmission is not passed to newborns; i.e. only susceptibles are born. This is likely a reasonable assumption to make for many diseases. As we are dealing the proportion of the total population it’s reasonable to keep N(t) constant, but the birth and death rates may not be reasonable. Instead, we might be best to allow them to grow indefinitely (or, if the death rate is higher, decrease to 0).\nAdditionally, we assume that the entire population is capable of giving birth to newborns, and that the disease does not cause a loss of life expectancy."
  },
  {
    "objectID": "05_Metapop_solutions.html",
    "href": "05_Metapop_solutions.html",
    "title": "05. Metapopulations with ODEs: Solutions",
    "section": "",
    "text": "Click here to return to the practical.\nThe code below has been written to solve a Susceptible-Infected-Recovered model with two populations. Familiarise yourself with the expanded model before moving onto the activities that follow. Note: the compartments C1 and C2 reflect the cumulative numbers of people infected. This will be used later on.\n# Load in the deSolve package\nlibrary(deSolve)\n# If the package is not installed, install using the install.packages() function\n\n# Define model function \nSIR_metapop_model &lt;- function(times, state, parms){\n  ## Define variables\n  S1 &lt;- state[\"S1\"]\n  I1 &lt;- state[\"I1\"]\n  R1 &lt;- state[\"R1\"]\n  C1 &lt;- state[\"C1\"]\n  N1 &lt;- S1 + I1 + R1\n  S2 &lt;- state[\"S2\"]\n  I2 &lt;- state[\"I2\"]\n  R2 &lt;- state[\"R2\"]\n  C2 &lt;- state[\"C2\"]\n  N2 &lt;- S2 + I2 + R2\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  alpha &lt;- parms[\"alpha\"]\n  lambda1 &lt;- (beta * I1 / N1 + alpha * beta * I2 / N2)\n  lambda2 &lt;- (beta * I2 / N2 + alpha * beta * I1 / N1)\n  # Define differential equations\n  dS1 &lt;- - lambda1 * S1\n  dI1 &lt;- lambda1 * S1 - gamma * I1\n  dR1 &lt;- gamma * I1\n  dC1 &lt;- lambda1 * S1\n  dS2 &lt;- - lambda2 * S2\n  dI2 &lt;-  lambda2 * S2 - gamma * I2\n  dR2 &lt;- gamma * I2\n  dC2 &lt;- lambda2 * S2\n  res &lt;- list(c(dS1, dI1, dR1, dC1, dS2, dI2, dR2, dC2))\n  return(res)\n}\n\n# Define parameters  \nparameters &lt;- c( beta = 0.4, gamma = 0.1, alpha = 1)\n\n# Define time to run model\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN1 &lt;- 1000; N2 &lt;- 1000\nI1_0 &lt;- 1; I2_0 &lt;- 0\nR1_0 &lt;- 0; R2_0 &lt;- 0\nC1_0 &lt;- 0; C2_0 &lt;- 0\nS1_0  &lt;- N1 - I1_0\nS2_0  &lt;- N2 - I2_0\nstate &lt;- c(S1 = S1_0, I1 = I1_0, R1 = R1_0, C1 = C1_0, \n           S2 = S2_0, I2 = I2_0, R2 = R2_0, C2 = C2_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, \n                  times = times, \n                  func = SIR_metapop_model, \n                  parms = parameters,\n                  method = rk4)\n\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar(mfrow = c(1, 1))\nplot(output$time, output$I1, type = \"l\", col = 4, lwd = 2, ylim = c(0, N1),\n      xlab = \"Time\", ylab = \"Number\", main = \"\")\nlines(output$time, output$I2, lwd = 2, col = 2, type = \"l\")\nlegend(\"topright\", \n       legend = c(\"Infected in population 1\", \n                  \"Infected in population 2\"),\n       lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "05_Metapop_solutions.html#question-a",
    "href": "05_Metapop_solutions.html#question-a",
    "title": "05. Metapopulations with ODEs: Solutions",
    "section": "Question A",
    "text": "Question A\nWhen you simulate the above model, you’ll notice that currently the epidemics are nearly identical in the two populations. Update the model parameters so the transmission rate between the two populations is equal to 5% of the transmission rate within each population. What happens to the size and timing of the epidemics?\nAnswer: Epidemic is delayed with slightly smaller peak in population 2 because takes time for infection to spread.\n\nparameters &lt;- c( beta = 0.4, gamma = 0.1, alpha = 0.05)"
  },
  {
    "objectID": "05_Metapop_solutions.html#question-b",
    "href": "05_Metapop_solutions.html#question-b",
    "title": "05. Metapopulations with ODEs: Solutions",
    "section": "Question B",
    "text": "Question B\nWhat happens if the epidemic starts with 10 people infected in both populations? Why does this happen?\nAnswer: Epidemics are identical because initial conditions are the same. Although there is some connectivity between populations, it is symmetrical, so same dynamics in both."
  },
  {
    "objectID": "05_Metapop_solutions.html#question-c",
    "href": "05_Metapop_solutions.html#question-c",
    "title": "05. Metapopulations with ODEs: Solutions",
    "section": "Question C",
    "text": "Question C\nThe model is currently set up to record the number of cumulative cases in each population (i.e. C1 and C2). The below code will plot these cumulative numbers of cases. Update the code so you are plotting incidence, i.e. new cases appearing over time, rather than cumulative cases.\n\npar(mfrow = c(1, 1))\nplot(output$time, output$C1, type = \"l\", col = 4, lwd = 2, ylim = c(0, N1+100), \n     xlab = \"Time\", ylab = \"Number\", main = \"\")\nlines( output$time, output$C2, lwd = 2, col = 2, type = \"l\")\nlegend(\"topright\", \n       legend = c(\"Cumulative cases in population 1\", \n                  \"Cumulative cases in population 2\"),\n       lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\nHint: Create a new variable that calculates the difference between adjacent timesteps, i.e. C1[2:t] - C1[1:(t-1)]\nAnswer:\n\ncases1 &lt;- tail(output$C1,-1) - head(output$C1,-1)\ncases2 &lt;- tail(output$C2,-1) - head(output$C2,-1)\ntime_cases &lt;- tail(output$time,-1)\n\nplot( time_cases, cases1, type = \"l\", col = 4, lwd = 2, ylim = c(0, N1+100),\n      xlab = \"Time\", ylab = \"Number\", main = \"\")\nlines( time_cases, cases2, lwd = 2, col = 2, type = \"l\")\nlegend(\"topright\", legend = c(\"Cases in population 1\", \"Cases in population 2\"),\n       lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "05_Metapop_solutions.html#question-d",
    "href": "05_Metapop_solutions.html#question-d",
    "title": "05. Metapopulations with ODEs: Solutions",
    "section": "Question D",
    "text": "Question D\nWhat does the incidence look like if only 50% of the cases in population 2 are reported?\nHint: There are several ways to do this - some are easier than others.\nAnswer:\n\ncases2 &lt;- 0.5*cases2\n\nplot( time_cases, cases1, type = \"l\", col = 4, lwd = 2, ylim = c(0, N1+100),\n      xlab = \"Time\", ylab = \"Number\", main = \"\")\nlines( time_cases, cases2, lwd = 2, col = 2, type = \"l\")\nlegend(\"topright\", legend = c(\"Cases in population 1\", \"Cases in population 2\"),\n       lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "05_Metapop_solutions.html#question-e",
    "href": "05_Metapop_solutions.html#question-e",
    "title": "05. Metapopulations with ODEs: Solutions",
    "section": "Question E",
    "text": "Question E\nIf you have time, expand the model to include three populations (denoted 1, 2, 3). How would you model an epidemic where:\n\nmixing between population 1 and population 2 is 5% of the rate of mixing within these populations\nmixing between population 1 and population 3 is 10% of the rate of mixing within these populations\nthere is no mixing between population 2 and population 3\n\nAnswer:\n\n# Define model function\nSIR_metapop_model_3 &lt;- function(times, state, parms){\n  ## Define variables\n  S1 &lt;- state[\"S1\"]\n  I1 &lt;- state[\"I1\"]\n  R1 &lt;- state[\"R1\"]\n  C1 &lt;- state[\"C1\"]\n  N1 &lt;- S1 + I1 + R1\n\n  S2 &lt;- state[\"S2\"]\n  I2 &lt;- state[\"I2\"]\n  R2 &lt;- state[\"R2\"]\n  C2 &lt;- state[\"C2\"]\n  N2 &lt;- S2 + I2 + R2\n\n  S3 &lt;- state[\"S3\"]\n  I3 &lt;- state[\"I3\"]\n  R3 &lt;- state[\"R3\"]\n  C3 &lt;- state[\"C3\"]\n  N3 &lt;- S3 + I3 + R3\n\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  alpha1 &lt;- parms[\"alpha1\"]\n  alpha2 &lt;- parms[\"alpha2\"]\n  lambda1 &lt;- (beta * I1 / N1 + alpha1 * beta * I2 / N2 + alpha2 * beta * I3 / N3)\n  lambda2 &lt;- (beta * I2 / N2 + alpha1 * beta * I1 / N1)\n  lambda3 &lt;- (beta * I3 / N3 + alpha2 * beta * I1 / N1)\n\n  # Define differential equations\n  dS1 &lt;- - lambda1 * S1\n  dI1 &lt;- lambda1 * S1 - gamma * I1\n  dR1 &lt;- gamma * I1\n  dC1 &lt;- lambda1 * S1\n  dS2 &lt;- - lambda2 * S2\n  dI2 &lt;-  lambda2 * S2 - gamma * I2\n  dR2 &lt;- gamma * I2\n  dC2 &lt;- lambda2 * S2\n  dS3 &lt;- - lambda3 * S3\n  dI3 &lt;-  lambda3 * S3 - gamma * I3\n  dR3 &lt;- gamma * I3\n  dC3 &lt;- lambda3 * S3\n\n  res &lt;- list(c(dS1, dI1, dR1, dC1, dS2, dI2, dR2, dC2, dS3, dI3, dR3, dC3))\n  return(res)\n}\n\n# Define parameters\nparameters &lt;- c( beta = 0.4, gamma = 0.1, alpha1 = 0.05, alpha2 = 0.1)\n\n# Define time to run model\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN1 &lt;- 1000; N2 &lt;- 1000; N3 &lt;- 1000\nI1_0 &lt;- 1; I2_0 &lt;- 0; I3_0 &lt;- 0\nR1_0 &lt;- 0; R2_0 &lt;- 0; R3_0 &lt;- 0\nC1_0 &lt;- 0; C2_0 &lt;- 0; C3_0 &lt;- 0\nS1_0  &lt;- N1 - I1_0; S2_0  &lt;- N2 - I2_0; S3_0  &lt;- N3 - I3_0\nstate &lt;- c(S1 = S1_0, I1 = I1_0, R1 = R1_0, C1 = C1_0, S2 = S2_0, I2 = I2_0, \n           R2 = R2_0, C2 = C2_0, S3 = S3_0, I3 = I3_0, R3 = R3_0, C3 = C3_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, \n                  times = times, \n                  func = SIR_metapop_model_3, \n                  parms = parameters,\n                  method = rk4)\n\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar( mfrow = c(1, 1))\nplot( output$time, output$I1, type = \"l\", col = 4, lwd = 2, ylim = c(0, N1),\n      xlab = \"Time\", ylab = \"Number\", main = \"\")\nlines( output$time, output$I2, lwd = 2, col = 2, type = \"l\")\nlines( output$time, output$I3, lwd = 2, col = 3, type = \"l\")\nlegend(\"topright\", \n       legend = c(\"Infected in population 1\", \n                  \"Infected in population 2\",\n                  \"Infected in population 3\"),\n       lty = rep(1, 2), col = c(4, 2,3), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "06_SensitivitySampling_practical.html",
    "href": "06_SensitivitySampling_practical.html",
    "title": "06. Sensitivity Analysis & Sampling",
    "section": "",
    "text": "First, let’s run an ODE model. Download and open up the SIRmodel.R\n\n\nAnswer:\n\n\n\nAnswer:\n\n\n\nAnswer:\n# First let's clear our workspace, remove plots and load the libraries we need\nrm(list=ls())\ndev.off()\nlibrary(deSolve)\nlibrary(ggplot2)\n\n# Let's read in these functions so we have them to hand\n&lt;YOUR CODE HERE&gt;\n\n# Let's choose a beta value of 0.4 and a gamma value of 0.2\nmax.prevalence &lt;- solveODE(parameters &lt;- c(beta = 0.4, gamma = 0.2))\nprint(max.prevalence)\n\n# Now let's look at the effect of the maximum prevalence of the epidemic across \n# gamma = 0.1 -1.0 (increment on 0.1)\ngamma.vec &lt;- &lt;YOUR CODE HERE&gt;\n\n# initialise max/prevalence container\nmax.prevalence &lt;- vector()\n\n# Add in a loop to make this happen\n\n&lt;YOUR CODE HERE&gt;\n\nmp &lt;- solveODE(parameters = c(beta = 0.4, gamma = gamma.val),\nplot.all.results = FALSE)\nmax.prevalence &lt;- c(max.prevalence, mp)\n\n&lt;YOUR CODE HERE&gt;\n\n# Now we have our max.prevalence, we need to plot this against our \n# infectiousness duration - plot max.prevalence as a function of the \n# \\*infectiousness duration\\*\n\npar(new=FALSE)\npar(mfrow=c(1,1))\n\nplot(&lt;YOUR CODE HERE&gt;, \n     &lt;YOUR CODE HERE&gt;, \n     type = \"b\",\n     xlab = \"Infectiousness Duration (days)\",\n     ylab = \"Maximum Prevalence\",\n     main = \"One-way uncertainty analysis\")\n\n# Now try to increase the resolution of gamma to get a better idea of the \n# relationship but remember to clear max.prevalence first!\n\n&lt;YOUR CODE HERE&gt;\n\n\n\nAnswer:"
  },
  {
    "objectID": "06_SensitivitySampling_practical.html#one-way-sensitivity-analyses",
    "href": "06_SensitivitySampling_practical.html#one-way-sensitivity-analyses",
    "title": "06. Sensitivity Analysis & Sampling",
    "section": "",
    "text": "First, let’s run an ODE model. Download and open up the SIRmodel.R\n\n\nAnswer:\n\n\n\nAnswer:\n\n\n\nAnswer:\n# First let's clear our workspace, remove plots and load the libraries we need\nrm(list=ls())\ndev.off()\nlibrary(deSolve)\nlibrary(ggplot2)\n\n# Let's read in these functions so we have them to hand\n&lt;YOUR CODE HERE&gt;\n\n# Let's choose a beta value of 0.4 and a gamma value of 0.2\nmax.prevalence &lt;- solveODE(parameters &lt;- c(beta = 0.4, gamma = 0.2))\nprint(max.prevalence)\n\n# Now let's look at the effect of the maximum prevalence of the epidemic across \n# gamma = 0.1 -1.0 (increment on 0.1)\ngamma.vec &lt;- &lt;YOUR CODE HERE&gt;\n\n# initialise max/prevalence container\nmax.prevalence &lt;- vector()\n\n# Add in a loop to make this happen\n\n&lt;YOUR CODE HERE&gt;\n\nmp &lt;- solveODE(parameters = c(beta = 0.4, gamma = gamma.val),\nplot.all.results = FALSE)\nmax.prevalence &lt;- c(max.prevalence, mp)\n\n&lt;YOUR CODE HERE&gt;\n\n# Now we have our max.prevalence, we need to plot this against our \n# infectiousness duration - plot max.prevalence as a function of the \n# \\*infectiousness duration\\*\n\npar(new=FALSE)\npar(mfrow=c(1,1))\n\nplot(&lt;YOUR CODE HERE&gt;, \n     &lt;YOUR CODE HERE&gt;, \n     type = \"b\",\n     xlab = \"Infectiousness Duration (days)\",\n     ylab = \"Maximum Prevalence\",\n     main = \"One-way uncertainty analysis\")\n\n# Now try to increase the resolution of gamma to get a better idea of the \n# relationship but remember to clear max.prevalence first!\n\n&lt;YOUR CODE HERE&gt;\n\n\n\nAnswer:"
  },
  {
    "objectID": "06_SensitivitySampling_practical.html#monte-carlo-sampling",
    "href": "06_SensitivitySampling_practical.html#monte-carlo-sampling",
    "title": "06. Sensitivity Analysis & Sampling",
    "section": "(2) Monte Carlo Sampling",
    "text": "(2) Monte Carlo Sampling\nNow suppose that we have a previous epidemiological study that suggested that R0 has a mean value of 5, but uncertainty within the range of [-1, +1]. However, we still don’t know whether the infectiousness period is 1 day or 10 days. We will now use the functions in SIRmodel_R0.R to make a similar plot as above, but this time, incorporate the uncertainty of R0 for each discrete value of gamma. We’re going to first use a direct Monte Carlo Sampling method.\n# Read in our set of functions in SIRmodel_R0.R\n&lt;YOUR CODE HERE&gt;\n\n# First, let's set a fixed seed for the random number generator\n# this will allow us to run the code again and retrieve the same 'simulation'\nset.seed(2019)\n\n# Now, draw R0 1,000 times from a suitable distribution (e.g. normal)\nr0.all = &lt;YOUR CODE HERE&gt;\nsize.df = length(r0.all) * length(gamma.vec)\n\n# initialise max.prevalence again, this time it needs to be a dataframe \n# or a matrix\nmax.prevalence = data.frame(r0.value = vector(mode = \"numeric\", \n                                            length = size.df),\ngamma = vector(mode= \"numeric\", length = size.df),\nmax.prev = vector(mode= \"numeric\", length = size.df))\nindex = 0\n\n# create a loop over each of these R0 values in turn\nfor (r0.val in r0.all){\n# create a loop over each of these Gamma values in turn\n    for (gamma.val in gamma.vec){\n    index = index + 1\n    mp = solveODE_2(parameters = c(R0 = r0.val, gamma = gamma.val))\n    max.prevalence[index, \"r0.value\"] = r0.val\n    max.prevalence[index, \"gamma\"] = gamma.val\n    max.prevalence[index, \"max.prev\"] = mp\n    }\n}\n\n# Take a look at max.prevalence by using the 'head() function\nhead(max.prevalence)\n\n(e) How have we saved the output?\nAnswer:\nNow plot this output using the R function MCplot() in SIRmodel_R0.R\nMCplot(max.prevalence)\n\n\n(f) What conclusions can you draw from the plot?\nAnswer:"
  },
  {
    "objectID": "06_SensitivitySampling_practical.html#latin-hypercube-sampling-lhs-vs-monte-carlo-sampling",
    "href": "06_SensitivitySampling_practical.html#latin-hypercube-sampling-lhs-vs-monte-carlo-sampling",
    "title": "06. Sensitivity Analysis & Sampling",
    "section": "(3) Latin hypercube sampling (LHS) vs Monte Carlo Sampling",
    "text": "(3) Latin hypercube sampling (LHS) vs Monte Carlo Sampling\n# First let's load in the library we'll need for later\nlibrary(lhs)\n\n# We're going to first sample directly from a full distribution uniform \n# distribution from 0 to 1. How many samples will we need to take? \n# Let's try a few options and see how well they do\n\npar(mfrow=c(3,2))\nhist(rnorm(10))\nhist(rnorm(100))\nhist(rnorm(1000))\nhist(rnorm(10000))\nhist(rnorm(20000))\n\n# Now let's plot the sample sizes against the variance of the sample distribution\n\nplot(\n    c(10,100,1000,10000,50000,100000),\n    c(var(rnorm(10)), var(rnorm(100)), var(rnorm(1000)), var(rnorm(10000)), \n      var(rnorm(50000)), var(rnorm(100000))),\n    ylab = \"variance\", main = \"Variance of sampled normal\"\n    )\nabline(h = 1)\n\n# Let's now use 100 samples to see the difference between a Monte Carlo \n# sampling and a LHS sampling approach\n# Pick some small number of samples\nn &lt;- 100\n\n# First we're going to sample 100 times from a random sample\nmc_unif &lt;- runif(n)\n\n# 100 lh samples across 1 parameter\nlatin_unif &lt;- randomLHS(n, 1)\n\n# plot these two distribution\ndev.off()\npar(mfrow=c(3,2))\nhist(mc_unif)\nhist(latin_unif)\n\n# You can see how the Latin Hypercube does a great job of sampling evenly across \n# the distribution. Let's now sample from a Normal distribution using a random \n# monte carlo sample across the whole distribution.\nmc_norm &lt;- rnorm(n, mean = 0, sd = 1)\n\n# How do we sample using an LHS? We use the previous numbers generated from the \n# uniform LHS to draw samples from the Normal using the Inverse Cumulative \n# Sampling\nlatin_norm &lt;- qnorm(latin_unif, mean = 0, sd = 1)\n\n# plot these two normal distributions\nhist(mc_norm)\nhist(latin_norm)\n\n# the latin hypercube sample looks much better! Why does this work?\n# first let's look at the norm probability distibution\nx &lt;- seq(-6,6, by =0.1) # random variable X\nnormdens &lt;- dnorm(x, mean = 0, sd = 1) # prob distribution, f(X)\nnormcumul &lt;- pnorm(x, mean = 0, sd = 1) # cumulative distribution, F(X)\n\nplot(x, normdens, \"l\")\nplot(x, normcumul, \"l\")\n\n# Most of the density is in the middle range of values (-1 to 1).\n\n# So we want a method to sample from this more often than the other areas in \n# the distribution. Specifically, we want to sample values from X proportionally \n# to the probability of those values occuring. Let's generate some samples \n# between 0-1. These can be values on our Y-axis. Then, if we ask what is the \n# value of the cumulative distribution that corresponds to these uniform \n# values we are taking the inverse for illustration let's just choose 10 points.\n\nex_latin &lt;- randomLHS(10, 1)\n\n# which X values are given by using these as the Y value (denoted by \"X\"s)?\n\nabline(h = ex_latin, col = \"red\")\npoints(qnorm(ex_latin, mean = 0, sd = 1), y=rep(0,10), pc = \"x\")\n\n# You can see that the samples are clustered around the middle: in areas of X \n# with higher density, the gradient of the cumluative distribution (F(X)) will \n# be very steep, causing more values between 0 and 1 to map to this range of X \n# with high density That is, F\\^{-1}(R) = X where R is a uniform random number \n# between 0 and 1.\n\n# So, you can sample from any distribution whose cumluative function is \n# 'invertable' by plugging in uniform random numbers to the inverse cumulative \n# function of your new distribution. For more information check out: \n# https://en.wikipedia.org/wiki/Inverse_transform_sampling\n\n# Likewise, to perform LHS on a uni- or mulitvariate non-uniform distribution, \n# we can transform our LHS samples from a uniform distribution as above.\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "05_Metapop_practical.html",
    "href": "05_Metapop_practical.html",
    "title": "05. Metapopulations with ODEs",
    "section": "",
    "text": "The code below has been written to solve a Susceptible-Infected-Recovered model with two populations. Familiarise yourself with the expanded model before moving onto the activities that follow. Note: the compartments C1 and C2 reflect the cumulative numbers of people infected. This will be used later on.\n# Load in the deSolve package\nlibrary(deSolve)\n# If the package is not installed, install using the install.packages() function\n\n# Define model function \nSIR_metapop_model &lt;- function(times, state, parms){\n  ## Define variables\n  S1 &lt;- state[\"S1\"]\n  I1 &lt;- state[\"I1\"]\n  R1 &lt;- state[\"R1\"]\n  C1 &lt;- state[\"C1\"]\n  N1 &lt;- S1 + I1 + R1\n  S2 &lt;- state[\"S2\"]\n  I2 &lt;- state[\"I2\"]\n  R2 &lt;- state[\"R2\"]\n  C2 &lt;- state[\"C2\"]\n  N2 &lt;- S2 + I2 + R2\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  alpha &lt;- parms[\"alpha\"]\n  lambda1 &lt;- (beta * I1 / N1 + alpha * beta * I2 / N2)\n  lambda2 &lt;- (beta * I2 / N2 + alpha * beta * I1 / N1)\n  # Define differential equations\n  dS1 &lt;- - lambda1 * S1\n  dI1 &lt;- lambda1 * S1 - gamma * I1\n  dR1 &lt;- gamma * I1\n  dC1 &lt;- lambda1 * S1\n  dS2 &lt;- - lambda2 * S2\n  dI2 &lt;-  lambda2 * S2 - gamma * I2\n  dR2 &lt;- gamma * I2\n  dC2 &lt;- lambda2 * S2\n  res &lt;- list(c(dS1, dI1, dR1, dC1, dS2, dI2, dR2, dC2))\n  return(res)\n}\n\n# Define parameters  \nparameters &lt;- c( beta = 0.4, gamma = 0.1, alpha = 1)\n\n# Define time to run model\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN1 &lt;- 1000; N2 &lt;- 1000\nI1_0 &lt;- 1; I2_0 &lt;- 0\nR1_0 &lt;- 0; R2_0 &lt;- 0\nC1_0 &lt;- 0; C2_0 &lt;- 0\nS1_0  &lt;- N1 - I1_0\nS2_0  &lt;- N2 - I2_0\nstate &lt;- c(S1 = S1_0, I1 = I1_0, R1 = R1_0, C1 = C1_0, \n           S2 = S2_0, I2 = I2_0, R2 = R2_0, C2 = C2_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, \n                  times = times, \n                  func = SIR_metapop_model, \n                  parms = parameters,\n                  method = rk4)\n\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar(mfrow = c(1, 1))\nplot(output$time, output$I1, type = \"l\", col = 4, lwd = 2, ylim = c(0, N1),\n      xlab = \"Time\", ylab = \"Number\", main = \"\")\nlines(output$time, output$I2, lwd = 2, col = 2, type = \"l\")\nlegend(\"topright\", \n       legend = c(\"Infected in population 1\", \n                  \"Infected in population 2\"),\n       lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "05_Metapop_practical.html#question-a",
    "href": "05_Metapop_practical.html#question-a",
    "title": "05. Metapopulations with ODEs",
    "section": "Question A",
    "text": "Question A\nWhen you simulate the above model, you’ll notice that currently the epidemics are nearly identical in the two populations. Update the model parameters so the transmission rate between the two populations is equal to 5% of the transmission rate within each population. What happens to the size and timing of the epidemics?"
  },
  {
    "objectID": "05_Metapop_practical.html#question-b",
    "href": "05_Metapop_practical.html#question-b",
    "title": "05. Metapopulations with ODEs",
    "section": "Question B",
    "text": "Question B\nWhat happens if the epidemic starts with 10 people infected in both populations? Why does this happen?"
  },
  {
    "objectID": "05_Metapop_practical.html#question-c",
    "href": "05_Metapop_practical.html#question-c",
    "title": "05. Metapopulations with ODEs",
    "section": "Question C",
    "text": "Question C\nThe model is currently set up to record the number of cumulative cases in each population (i.e. C1 and C2). The below code will plot these cumulative numbers of cases. Update the code so you are plotting incidence, i.e. new cases appearing over time, rather than cumulative cases.\n\npar(mfrow = c(1, 1))\nplot(output$time, output$C1, type = \"l\", col = 4, lwd = 2, ylim = c(0, N1+100), \n     xlab = \"Time\", ylab = \"Number\", main = \"\")\nlines( output$time, output$C2, lwd = 2, col = 2, type = \"l\")\nlegend(\"topright\", \n       legend = c(\"Cumulative cases in population 1\", \n                  \"Cumulative cases in population 2\"),\n       lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\nHint: Create a new variable that calculates the difference between adjacent timesteps, i.e. C1[2:t] - C1[1:(t-1)]"
  },
  {
    "objectID": "05_Metapop_practical.html#question-d",
    "href": "05_Metapop_practical.html#question-d",
    "title": "05. Metapopulations with ODEs",
    "section": "Question D",
    "text": "Question D\nWhat does the incidence look like if only 50% of the cases in population 2 are reported?\nHint: There are several ways to do this - some are easier than others."
  },
  {
    "objectID": "05_Metapop_practical.html#question-e",
    "href": "05_Metapop_practical.html#question-e",
    "title": "05. Metapopulations with ODEs",
    "section": "Question E",
    "text": "Question E\nIf you have time, expand the model to include three populations (denoted 1, 2, 3). How would you model an epidemic where:\n\nmixing between population 1 and population 2 is 5% of the rate of mixing within these populations\nmixing between population 1 and population 3 is 10% of the rate of mixing within these populations\nthere is no mixing between population 2 and population 3\n\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "08_StochasticIBM_practical.html",
    "href": "08_StochasticIBM_practical.html",
    "title": "08. Stochastic Individual-Based Models",
    "section": "",
    "text": "In this practical, we will implement a stochastic individual-based model of SARS-CoV-2 transmission."
  },
  {
    "objectID": "08_StochasticIBM_practical.html#practical-1.-an-individual-based-seir-model-of-sars-cov-2-transmission",
    "href": "08_StochasticIBM_practical.html#practical-1.-an-individual-based-seir-model-of-sars-cov-2-transmission",
    "title": "08. Stochastic Individual-Based Models",
    "section": "Practical 1. An individual-based SEIR model of SARS-CoV-2 transmission",
    "text": "Practical 1. An individual-based SEIR model of SARS-CoV-2 transmission\nOpen up the file 01_IBM_SEIR.R. This is code with the skeleton of a stochastic individual-based SEIR model with the following model diagram:\n\nHere, the force of infection is \\(\\beta I/N\\), the latent period duration is \\(1/\\delta\\), the infectious period is \\(1/\\gamma\\) and the waning rate is \\(\\omega\\). (Symbol names: \\(\\beta\\) = beta, \\(\\delta\\) = delta, \\(\\gamma\\) = gamma, \\(\\omega\\) = omega.)\nThe rest of this section goes through each part of the script, with questions to check your understanding. Remember, you can consult the practical solutions if you are stuck.\n\n# Individual-based SARS-CoV-2 transmission model, practical 1\nlibrary(ggplot2)\n\n\n## Model parameters\nbeta &lt;- 0.5        # Transmission parameter\ndelta &lt;- 1 / 2.5   # Rate of transitioning out of latent state\ngamma &lt;- 1 / 5     # Rate of transitioning out of infectious state\nomega &lt;- 1 / 180   # Rate of waning immunity\n\ndt &lt;- 1            # Time step of simulation (1 day)\ndays &lt;- 365        # Duration of simulation (365 days)\nsteps &lt;- days / dt # Total number of time steps\nn &lt;- 1000          # Population size\n\n\nWhat is the unit of time (seconds, days, weeks?) for this model? What have we used as the average duration of the latent period, the average duration of the infectious period, and the average duration of immunity?\n\n\n## Data frame to store simulation results\nresults &lt;- data.frame(ts = 1:steps, S = 0, E = 0, I = 0, R = 0)\n\nWe will use this data frame to track the dynamics of the system over time, including the number of people in state S, E, I, and R for each time step. After you run this line, inspect the data frame (type “results” at the prompt) to make sure you understand its structure.\n\n## Initialize simulation\n\n# Set the seed for the pseudorandom number generator, for reproducibility\nset.seed(12345)\n\n# Since this is an individual-based model, we track the properties of all n\n# individuals in the simulation. One kind of property we can track is a state,\n# such as S (susceptible), E (exposed), I (infectious), or R (recovered). We\n# will store each individual's state as a string, either \"S\", \"E\", \"I\", or \"R\".\n\nstate &lt;- rep(\"S\", n)   # Each individual's state: start with all susceptible\nstate[1:10] &lt;- \"E\"     # Start 10 individuals in the \"exposed\" state\n\nThis section begins with a call to set.seed, which should be familiar from previous practicals, to ensure we can reproduce the same sequence of random numbers for our simulation. Then the state vector is initialized.\n\nWhat is in the state vector at the end of this section? Why have we set some individuals to state “E”?\n\n\n## Run simulation\n\n# We'll use the built-in function txtProgressBar to track the simulation's\n# progress. Really helps for planning coffee breaks! It needs to know the\n# minimum and maximum values to expect, and style = 3 tells it to report the\n# percentage complete.\nbar &lt;- txtProgressBar(min = 1, max = steps, style = 3)\n\n# Loop over each time step . . .\nfor (ts in 1:steps) {\n    # Calculate the force of infection\n    lambda &lt;- beta * sum(state == \"I\") / n\n\n    # Loop through each individual . . .\n    for (i in 1:n) {\n        if (state[i] == \"S\") {\n            # Transition S -&gt; E (infection) at rate lambda\n            if (runif(1) &lt; 1 - exp(-lambda * dt)) {\n                state[i] &lt;- \"E\"\n            }\n        } else if (state[i] == \"E\") {\n            #### Fill in the rest: Transition E -&gt; I (latent to infectious) at\n            #### rate delta, transition I -&gt; R (infectious to recovered) at rate\n            #### gamma, and transition R -&gt; S (waning of immunity) at rate omega\n            ...\n        } else if (...) {\n            ...\n        }\n    }\n\n    # Save population state for this time step\n    results[ts, \"S\"] &lt;- sum(state == \"S\")\n    ##### Fill in the rest for states E, I, and R\n    results[ts, \"E\"] &lt;- ...\n    ...\n\n    # Update progress bar; close progress bar if we are finished\n    setTxtProgressBar(bar, ts)\n    if (ts == steps) {\n        close(bar)\n    }\n}\n\nThis section starts by setting up a progress bar using txtProgressBar. The details of how this works are not critical, but you should see the progress bar displayed in the R console when you run the main for loop for the simulation.\nThen the simulation’s main for loop happens. The contents of this for loop happen once for every value of ts in 1, 2, 3, …, steps. There are four parts of the for loop.\nThe first part calculates the force of infection, lambda.\n\nPart of this calculation for lambda includes the expression sum(state == \"I\"). What does this expression do?\n\nThe second part loops through each individual i and executes their state transitions. The S \\(\\rightarrow\\) E transition has been filled in for you, but you will need to fill in the E \\(\\rightarrow\\) I, I \\(\\rightarrow\\) R, and R \\(\\rightarrow\\) S transitions yourself.\n\nWhat does the expression runif(1) &lt; 1 - exp(-lambda * dt) do?\n\nThe third part saves the current state of the population (number of individuals in the S, E, I, and R states) into the results data frame. S has been completed, but you will need to fill in the details for E, I, and R.\nFinally, the fourth part of the for loop updates the progress bar.\n\n## Plot simulation results\nggplot(results) +\n  geom_line(aes(x = ts, y = S, colour = \"S\")) +\n  geom_line(aes(x = ts, y = E, colour = \"E\")) +\n  geom_line(aes(x = ts, y = I, colour = \"I\")) +\n  geom_line(aes(x = ts, y = R, colour = \"R\"))\n\nThe final section of the script plots what is in the results data frame using ggplot.\n\nWhat does the plot show? How many epidemics are there over the time period simulated?\nIf you re-run all the code from the line ## Initialize simulation down to the end of the file, the simulation will run again and, since the same value is used for set.seed, you should see the same results. But different seeds can produce different results. What happens if you use set.seed(123456) instead of 12345? Try a few other values in set.seed to explore the randomness exhibited by the model."
  },
  {
    "objectID": "08_StochasticIBM_practical.html#practical-2.-adding-more-complex-dynamics-to-the-model",
    "href": "08_StochasticIBM_practical.html#practical-2.-adding-more-complex-dynamics-to-the-model",
    "title": "08. Stochastic Individual-Based Models",
    "section": "Practical 2. Adding more complex dynamics to the model",
    "text": "Practical 2. Adding more complex dynamics to the model\nOpen up the file 09_StochasticIBM/02_RevIBM.R. This is the working SEIR model from Practical 1, with a few changes as detailed below.\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "00_PreCourseMaterial.html",
    "href": "00_PreCourseMaterial.html",
    "title": "Pre-course material",
    "section": "",
    "text": "We will be making use of R programming using RStudio in this course. There will be lots of variation in how much R experience each student will have, so we have compiled some pre-course material to allow everyone to get up to the minimal level required to fully participate and enjoy the course. \nEach practical P01 - P05 below comes with a prerecorded lecture and an associated practical (except P03). Before you get started, please make sure you download R and Rstudio (local version - free) here.\n\nP01 - Introduction to R: Slides, Practical, Recording - part 1, part 2, part 3\nP02 - Programming skills, more R fun(ctionality): Slides, Practical, Recording\nP03 - Best (computational) practices: Slides, Practical\nP04 - Plotting model output with ggplot2: Slides, Practical, Recording\nP05 - Introduction to Git using Github: Slides, Practical, Recording\n\nYou are welcome to listen to any of the recorded lectures and complete any of the associated practicals regardless of your experience. However, we’ve made a list of some recommendations below to guide what is expected: \n\nIf you are new to R, please listen to lectures P01 / P02 / P03 / P04 and complete the associated practicals.\nFor those of you who have used R previously but feel a bit rusty, you may find P02 / P03 / P04 helpful to get you back up to speed. If you try P02 and feel you need some more explanation, go back to P01 and start there. \nIf you have never used ‘tidy data’ or ggplot then complete P04.\nIf you are new to Git and Github, please listen to lecture P05. \n\n\nOptional Further Reading and Exercises\nIf you would like additional practice with R, we recommend the following online resources:\n\nhttp://tryr.codeschool.com/\nhttps://monashdatafluency.github.io/r-intro-2/\nhttps://www.r-bloggers.com/how-to-learn-r-2/\nhttps://www.edx.org/course/introduction-to-r-for-data-science-2"
  },
  {
    "objectID": "03_DiscreteDeterministic_practical.html",
    "href": "03_DiscreteDeterministic_practical.html",
    "title": "03. Discrete Time Deterministic Models",
    "section": "",
    "text": "time_sir &lt;- seq(0, 20, by = 1)\n\ny_sir &lt;- matrix(data = NA,\n                nrow = length(time_sir),\n                ncol = 3)\n\nupdate_sir &lt;- function(t, y, parms){\n    beta  &lt;- parms[\"beta\"]\n    gamma &lt;- parms[\"gamma\"]\n\n    out &lt;- ???\n\n    return(out)\n}\n\nparms_sir &lt;- c(beta = 1.3,\n               gamma = 0.23)\n\n# initial values at t=0\n\ny_sir[1, ] &lt;- c(???, ???, ???)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(x = time_sir, y = y_sir[,2])\n\nA.1.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.1.(b) Approximately how long does it take for the susceptibles to go to 0?\n\n\n\nA.2.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.2.(b) Approximately how long does it take for the susceptibles to go to 0?\n\nparms_sir &lt;- c(beta = ???,\n               gamma = ???)\n\ny_sir[1, ] &lt;- ???\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(x = ???, y = ???, ylim = c(0,1))\n\n\n\n\nA.3.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.3.(b) Approximately how long does it take for the susceptibles to go to 0?\n\nparms_sir &lt;- ???\n\ny_sir[1, ] &lt;- c(0.99, 0.01, 0)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(???)"
  },
  {
    "objectID": "03_DiscreteDeterministic_practical.html#a.-sir-model-from-lecture",
    "href": "03_DiscreteDeterministic_practical.html#a.-sir-model-from-lecture",
    "title": "03. Discrete Time Deterministic Models",
    "section": "",
    "text": "time_sir &lt;- seq(0, 20, by = 1)\n\ny_sir &lt;- matrix(data = NA,\n                nrow = length(time_sir),\n                ncol = 3)\n\nupdate_sir &lt;- function(t, y, parms){\n    beta  &lt;- parms[\"beta\"]\n    gamma &lt;- parms[\"gamma\"]\n\n    out &lt;- ???\n\n    return(out)\n}\n\nparms_sir &lt;- c(beta = 1.3,\n               gamma = 0.23)\n\n# initial values at t=0\n\ny_sir[1, ] &lt;- c(???, ???, ???)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(x = time_sir, y = y_sir[,2])\n\nA.1.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.1.(b) Approximately how long does it take for the susceptibles to go to 0?\n\n\n\nA.2.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.2.(b) Approximately how long does it take for the susceptibles to go to 0?\n\nparms_sir &lt;- c(beta = ???,\n               gamma = ???)\n\ny_sir[1, ] &lt;- ???\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(x = ???, y = ???, ylim = c(0,1))\n\n\n\n\nA.3.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.3.(b) Approximately how long does it take for the susceptibles to go to 0?\n\nparms_sir &lt;- ???\n\ny_sir[1, ] &lt;- c(0.99, 0.01, 0)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(???)"
  },
  {
    "objectID": "03_DiscreteDeterministic_practical.html#b.-sir-model",
    "href": "03_DiscreteDeterministic_practical.html#b.-sir-model",
    "title": "03. Discrete Time Deterministic Models",
    "section": "B. SIR model",
    "text": "B. SIR model\n\nB.1 Incorporating births\nAdapt the SIR model in the slides to incorporate birth of new susceptibles proportional to the sum of the S, I, and R populations. Balance these new births with deaths from each of the S I and R groups, with both the per capita birth and death rates being delta=0.01\n\nnew_sir &lt;- function(t, y, parms){\n    \n    beta  &lt;- parms[\"beta\"]\n    gamma &lt;- parms[\"gamma\"]\n    delta &lt;- parms[\"delta\"]\n\n    ??? &lt;- ???\n    ??? &lt;- ???\n    ??? &lt;- ???    \n        \n    return(???)\n    \n}\n\nnew_parms &lt;- ???\n\n\n\nB.2 Visualising for the whole population\nCalculate N(t) = S(t) + I(t) the total number of alive individuals. Make a plot of S(t), I(t), R(t) and N(t). Your function N(t) should be constant at 1 for all values of t. If this is not the case, ensure the model contains births of new S proportional to N, and deaths of each of S, I, and R.\n\ny_sir &lt;- cbind(y_sir, rowSums(y_sir))\npar(mfrow = c(2,2))\n\nfor (i in 1:ncol(y_sir)){\n\n    plot(y_sir[,i] ~ time_sir, type = \"p\", \n         xlab = \"Time (years)\")\n\n}\n\nB.2.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nB.2.(b) Approximately how long does it take for the susceptibles to go to 0?\n\n\nB.3 Discussion\nDiscuss what happens to the population of S, I, and R over time. Consider the parameters of the model, what they represent, and whether the assumptions they represent are realistic.\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "10_StochasticContinuous_practical.html",
    "href": "10_StochasticContinuous_practical.html",
    "title": "10. Stochastic Continuous Models",
    "section": "",
    "text": "time_sir &lt;- seq(0, 20, by = 1)\n\ny_sir &lt;- matrix(data = NA,\n                nrow = length(time_sir),\n                ncol = 3)\n\nupdate_sir &lt;- function(t, y, parms){\n    beta  &lt;- parms[\"beta\"]\n    gamma &lt;- parms[\"gamma\"]\n\n    out &lt;- ???\n\n    return(out)\n}\n\nparms_sir &lt;- c(beta = 1.3,\n               gamma = 0.23)\n\n# initial values at t=0\n\ny_sir[1, ] &lt;- c(???, ???, ???)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(x = time_sir, y = y_sir[,2])\n\nA.1.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.1.(b) Approximately how long does it take for the susceptibles to go to 0?\n\n\n\nA.2.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.2.(b) Approximately how long does it take for the susceptibles to go to 0?\n\nparms_sir &lt;- c(beta = ???,\n               gamma = ???)\n\ny_sir[1, ] &lt;- ???\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(x = ???, y = ???, ylim = c(0,1))\n\n\n\n\nA.3.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.3.(b) Approximately how long does it take for the susceptibles to go to 0?\n\nparms_sir &lt;- ???\n\ny_sir[1, ] &lt;- c(0.99, 0.01, 0)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(???)\n\n\n\n\n\n\n\nAdapt the SIR model in the slides to incorporate birth of new susceptibles proportional to the sum of the S, I, and R populations. Balance these new births with deaths from each of the S I and R groups, with both the per capita birth and death rates being delta=0.01\n\nnew_sir &lt;- function(t, y, parms){\n    \n    beta  &lt;- parms[\"beta\"]\n    gamma &lt;- parms[\"gamma\"]\n    delta &lt;- parms[\"delta\"]\n\n    ??? &lt;- ???\n    ??? &lt;- ???\n    ??? &lt;- ???    \n        \n    return(???)\n    \n}\n\nnew_parms &lt;- ???\n\n\n\n\nCalculate N(t) = S(t) + I(t) the total number of alive individuals. Make a plot of S(t), I(t), R(t) and N(t). Your function N(t) should be constant at 1 for all values of t. If this is not the case, ensure the model contains births of new S proportional to N, and deaths of each of S, I, and R.\n\ny_sir &lt;- cbind(y_sir, rowSums(y_sir))\npar(mfrow = c(2,2))\n\nfor (i in 1:ncol(y_sir)){\n\n    plot(y_sir[,i] ~ time_sir, type = \"p\", \n         xlab = \"Time (years)\")\n\n}\n\nB.2.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nB.2.(b) Approximately how long does it take for the susceptibles to go to 0?\n\n\n\nDiscuss what happens to the population of S, I, and R over time. Consider the parameters of the model, what they represent, and whether the assumptions they represent are realistic.\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "10_StochasticContinuous_practical.html#a.-sir-model-from-lecture",
    "href": "10_StochasticContinuous_practical.html#a.-sir-model-from-lecture",
    "title": "10. Stochastic Continuous Models",
    "section": "",
    "text": "time_sir &lt;- seq(0, 20, by = 1)\n\ny_sir &lt;- matrix(data = NA,\n                nrow = length(time_sir),\n                ncol = 3)\n\nupdate_sir &lt;- function(t, y, parms){\n    beta  &lt;- parms[\"beta\"]\n    gamma &lt;- parms[\"gamma\"]\n\n    out &lt;- ???\n\n    return(out)\n}\n\nparms_sir &lt;- c(beta = 1.3,\n               gamma = 0.23)\n\n# initial values at t=0\n\ny_sir[1, ] &lt;- c(???, ???, ???)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(x = time_sir, y = y_sir[,2])\n\nA.1.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.1.(b) Approximately how long does it take for the susceptibles to go to 0?\n\n\n\nA.2.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.2.(b) Approximately how long does it take for the susceptibles to go to 0?\n\nparms_sir &lt;- c(beta = ???,\n               gamma = ???)\n\ny_sir[1, ] &lt;- ???\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(x = ???, y = ???, ylim = c(0,1))\n\n\n\n\nA.3.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nA.3.(b) Approximately how long does it take for the susceptibles to go to 0?\n\nparms_sir &lt;- ???\n\ny_sir[1, ] &lt;- c(0.99, 0.01, 0)\n\nfor (i in 2:nrow(y_sir)){\n    y_sir[i,] &lt;- ???\n}\n\nplot(???)"
  },
  {
    "objectID": "10_StochasticContinuous_practical.html#b.-sir-model",
    "href": "10_StochasticContinuous_practical.html#b.-sir-model",
    "title": "10. Stochastic Continuous Models",
    "section": "",
    "text": "Adapt the SIR model in the slides to incorporate birth of new susceptibles proportional to the sum of the S, I, and R populations. Balance these new births with deaths from each of the S I and R groups, with both the per capita birth and death rates being delta=0.01\n\nnew_sir &lt;- function(t, y, parms){\n    \n    beta  &lt;- parms[\"beta\"]\n    gamma &lt;- parms[\"gamma\"]\n    delta &lt;- parms[\"delta\"]\n\n    ??? &lt;- ???\n    ??? &lt;- ???\n    ??? &lt;- ???    \n        \n    return(???)\n    \n}\n\nnew_parms &lt;- ???\n\n\n\n\nCalculate N(t) = S(t) + I(t) the total number of alive individuals. Make a plot of S(t), I(t), R(t) and N(t). Your function N(t) should be constant at 1 for all values of t. If this is not the case, ensure the model contains births of new S proportional to N, and deaths of each of S, I, and R.\n\ny_sir &lt;- cbind(y_sir, rowSums(y_sir))\npar(mfrow = c(2,2))\n\nfor (i in 1:ncol(y_sir)){\n\n    plot(y_sir[,i] ~ time_sir, type = \"p\", \n         xlab = \"Time (years)\")\n\n}\n\nB.2.(a) At approximately what time does the peak in infectious population occur and what proportion of the population is infectious?\nB.2.(b) Approximately how long does it take for the susceptibles to go to 0?\n\n\n\nDiscuss what happens to the population of S, I, and R over time. Consider the parameters of the model, what they represent, and whether the assumptions they represent are realistic.\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "04_ODEs_solutions.html",
    "href": "04_ODEs_solutions.html",
    "title": "04. Ordinary differential equations (ODEs): Solutions",
    "section": "",
    "text": "Click here to return to the practical.\n\n\nThe code below will solve the SI model with beta = 0.4 over 50 days with initial conditions S(0) = 99, I(0) = 1. Run the following lines including the plot() line to create a plot of the output\n\nlibrary(deSolve) # Load in the deSolve package. If the package is not installed, install using the install.packages() function\n# Define model function\n\nSI_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  N &lt;- S + I\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N\n  res &lt;- list(c(dS, dI))\n  return(res)\n}\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nstate &lt;- c( S = S_0, I = I_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SI_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar( mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines( output$time, output$I, lwd = 2, col = \"red\", type = \"l\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\"),\n       lty = c(1, 1), col = c(\"blue\", \"red\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\n\nAnswer: The number of infecteds as a higher intercept but same asymptote\n\n\n\nAnswer: The time steps of the model solution\n\n\n\nAnswer: Solution becomes less precise.\n\n\n\n\n\nNow, let’s solve a Susceptible-Infected-Recovered set of ordinary equations. There are now states; Susceptible, Infected, Recovered. Once infected people recover at a rate gamma = 0.1. The code for the model function ONLY is given below.\n\n# Define model function \nSIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n  N &lt;- S + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dI, dR ))\n  return(res)\n}\n\n\n\n\n\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4, gamma = 0.1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nR_0 &lt;- 0\nstate &lt;- c(S = S_0, I = I_0, R = R_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar(mfrow = c(1, 1))\nplot(output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n     xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend( \"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n        lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\nHint: Recall that for an SIR model, the basic reproduction number, R_0 = beta / gamma\nAnswer: The epidemic does not take off\n\nparameters &lt;- c(beta = 0.09, gamma = 0.1)\n\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe code below has been written to solve a Susceptible-Exposed-Infected-Recovered model. In the model individuals can be in one of four states. Once infected, susceptible individuals move to the exposed class. Exposed individuals become infectious at a rate delta = 0.14.\n\n\n\n\n\n# Define model function \nSEIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[1]\n  E &lt;- state[2]\n  I &lt;- state[3]\n  R &lt;- state[4]\n  N &lt;- S + E + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  delta &lt;- parms[\"delta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I ) / N\n  dE &lt;- (beta * S * I) / N - delta * E\n  dI &lt;- delta * E - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dE, dI, dR))\n  return(res)\n}\n\n# Define parameters  \nparameters &lt;- c( beta = 0.4, gamma = 0.1, delta = 0.14)\n\n# Define time to run model\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0  &lt;- N - I_0\nR_0 &lt;- 0\nstate &lt;- c(S = S_0, E = 0, I = I_0, R = R_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SEIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlines(output$time, output$E, lwd = 2, col = \"cyan\")\nlegend(\"topright\", legend =  c(\"Susceptible\", \"Exposed\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\", \"cyan\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere we assume that susceptible individuals are vaccinated at a rate v = 0.05. The vaccine is 100% effective, so once vaccinated, individuals cannot become infected. HINT: you will need to create a new class V, you can assume that the initial number of vaccinated individuals is 0.\n\n# Define model function \nSIRV_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n  V &lt;- state[\"V\"]\n  N &lt;- S + I + R + V\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  v &lt;- parms[\"v\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N - v * S\n  dI &lt;- (beta * S * I) / N - gamma * I\n  dR &lt;- gamma * I\n  dV &lt;- v * S\n  res &lt;- list(c(dS, dI, dR, dV))\n  return(res)\n}\n\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4, gamma = 0.1, v = 0.05)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nR_0 &lt;- 0\nV_0 &lt;- 0\nstate &lt;- c(S = S_0, I = I_0, R = R_0, V = V_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SIRV_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot results\npar(mfrow = c(1, 1))\nplot(output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n     xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"green\")\nlines(output$time, output$R, lwd = 2, col = \"red\")\nlines(output$time, output$V, lwd = 2, col = \"purple\")\nlegend( \"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\", \"Vaccinated\"),\n        lty=1, col = c(\"blue\", \"red\", \"green\", 'purple'), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "04_ODEs_solutions.html#solving-the-si-model-using-desolve",
    "href": "04_ODEs_solutions.html#solving-the-si-model-using-desolve",
    "title": "04. Ordinary differential equations (ODEs): Solutions",
    "section": "",
    "text": "The code below will solve the SI model with beta = 0.4 over 50 days with initial conditions S(0) = 99, I(0) = 1. Run the following lines including the plot() line to create a plot of the output\n\nlibrary(deSolve) # Load in the deSolve package. If the package is not installed, install using the install.packages() function\n# Define model function\n\nSI_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  N &lt;- S + I\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N\n  res &lt;- list(c(dS, dI))\n  return(res)\n}\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nstate &lt;- c( S = S_0, I = I_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SI_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar( mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines( output$time, output$I, lwd = 2, col = \"red\", type = \"l\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\"),\n       lty = c(1, 1), col = c(\"blue\", \"red\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\n\nAnswer: The number of infecteds as a higher intercept but same asymptote\n\n\n\nAnswer: The time steps of the model solution\n\n\n\nAnswer: Solution becomes less precise."
  },
  {
    "objectID": "04_ODEs_solutions.html#solving-the-sir-model-using-desolve",
    "href": "04_ODEs_solutions.html#solving-the-sir-model-using-desolve",
    "title": "04. Ordinary differential equations (ODEs): Solutions",
    "section": "",
    "text": "Now, let’s solve a Susceptible-Infected-Recovered set of ordinary equations. There are now states; Susceptible, Infected, Recovered. Once infected people recover at a rate gamma = 0.1. The code for the model function ONLY is given below.\n\n# Define model function \nSIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n  N &lt;- S + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dI, dR ))\n  return(res)\n}\n\n\n\n\n\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4, gamma = 0.1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nR_0 &lt;- 0\nstate &lt;- c(S = S_0, I = I_0, R = R_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar(mfrow = c(1, 1))\nplot(output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n     xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend( \"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n        lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\nHint: Recall that for an SIR model, the basic reproduction number, R_0 = beta / gamma\nAnswer: The epidemic does not take off\n\nparameters &lt;- c(beta = 0.09, gamma = 0.1)\n\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "04_ODEs_solutions.html#solving-the-seir-model-using-desolve",
    "href": "04_ODEs_solutions.html#solving-the-seir-model-using-desolve",
    "title": "04. Ordinary differential equations (ODEs): Solutions",
    "section": "",
    "text": "The code below has been written to solve a Susceptible-Exposed-Infected-Recovered model. In the model individuals can be in one of four states. Once infected, susceptible individuals move to the exposed class. Exposed individuals become infectious at a rate delta = 0.14.\n\n\n\n\n\n# Define model function \nSEIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[1]\n  E &lt;- state[2]\n  I &lt;- state[3]\n  R &lt;- state[4]\n  N &lt;- S + E + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  delta &lt;- parms[\"delta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I ) / N\n  dE &lt;- (beta * S * I) / N - delta * E\n  dI &lt;- delta * E - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dE, dI, dR))\n  return(res)\n}\n\n# Define parameters  \nparameters &lt;- c( beta = 0.4, gamma = 0.1, delta = 0.14)\n\n# Define time to run model\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0  &lt;- N - I_0\nR_0 &lt;- 0\nstate &lt;- c(S = S_0, E = 0, I = I_0, R = R_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SEIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlines(output$time, output$E, lwd = 2, col = \"cyan\")\nlegend(\"topright\", legend =  c(\"Susceptible\", \"Exposed\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\", \"cyan\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere we assume that susceptible individuals are vaccinated at a rate v = 0.05. The vaccine is 100% effective, so once vaccinated, individuals cannot become infected. HINT: you will need to create a new class V, you can assume that the initial number of vaccinated individuals is 0.\n\n# Define model function \nSIRV_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n  V &lt;- state[\"V\"]\n  N &lt;- S + I + R + V\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  v &lt;- parms[\"v\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N - v * S\n  dI &lt;- (beta * S * I) / N - gamma * I\n  dR &lt;- gamma * I\n  dV &lt;- v * S\n  res &lt;- list(c(dS, dI, dR, dV))\n  return(res)\n}\n\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4, gamma = 0.1, v = 0.05)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nR_0 &lt;- 0\nV_0 &lt;- 0\nstate &lt;- c(S = S_0, I = I_0, R = R_0, V = V_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SIRV_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot results\npar(mfrow = c(1, 1))\nplot(output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n     xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"green\")\nlines(output$time, output$R, lwd = 2, col = \"red\")\nlines(output$time, output$V, lwd = 2, col = \"purple\")\nlegend( \"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\", \"Vaccinated\"),\n        lty=1, col = c(\"blue\", \"red\", \"green\", 'purple'), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "timetable.html",
    "href": "timetable.html",
    "title": "Modern Techniques in Modelling",
    "section": "",
    "text": "Date\nTime\nSession\nTitle\nLead\n\n\n\n\n2024/09/09\n10.00-10.30\n01\nIntroduction\nYang/ Nick/ Oli\n\n\nMonday\n10.30-11.00\n02\nDifferent types of models\nYang/ Nick/ Oli\n\n\n\n11.00-11.30\n\nBREAK\n\n\n\n\n11.30-12.30\n03\nDiscrete time deterministic model, difference equations/ Euler\nBilly Quilty\n\n\n\n12.30-13.30\n\nLUNCH\n\n\n\n\n13.30-14.30\n03\nDiscrete time deterministic model, difference equations/ Euler (continued)\nBilly Quilty\n\n\n\n14.30-15.00\n\nBREAK\n\n\n\n\n15.00-16.00\n04\nODE models\nNick Davies"
  },
  {
    "objectID": "timetable.html#day-1",
    "href": "timetable.html#day-1",
    "title": "Modern Techniques in Modelling",
    "section": "",
    "text": "Date\nTime\nSession\nTitle\nLead\n\n\n\n\n2024/09/09\n10.00-10.30\n01\nIntroduction\nYang/ Nick/ Oli\n\n\nMonday\n10.30-11.00\n02\nDifferent types of models\nYang/ Nick/ Oli\n\n\n\n11.00-11.30\n\nBREAK\n\n\n\n\n11.30-12.30\n03\nDiscrete time deterministic model, difference equations/ Euler\nBilly Quilty\n\n\n\n12.30-13.30\n\nLUNCH\n\n\n\n\n13.30-14.30\n03\nDiscrete time deterministic model, difference equations/ Euler (continued)\nBilly Quilty\n\n\n\n14.30-15.00\n\nBREAK\n\n\n\n\n15.00-16.00\n04\nODE models\nNick Davies"
  },
  {
    "objectID": "timetable.html#day-2",
    "href": "timetable.html#day-2",
    "title": "Modern Techniques in Modelling",
    "section": "Day 2",
    "text": "Day 2\n\n\n\n\n\n\n\n\n\n\nDate\nTime\nSession\nTitle\nLead\n\n\n\n\n2024/09/10\n10.00-11.30\n04\nODE models (continued)\nNick Davies\n\n\nTuesday\n11.30-12.00\n\nBREAK\n\n\n\n\n12.00-12.45\n05\nODE with deSolve in a metapopulation model\nNick Davies\n\n\n\n12.45-13.30\n\nLUNCH\n\n\n\n\n13.30-15.00\n06\nSimulation, sensitivity, and sampling\nYang Liu\n\n\n\n15.00-15.30\n\nBREAK\n\n\n\n\n15.30-16.00\n07\nPresentation of modelling problem\nOliver Brady"
  },
  {
    "objectID": "timetable.html#day-3",
    "href": "timetable.html#day-3",
    "title": "Modern Techniques in Modelling",
    "section": "Day 3",
    "text": "Day 3\n\n\n\n\n\n\n\n\n\n\nDate\nTime\nSession\nTitle\nLead\n\n\n\n\n2024/09/11\n10.00-11.00\n08\nStochastic models discrete time\nNick Davies\n\n\nWednesday\n11.00-11.30\n\nBREAK\n\n\n\n\n11.30-12.30\n08\nStochastic models discrete time\nNick Davies\n\n\n\n12.30-13.30\n\nLUNCH\n\n\n\n\n13.30-14.30\n09\nNetwork models\nKath O’Reilly\n\n\n\n14.30-15.00\n\nBREAK\n\n\n\n\n15.00-16.00\n09\nNetwork models\nKath O’Reilly"
  },
  {
    "objectID": "timetable.html#day4",
    "href": "timetable.html#day4",
    "title": "Modern Techniques in Modelling",
    "section": "Day4",
    "text": "Day4\n\n\n\n\n\n\n\n\n\n\nDate\nTime\nSession\nTitle\nLead\n\n\n\n\n2024/09/12\n10.00-11.00\n10\nStochastic model continuous time\nSeb Funk\n\n\nThursday\n11.00-11.30\n\nBREAK\n\n\n\n\n11.30-12.30\n10\nStochastic model continuous time\nSeb Funk\n\n\n\n12.30-13.30\n\nLUNCH\n\n\n\n\n13.30-14.30\n11\nGroup work\nSeb Funk\n\n\n\n14.30-14.45\n\nBREAK\n\n\n\n\n14.45-15.45\n12\nGroup presentations\nSeb Funk\n\n\n\n15.45-16.15\n13\nWrap-up\nYang/ Nick/ Oli"
  },
  {
    "objectID": "09_Networks_solutions.html",
    "href": "09_Networks_solutions.html",
    "title": "09. Networks (solutions)",
    "section": "",
    "text": "# Network modelling, practical 1: Introduction to the igraph package\n\nlibrary(igraph) # For network functionality\nlibrary(data.table)\nlibrary(ggplot2)\n\n## 1. Building and plotting graphs\n\n# Complete graph with 4 nodes\ngr &lt;- make_full_graph(4)\nprint(gr)\nplot(gr)\n\n# Plot different graphs each with 16 vertices, but different connections \n# between vertices:\ngr &lt;- make_full_graph(16)\nplot(gr)\ngr &lt;- make_ring(16)\nplot(gr)\ngr &lt;- make_ring(16, circular = FALSE)\nplot(gr)\ngr &lt;- make_lattice(c(4, 4))\nplot(gr)\n\n# Compare a connected graph with 16 vertices to an Erdős-Rényi G(n, p) graph\n# with 16 vertices:\nplot(make_full_graph(16), layout = layout_in_circle)\nplot(sample_gnp(16, 0.2), layout = layout_in_circle)\n\n# Other random graphs: The \"small-world\" model by Watts and Strogatz, where \n# there are connections between neighbours, some of which are randomly rewired:\nplot(sample_smallworld(1, 16, 2, 0.1), layout = layout_in_circle)\n\n# The \"preferential attachment\" model by Barabási and Albert, which is built\n# by adding nodes one at a time, and each time a node is added, it is connected\n# to other nodes, where the connection is more likely to be made to a node that\n# already has more connections (a \"rich get richer\" dynamic).\nplot(sample_pa(16, directed = FALSE))\n\n\n## 2. Getting and setting properties of the graph\n\n# Start by making a new 'lattice' graph:\nnetwork &lt;- make_lattice(c(5, 5))\nprint(network)\nplot(network)\n\n# Some simple calculations: vcount() or ecount() give the number of vertices or \n# edges in the graph; degree() gives the number of neighbours of each vertex. \nvcount(network)\necount(network)\ndegree(network)\n\n# With igraph, you can get and set attributes of the entire graph using the\n# `$` operator. For example, let's set the graph's layout to a grid:\nnetwork$layout &lt;- layout_on_grid(network)\nprint(network)\nplot(network)\n\n# You can also modify properties of the vertices and of the edges, using\n# V() and E() respectively.\nV(network)$color &lt;- \"azure\"\nE(network)$color &lt;- \"pink\"\nplot(network) # lovely\n\n# You can use V(network)[[]] or E(network)[[]] to see the properties of the\n# vertices/edges laid out as a data frame:\nV(network)[[]]\nE(network)[[]]\n\n# The \"color\" attribute is now also listed when we print the network:\nnetwork\n\n# Finally, we can also use brackets [] to change properties of only certain\n# vertices/edges. \n\nV(network)[12]$color &lt;- \"orange\"\nplot(network)\n\nV(network)[color == \"orange\"]$color &lt;- \"pink\"\nplot(network)\n\n# Pink is contagious:\nV(network)[.nei(color == \"pink\")]$color &lt;- \"pink\"\nplot(network)\n\n# What happens if you re-run the last two lines above several times?\n\n# Other interesting attributes for vertices include:\nV(network)$label &lt;- NA        # text label for the vertices (set to NA for no labels)\nV(network)$size &lt;- 5          # size of vertex markers\nV(network)$shape &lt;- \"square\"  # shape of markers\nplot(network)\n# See ?igraph.plotting for more.\n\n\n## Bonus: Code a network model\n# Here is one possible way of doing it...\nnetwork &lt;- make_lattice(c(5, 5))\n\n# Set all vertices to \"susceptible\" except for one \"infected\"\nV(network)$state &lt;- \"S\"\nV(network)[1]$state &lt;- \"I\"\n\n# Pick plotting colours\ncolours &lt;- c(S = \"lightblue\", I = \"red\", R = \"pink\")\n\n# Print and loop through time steps\nt_max &lt;- 10\nfor (t in 1:t_max)\n{\n    # Plot network\n    plot(network, \n        vertex.color = colours[V(network)$state], \n        layout = layout_on_grid)\n    \n    # Pause so we can see animation\n    Sys.sleep(1.0)\n    \n    # Find \"infector\" vertices\n    infectors &lt;- V(network)[state == \"I\"]\n    \n    # Infect susceptible neighbours of infectors\n    V(network)[.nei(infectors) & state == \"S\"]$state &lt;- \"I\"\n    \n    # Recover infectors\n    V(network)[infectors]$state &lt;- \"R\"\n}"
  },
  {
    "objectID": "09_Networks_solutions.html#practical-1.-introduction-to-the-igraph-package",
    "href": "09_Networks_solutions.html#practical-1.-introduction-to-the-igraph-package",
    "title": "09. Networks (solutions)",
    "section": "",
    "text": "# Network modelling, practical 1: Introduction to the igraph package\n\nlibrary(igraph) # For network functionality\nlibrary(data.table)\nlibrary(ggplot2)\n\n## 1. Building and plotting graphs\n\n# Complete graph with 4 nodes\ngr &lt;- make_full_graph(4)\nprint(gr)\nplot(gr)\n\n# Plot different graphs each with 16 vertices, but different connections \n# between vertices:\ngr &lt;- make_full_graph(16)\nplot(gr)\ngr &lt;- make_ring(16)\nplot(gr)\ngr &lt;- make_ring(16, circular = FALSE)\nplot(gr)\ngr &lt;- make_lattice(c(4, 4))\nplot(gr)\n\n# Compare a connected graph with 16 vertices to an Erdős-Rényi G(n, p) graph\n# with 16 vertices:\nplot(make_full_graph(16), layout = layout_in_circle)\nplot(sample_gnp(16, 0.2), layout = layout_in_circle)\n\n# Other random graphs: The \"small-world\" model by Watts and Strogatz, where \n# there are connections between neighbours, some of which are randomly rewired:\nplot(sample_smallworld(1, 16, 2, 0.1), layout = layout_in_circle)\n\n# The \"preferential attachment\" model by Barabási and Albert, which is built\n# by adding nodes one at a time, and each time a node is added, it is connected\n# to other nodes, where the connection is more likely to be made to a node that\n# already has more connections (a \"rich get richer\" dynamic).\nplot(sample_pa(16, directed = FALSE))\n\n\n## 2. Getting and setting properties of the graph\n\n# Start by making a new 'lattice' graph:\nnetwork &lt;- make_lattice(c(5, 5))\nprint(network)\nplot(network)\n\n# Some simple calculations: vcount() or ecount() give the number of vertices or \n# edges in the graph; degree() gives the number of neighbours of each vertex. \nvcount(network)\necount(network)\ndegree(network)\n\n# With igraph, you can get and set attributes of the entire graph using the\n# `$` operator. For example, let's set the graph's layout to a grid:\nnetwork$layout &lt;- layout_on_grid(network)\nprint(network)\nplot(network)\n\n# You can also modify properties of the vertices and of the edges, using\n# V() and E() respectively.\nV(network)$color &lt;- \"azure\"\nE(network)$color &lt;- \"pink\"\nplot(network) # lovely\n\n# You can use V(network)[[]] or E(network)[[]] to see the properties of the\n# vertices/edges laid out as a data frame:\nV(network)[[]]\nE(network)[[]]\n\n# The \"color\" attribute is now also listed when we print the network:\nnetwork\n\n# Finally, we can also use brackets [] to change properties of only certain\n# vertices/edges. \n\nV(network)[12]$color &lt;- \"orange\"\nplot(network)\n\nV(network)[color == \"orange\"]$color &lt;- \"pink\"\nplot(network)\n\n# Pink is contagious:\nV(network)[.nei(color == \"pink\")]$color &lt;- \"pink\"\nplot(network)\n\n# What happens if you re-run the last two lines above several times?\n\n# Other interesting attributes for vertices include:\nV(network)$label &lt;- NA        # text label for the vertices (set to NA for no labels)\nV(network)$size &lt;- 5          # size of vertex markers\nV(network)$shape &lt;- \"square\"  # shape of markers\nplot(network)\n# See ?igraph.plotting for more.\n\n\n## Bonus: Code a network model\n# Here is one possible way of doing it...\nnetwork &lt;- make_lattice(c(5, 5))\n\n# Set all vertices to \"susceptible\" except for one \"infected\"\nV(network)$state &lt;- \"S\"\nV(network)[1]$state &lt;- \"I\"\n\n# Pick plotting colours\ncolours &lt;- c(S = \"lightblue\", I = \"red\", R = \"pink\")\n\n# Print and loop through time steps\nt_max &lt;- 10\nfor (t in 1:t_max)\n{\n    # Plot network\n    plot(network, \n        vertex.color = colours[V(network)$state], \n        layout = layout_on_grid)\n    \n    # Pause so we can see animation\n    Sys.sleep(1.0)\n    \n    # Find \"infector\" vertices\n    infectors &lt;- V(network)[state == \"I\"]\n    \n    # Infect susceptible neighbours of infectors\n    V(network)[.nei(infectors) & state == \"S\"]$state &lt;- \"I\"\n    \n    # Recover infectors\n    V(network)[infectors]$state &lt;- \"R\"\n}"
  },
  {
    "objectID": "09_Networks_solutions.html#practical-2.-a-network-model-of-mpox-transmission",
    "href": "09_Networks_solutions.html#practical-2.-a-network-model-of-mpox-transmission",
    "title": "09. Networks (solutions)",
    "section": "Practical 2. A network model of mpox transmission",
    "text": "Practical 2. A network model of mpox transmission\n\n# Network modelling, practical 2: A network model of mpox transmission\n\nlibrary(igraph)\nlibrary(data.table)\nlibrary(ggplot2)\n\n\n### Setting up the network\n\n# Set up a transmission network of n nodes by preferential attachment with \n# affinity proportional to degree^m.\ncreate_network &lt;- function(n, d, layout = layout_nicely)\n{\n    # Create the network by preferential attachment, passing on the parameters \n    # n and power\n    network &lt;- sample_pa(n, d, directed = FALSE)\n\n    # Add the \"state\" attribute to the vertices of the network, which can be\n    # \"S\", \"I\", \"R\", or \"V\". \n    # Start out everyone as susceptible ...\n    V(network)$state &lt;- \"S\"\n    # ... except make 5 random individuals infectious.\n    V(network)$state[sample(vcount(network), 5, prob = degree(network))] &lt;- \"I\"\n\n    # Reorder vertices so they go in order from least to most connected. This\n    # is to help with degree-targeted vaccination, and also to make the \n    # most connected vertices plot on top so they don't get hidden. \n    network &lt;- permute(network, rank(degree(network), ties.method = \"first\"))\n    # Set the network layout so it doesn't change every time it's plotted.\n    network$layout &lt;- layout(network)\n    \n    return (network)\n}\n\n## See how the parameter d to create_network changes the network structure\nnet &lt;- create_network(40, 0)\nplot(net)\n\nnet &lt;- create_network(40, 1)\nplot(net)\n\nnet &lt;- create_network(40, 2)\nplot(net)\n\n# Plot a network, highlighting the degree of each node by different colours.\nplot_degree &lt;- function(network)\n{\n    # Set up palette\n    colors &lt;- hcl.colors(5, \"Zissou 1\")\n    \n    # Classify nodes by degree\n    deg &lt;- cut(degree(network), \n        breaks = c(1, 2, 5, 10, 20, Inf),\n        labels = c(\"1\", \"2-4\", \"5-9\", \"10-19\", \"20+\"),\n        include.lowest = TRUE, right = FALSE)\n\n    # Plot network\n    plot(network, \n        vertex.color = colors[deg],\n        vertex.label = NA,\n        vertex.size = 4)\n    legend(\"topright\", levels(deg), fill = colors, title = \"Degree\")\n}\n\n## Look at the degree distribution plotted for different values of d\nnet &lt;- create_network(500, 1)\nplot_degree(net)\n\nnet &lt;- create_network(500, 1.5)\nplot_degree(net)\n\nnet &lt;- create_network(500, 2)\nplot_degree(net)\n\n# Plot a network, colouring by state (S/I/R/V).\nplot_state &lt;- function(network)\n{\n    # Set up palette\n    colors &lt;- c(S = \"lightblue\", I = \"red\", R = \"darkblue\", V = \"white\")\n    \n    # Plot network\n    plot(network, \n        vertex.color = colors[V(network)$state], \n        vertex.label = NA,\n        vertex.size = 4)\n    legend(\"topright\", names(colors), fill = colors, title = \"State\")\n}\n\n## Test the plot_state function\nnet &lt;- create_network(500, 1)\nplot_state(net)\n\n\n### Running the model\n\n# Enact one step of the network model: infectious individuals infect \n# susceptible neighbours with probability p, and recover after one time step.\nnetwork_step &lt;- function(net, p)\n{\n    # Identify all susceptible neighbours of infectious individuals, \n    # who are \"at risk\" of infection\n    at_risk &lt;- V(net)[state == \"S\" & .nei(state == \"I\")]\n    \n    # Use the transmission probability to select who gets exposed from\n    # among those at risk\n    exposed &lt;- at_risk[runif(length(at_risk)) &lt; p]\n    \n    # All currently infectious individuals will recover\n    V(net)[state == \"I\"]$state &lt;- \"R\"\n    \n    # All exposed individuals become infectious\n    V(net)[exposed]$state &lt;- \"I\"\n\n    return (net)\n}\n\n# Run the transmission model on the network with maximum simulation time t_max\n# and transmission probability p; plot the network as the model is running if\n# animate = TRUE.\nrun_model &lt;- function(net, t_max, p, animate = FALSE)\n{\n    # Plot network degree\n    if (animate) {\n        plot_degree(net)\n        Sys.sleep(2.0)\n    }\n\n    # Set up results\n    dt &lt;- list()\n\n    # Iterate over each time step\n    for (t in 0:t_max)\n    {\n        # Store results\n        dt[[length(dt) + 1]] &lt;- data.table(\n            S = sum(V(net)$state == \"S\"),\n            I = sum(V(net)$state == \"I\"),\n            R = sum(V(net)$state == \"R\"),\n            V = sum(V(net)$state == \"V\")\n        )\n\n        # Plot current state\n        if (animate) {\n            Sys.sleep(0.5)\n            plot_state(net)\n        }\n        \n        # Stop early if no infectious individuals are left\n        if (!any(V(net)$state == \"I\")) {\n            break;\n        }\n\n        # Run one step of the network model\n        net &lt;- network_step(net, p)\n    }\n    \n    # Return results, including empirical calculation of Rt\n    results &lt;- rbindlist(dt, idcol = \"t\")\n    results$Rt &lt;- results$I / shift(results$I, 1) # new infections per new infection last time step\n    return (results)\n}\n\n\n## Run an example simulation\nnet &lt;- create_network(500, 1)\nrun_model(net, 100, 0.8, TRUE)\n\n\n### Bonus material: vaccination and multiple runs\n\n# Vaccinate a fraction v of the nodes in the network. The parameter k, between\n# -1 and 1, determines the association between network degree and vaccination.\nvaccinate_network &lt;- function(network, v, k)\n{\n    # Count total population (n) and number to vaccinate (nv)\n    n &lt;- vcount(network)\n    nv &lt;- rbinom(1, n, v)\n\n    # If k &gt; 0, vaccinate the nv most-connected individuals; if k &lt;= 0, \n    # vaccinate the nv least-connected individuals.\n    if (k &gt; 0) {\n        target &lt;- (n - nv + 1):n\n    } else {\n        target &lt;- 1:nv\n    }\n    V(network)[target]$state &lt;- \"V\"\n    \n    # Now randomly shuffle the state of a fraction 1 - abs(k) of individuals.\n    shuffle &lt;- which(rbinom(n, 1, 1 - abs(k)) == 1)\n    V(network)[shuffle]$state &lt;- sample(V(network)[shuffle]$state)\n\n    return (network)\n}\n\n# Run the model nsim times with parameters in params (n, d, v, k, t_max, p),\n# showing the animated network the first nanim times, and returning a data.table\n# with the results of each simulation.\nrun_scenario &lt;- function(params, nsim, nanim = 1)\n{\n    results &lt;- list()\n    \n    for (sim in 1:nsim)\n    {\n        net &lt;- create_network(params$n, params$d)\n        net &lt;- vaccinate_network(net, params$v, params$k)\n\n        results[[sim]] &lt;- run_model(net, params$t_max, params$p, animate = sim &lt;= nanim)\n        \n        cat(\".\")\n    }\n    cat(\"\\n\");\n    \n    results &lt;- rbindlist(results, idcol = \"run\")\n    return (results)\n}\n\n## Test multiple runs\nparams &lt;- list(\n    n = 500,\n    d = 0,\n    p = 0.8,\n    v = 0.3,\n    k = -0.5,\n    t_max = 100\n)\n\n# Do a test run!\nx &lt;- run_scenario(params, nsim = 50)\nggplot(x) +\n    geom_line(aes(x = t, y = R, group = run))\n\nReturn to the practical here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Content overview",
    "section": "",
    "text": "Pre-course material - please review before the short course\nSession 1 - Introduction: Slides\nSession 2 - Types of models: Slides\nSession 3 - Discrete time deterministic models: Slides, Practical, Solutions\nSession 4 - Ordinary differential equations: Slides, Practical, Solutions\nSession 5 - Metapopulations with ODEs: Slides, Practical, Solutions\nSession 6 - Sensitivity analysis & sampling: Slides, Practical, Solutions\nSession 8 -\nSession 9 - Network modelling: Slides, Practical, Solutions\nSession 10 -"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Your course organisers are Oliver Brady, Nicholas Davies, and Yang Liu.\nYour course administrator is .\nOther lectures and demonstrators include Billy Quilty, Kath O’Reilly, Seb Funk."
  },
  {
    "objectID": "about.html#who-we-are",
    "href": "about.html#who-we-are",
    "title": "About",
    "section": "",
    "text": "Your course organisers are Oliver Brady, Nicholas Davies, and Yang Liu.\nYour course administrator is .\nOther lectures and demonstrators include Billy Quilty, Kath O’Reilly, Seb Funk."
  },
  {
    "objectID": "about.html#who-you-are-scope-of-the-course",
    "href": "about.html#who-you-are-scope-of-the-course",
    "title": "About",
    "section": "Who you are (= scope of the course)",
    "text": "Who you are (= scope of the course)\n\nIndividuals with some exposure to the theory and use of infectious disease modelling & like to start coding their own models using R OR\nIndividuals who know some R but do not have experience using R to code infectious disease models OR\nIndividuals who will be conducting research using infectious disease models in R OR\nIndividuals who want a deeper understanding of techniques for implementing models."
  },
  {
    "objectID": "about.html#other-short-courses-lshtm-you-may-be-interested-in",
    "href": "about.html#other-short-courses-lshtm-you-may-be-interested-in",
    "title": "About",
    "section": "Other short courses @ LSHTM you may be interested in",
    "text": "Other short courses @ LSHTM you may be interested in\nModel fitting and inference for infectious disease dynamics (organised by Seb Funk)\nIntroduction to infectious disease modelling and its applications (organised by Emilia Vynnycky and Richard White)"
  },
  {
    "objectID": "06_SensitivitySampling_solutions.html",
    "href": "06_SensitivitySampling_solutions.html",
    "title": "06. Sensitivity Analysis & Sampling: Practical",
    "section": "",
    "text": "Click here to return to the practical."
  },
  {
    "objectID": "06_SensitivitySampling_solutions.html#one-way-sensitivity-analyses",
    "href": "06_SensitivitySampling_solutions.html#one-way-sensitivity-analyses",
    "title": "06. Sensitivity Analysis & Sampling: Practical",
    "section": "(1) One-way sensitivity analyses",
    "text": "(1) One-way sensitivity analyses\nFirst, let’s run an ODE model. Download and open up the SIRmodel.R\n\n(a) Which functions are in here?\nAnswer: solveODE() and SIR_model()\n\n\n(b) What are the arguments of the first function?\nAnswer: (1) the parameter values lists, (2) Argument to plot everything, (3) number of row to plot (4) number of cols to plot\n\n\n(c) What is the output of the first function?\nAnswer: maximum prevalence through the epidemic\n# First let's clear our workspace, remove plots and load the libraries we need\nrm(list=ls())\ndev.off()\nlibrary(deSolve)\nlibrary(ggplot2)\n\n# Let's read in these functions so we have them to hand\nsource(\"SIRmodel.R\")\n\n# Let's choose a beta value of 0.4 and a gamma value of 0.2\nmax.prevalence &lt;- solveODE(parameters &lt;- c(beta = 0.4, gamma = 0.2))\nprint(max.prevalence)\n\n# Now let's look at the effect of the maximum prevalence of the epidemic across \n# gamma = 0.1 -1.0 (increment on 0.1)\ngamma.vec &lt;- seq(0.1, 1.0, by = 0.1)\n\n# initialise max/prevalence container\nmax.prevalence &lt;- vector()\n\n# Add in a loop to make this happen\nfor (gamma.val in gamma.vec){\n  mp = solveODE(parameters = c(beta = 0.4, gamma = gamma.val),\n                                         plot.all.results = FALSE)\n  max.prevalence = c(max.prevalence, mp)\n}\n\n# Now we have our max.prevalence, we need to plot this against our \n# infectiousness duration - plot max.prevalence as a function of the \n# \\*infectiousness duration\\*\n\npar(new=FALSE)\npar(mfrow=c(1,1))\n\nplot(1/gamma.vec, \n     max.prevalence, \n     type = \"b\",\n     xlab = \"Infectiousness Duration (days)\",\n     ylab = \"Maximum Prevalence\",\n     main = \"One-way uncertainty analysis\")\n\n# Now try to increase the resolution of gamma to get a better idea of the \n# relationship but remember to clear max.prevalence first!\n\n# You could try and replace gamma.vec = seq(0.1, 1.0, by = 0.1) with\ninf.duration = 1:10\ngamma.vec = 1/inf.duration\n\n\n(d) Describe in words the qualitative relationship\nAnswer: There is no epidemic until the infectiousness duration is &gt; 2 days (R0 &gt; 1) after that there is a linear increase in the maximum prevalence until gamma = 6, then there is a diminishing increase in the maximum prevalence."
  },
  {
    "objectID": "06_SensitivitySampling_solutions.html#monte-carlo-sampling",
    "href": "06_SensitivitySampling_solutions.html#monte-carlo-sampling",
    "title": "06. Sensitivity Analysis & Sampling: Practical",
    "section": "(2) Monte Carlo Sampling",
    "text": "(2) Monte Carlo Sampling\nNow suppose that we have a previous epidemiological study that suggested that R0 has a mean value of 5, but uncertainty within the range of [-1, +1]. However, we still don’t know whether the infectiousness period is 1 day or 10 days. We will now use the functions in SIRmodel_R0.R to make a similar plot as above, but this time, incorporate the uncertainty of R0 for each discrete value of gamma. We’re going to first use a direct Monte Carlo Sampling method.\n# Read in our set of functions in SIRmodel_R0.R\nsource(\"SIRmodel_R0.R\")\n\n# First, let's set a fixed seed for the random number generator\n# this will allow us to run the code again and retrieve the same 'simulation'\nset.seed(2019)\n\n# Now, draw R0 1,000 times from a suitable distribution (e.g. normal)\nr0.all = rnorm(1000, 5, 0.5)\nsize.df = length(r0.all) * length(gamma.vec)\n\n# initialise max.prevalence again, this time it needs to be a dataframe \n# or a matrix\nmax.prevalence = data.frame(r0.value = vector(mode = \"numeric\", \n                                            length = size.df),\n                            gamma = vector(mode = \"numeric\", \n                                           length = size.df),\n                            max.prev = vector(mode = \"numeric\", \n                                              length = size.df))\nindex = 0\n\n# create a loop over each of these R0 values in turn\nfor (r0.val in r0.all){\n# create a loop over each of these Gamma values in turn\n    for (gamma.val in gamma.vec){\n    index = index + 1\n    mp = solveODE_2(parameters = c(R0 = r0.val, gamma = gamma.val))\n    max.prevalence[index, \"r0.value\"] = r0.val\n    max.prevalence[index, \"gamma\"] = gamma.val\n    max.prevalence[index, \"max.prev\"] = mp\n    }\n}\n\n# Take a look at max.prevalence by using the 'head() function\nhead(max.prevalence)\n\n(e) How have we saved the output?\nAnswer: using ‘long’ formatting – see the ggplot pre-course material\nNow plot this output using the R function MCplot() in SIRmodel_R0.R\nMCplot(max.prevalence)\n\n\n(f) What conclusions can you draw from the plot?\nAnswer: Increasing the rate of recovery reduces the max prevalence. However, the uncertainty in R0 has a larger impact on the maximum prevalence than infectious duration. In fact, until the infectiousness duration decreases below 4 days, the value of R0 is the important parameter in determining prevalence."
  },
  {
    "objectID": "06_SensitivitySampling_solutions.html#latin-hypercube-sampling-lhs-vs-monte-carlo-sampling",
    "href": "06_SensitivitySampling_solutions.html#latin-hypercube-sampling-lhs-vs-monte-carlo-sampling",
    "title": "06. Sensitivity Analysis & Sampling: Practical",
    "section": "(3) Latin hypercube sampling (LHS) vs Monte Carlo Sampling",
    "text": "(3) Latin hypercube sampling (LHS) vs Monte Carlo Sampling\n# First let's load in the library we'll need for later\nlibrary(lhs)\n\n# We're going to first sample directly from a full distribution uniform \n# distribution from 0 to 1. How many samples will we need to take? \n# Let's try a few options and see how well they do\n\npar(mfrow=c(3,2))\nhist(rnorm(10))\nhist(rnorm(100))\nhist(rnorm(1000))\nhist(rnorm(10000))\nhist(rnorm(20000))\n\n# Now let's plot the sample sizes against the variance of the sample distribution\n\nplot(\n    c(10,100,1000,10000,50000,100000),\n    c(var(rnorm(10)), var(rnorm(100)), var(rnorm(1000)), var(rnorm(10000)), \n      var(rnorm(50000)), var(rnorm(100000))),\n    ylab = \"variance\", main = \"Variance of sampled normal\"\n    )\nabline(h = 1)\n\n# Let's now use 100 samples to see the difference between a Monte Carlo \n# sampling and a LHS sampling approach.\n# Pick some small number of samples\nn &lt;- 100\n\n# First we're going to sample 100 times from a random sample\nmc_unif &lt;- runif(n)\n\n# 100 lh samples across 1 parameter\nlatin_unif &lt;- randomLHS(n, 1)\n\n# plot these two distribution\ndev.off()\npar(mfrow=c(3,2))\nhist(mc_unif)\nhist(latin_unif)\n\n# You can see how the Latin Hypercube does a great job of sampling evenly \n# across the distribution. Let's now sample from a Normal distribution using \n# a random monte carlo sample across the whole distribution.\nmc_norm &lt;- rnorm(n, mean = 0, sd = 1)\n\n# How do we sample using an LHS? We use the previous numbers generated from the \n# uniform LHS to draw samples from the Normal using the Inverse Cumulative \n# Sampling.\nlatin_norm &lt;- qnorm(latin_unif, mean = 0, sd = 1)\n\n# plot these two normal distributions\nhist(mc_norm)\nhist(latin_norm)\n\n# the latin hypercube sample looks much better! Why does this work?\n# first let's look at the norm probability distibution\nx &lt;- seq(-6, 6, by = 0.1) # random variable X\nnormdens &lt;- dnorm(x, mean = 0, sd = 1) # prob distribution, f(X)\nnormcumul &lt;- pnorm(x, mean = 0, sd = 1) # cumulative distribution, F(X)\n\nplot(x, normdens, \"l\")\nplot(x, normcumul, \"l\")\n\n# Most of the density is in the middle range of values (-1 to 1).\n\n# So we want a method to sample from this more often than the other areas in \n# the distribution. Specifically, we want to sample values from X proportionally \n# to the probability of those values occuring. Let's generate some samples \n# between 0-1. These can be values on our Y-axis. Then, if we ask what is the \n# value of the cumulative distribution that corresponds to these uniform \n# values we are taking the inverse for illustration let's just choose 10 points.\nex_latin &lt;- randomLHS(10, 1)\n\n# which X values are given by using these as the Y value (denoted by \"X\"s)?\nabline(h = ex_latin, col = \"red\")\npoints(qnorm(ex_latin, mean = 0, sd = 1), y=rep(0,10), pc = \"x\")\n\n# You can see that the samples are clustered around the middle: in areas of X \n# with higher density, the gradient of the cumluative distribution (F(X)) will \n# be very steep, causing more values between 0 and 1 to map to this range of X \n# with high density That is, F\\^{-1}(R) = X where R is a uniform random number \n# between 0 and 1.\n\n# So, you can sample from any distribution whose cumluative function is \n# 'invertable' by plugging in uniform random numbers to the inverse cumulative \n# function of your new distribution. For more information check out: \n# https://en.wikipedia.org/wiki/Inverse_transform_sampling\n\n# Likewise, to perform LHS on a uni- or mulitvariate non-uniform distribution, \n# we can transform our LHS samples from a uniform distribution as above."
  },
  {
    "objectID": "04_ODEs_practical.html",
    "href": "04_ODEs_practical.html",
    "title": "04. Ordinary differential equations (ODEs)",
    "section": "",
    "text": "The code below will solve the SI model with beta = 0.4 over 50 days with initial conditions S(0) = 99, I(0) = 1. Run the following lines including the plot() line to create a plot of the output\n\nlibrary(deSolve) # Load in the deSolve package. If the package is not installed, install using the install.packages() function\n# Define model function\n\nSI_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  N &lt;- S + I\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N\n  res &lt;- list(c(dS, dI))\n  return(res)\n}\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nstate &lt;- c( S = S_0, I = I_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SI_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar( mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines( output$time, output$I, lwd = 2, col = \"red\", type = \"l\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\"),\n       lty = c(1, 1), col = c(\"blue\", \"red\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow, let’s solve a Susceptible-Infected-Recovered set of ordinary equations. There are now states; Susceptible, Infected, Recovered. Once infected people recover at a rate gamma = 0.1. The code for the model function ONLY is given below.\n\n# Define model function \nSIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n  N &lt;- S + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dI, dR ))\n  return(res)\n}\n\n\n\n\n\n\n# Define parameter values\nparameters &lt;-\n\n# Define initial conditions\nN &lt;- 100\n\nstate &lt;-\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar(mfrow = c(1, 1))\nplot(output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n     xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend( \"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n        lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")\n\n\n\n\nHint: Recall that for an SIR model, the basic reproduction number, R_0 = beta / gamma\n\nparameters &lt;- \n\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\nThe code below has been written to solve a Susceptible-Exposed-Infected-Recovered model. In the model individuals can be in one of four states. Once infected, susceptible individuals move to the exposed class. Exposed individuals become infectious at a rate delta = 0.14.\n\n\n\n\n\n# Define model function \nSEIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[1]\n  I &lt;- state[2]\n  R &lt;- state[3]\n  N &lt;- S + E + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  delta &lt;- parms[\"delta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I ) / N\n  dE &lt;- (beta * S * I) / N - delta * E\n  dI &lt;- delta * E - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dI, dR))\n  return(res)\n}\n\n# Define parameters  \nparameters &lt;- c( beta = 0.4, gamma = 0.1)\n\n# Define time to run model\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0  &lt;- N - I_0\nR_0 &lt;- 0\nstate &lt;- c(S = S_0, E = 0, I = I_0, R = R_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SEIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlines(output$time, output$E, lwd = 2, col = \"cyan\")\nlegend(\"topright\", legend =  c(\"Susceptible\", \"Exposed\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\", \"cyan\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\nHere we assume that susceptible individuals are vaccinated at a rate v = 0.05. The vaccine is 100% effective, so once vaccinated, individuals cannot become infected. HINT: you will need to create a new class V, you can assume that the initial number of vaccinated individuals is 0.\nSolutions to this practical can be accessed here."
  },
  {
    "objectID": "04_ODEs_practical.html#solving-the-si-model-using-desolve",
    "href": "04_ODEs_practical.html#solving-the-si-model-using-desolve",
    "title": "04. Ordinary differential equations (ODEs)",
    "section": "",
    "text": "The code below will solve the SI model with beta = 0.4 over 50 days with initial conditions S(0) = 99, I(0) = 1. Run the following lines including the plot() line to create a plot of the output\n\nlibrary(deSolve) # Load in the deSolve package. If the package is not installed, install using the install.packages() function\n# Define model function\n\nSI_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  N &lt;- S + I\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N\n  res &lt;- list(c(dS, dI))\n  return(res)\n}\n\n# Define parameter values\nparameters &lt;- c(beta = 0.4)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0 &lt;- N - I_0\nstate &lt;- c( S = S_0, I = I_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SI_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar( mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines( output$time, output$I, lwd = 2, col = \"red\", type = \"l\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\"),\n       lty = c(1, 1), col = c(\"blue\", \"red\"), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "04_ODEs_practical.html#solving-the-sir-model-using-desolve",
    "href": "04_ODEs_practical.html#solving-the-sir-model-using-desolve",
    "title": "04. Ordinary differential equations (ODEs)",
    "section": "",
    "text": "Now, let’s solve a Susceptible-Infected-Recovered set of ordinary equations. There are now states; Susceptible, Infected, Recovered. Once infected people recover at a rate gamma = 0.1. The code for the model function ONLY is given below.\n\n# Define model function \nSIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n  N &lt;- S + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I) / N\n  dI &lt;- (beta * S * I) / N - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dI, dR ))\n  return(res)\n}\n\n\n\n\n\n\n# Define parameter values\nparameters &lt;-\n\n# Define initial conditions\nN &lt;- 100\n\nstate &lt;-\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# Plot output\npar(mfrow = c(1, 1))\nplot(output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n     xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend( \"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n        lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")\n\n\n\n\nHint: Recall that for an SIR model, the basic reproduction number, R_0 = beta / gamma\n\nparameters &lt;- \n\noutput_raw &lt;- ode(y = state, times = times, func = SIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlegend(\"topright\", legend = c(\"Susceptible\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\"), lwd = 2, bty = \"n\")"
  },
  {
    "objectID": "04_ODEs_practical.html#solving-the-seir-model-using-desolve",
    "href": "04_ODEs_practical.html#solving-the-seir-model-using-desolve",
    "title": "04. Ordinary differential equations (ODEs)",
    "section": "",
    "text": "The code below has been written to solve a Susceptible-Exposed-Infected-Recovered model. In the model individuals can be in one of four states. Once infected, susceptible individuals move to the exposed class. Exposed individuals become infectious at a rate delta = 0.14.\n\n\n\n\n\n# Define model function \nSEIR_model &lt;- function(times, state, parms){\n  ## Define variables\n  S &lt;- state[1]\n  I &lt;- state[2]\n  R &lt;- state[3]\n  N &lt;- S + E + I + R\n  # Extract parameters\n  beta &lt;- parms[\"beta\"]\n  gamma &lt;- parms[\"gamma\"]\n  delta &lt;- parms[\"delta\"]\n  # Define differential equations\n  dS &lt;- - (beta * S * I ) / N\n  dE &lt;- (beta * S * I) / N - delta * E\n  dI &lt;- delta * E - gamma * I\n  dR &lt;- gamma * I\n  res &lt;- list(c(dS, dI, dR))\n  return(res)\n}\n\n# Define parameters  \nparameters &lt;- c( beta = 0.4, gamma = 0.1)\n\n# Define time to run model\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Define initial conditions\nN &lt;- 100\nI_0 &lt;- 1\nS_0  &lt;- N - I_0\nR_0 &lt;- 0\nstate &lt;- c(S = S_0, E = 0, I = I_0, R = R_0)\n\n# Solve equations\noutput_raw &lt;- ode(y = state, times = times, func = SEIR_model, parms = parameters,\n                  method = \"rk4\")\n# Convert to data frame for easy extraction of columns\noutput &lt;- as.data.frame(output_raw)\n\n# plot results\npar(mfrow = c(1, 1))\nplot( output$time, output$S, type = \"l\", col = \"blue\", lwd = 2, ylim = c(0, N),\n      xlab = \"Time\", ylab = \"Number\")\nlines(output$time, output$I, lwd = 2, col = \"red\")\nlines(output$time, output$R, lwd = 2, col = \"green\")\nlines(output$time, output$E, lwd = 2, col = \"cyan\")\nlegend(\"topright\", legend =  c(\"Susceptible\", \"Exposed\", \"Infected\", \"Recovered\"),\n       lty = 1, col = c(\"blue\", \"red\", \"green\", \"cyan\"), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\nHere we assume that susceptible individuals are vaccinated at a rate v = 0.05. The vaccine is 100% effective, so once vaccinated, individuals cannot become infected. HINT: you will need to create a new class V, you can assume that the initial number of vaccinated individuals is 0.\nSolutions to this practical can be accessed here."
  }
]